<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 12 结构体</title>
    <link href="/2024/11/11/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2012%20%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2024/11/11/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2012%20%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h2 id="结构体语法"><a href="#结构体语法" class="headerlink" title="结构体语法"></a>结构体语法</h2><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>一个结构体由几部分组成：</p><ul><li>通过关键字 <code>struct</code> 定义</li><li>一个清晰明确的结构体 <code>名称</code></li><li>几个有名字的结构体 <code>字段</code></li></ul><p>例如, 以下结构体定义了某网站的用户：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    active: <span class="hljs-type">bool</span>,<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体名称是 <code>User</code>，拥有 4 个字段，且每个字段都有对应的字段名及类型声明，例如 <code>username</code> 代表了用户名，是一个可变的 <code>String</code> 类型。</p><h3 id="创建结构体实例"><a href="#创建结构体实例" class="headerlink" title="创建结构体实例"></a>创建结构体实例</h3><p>有几点值得注意:</p><ul><li>初始化实例时，<strong>每个字段</strong>都需要进行初始化</li><li>初始化时的字段顺序<strong>不需要</strong>和结构体定义时的顺序一致</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>active: <span class="hljs-literal">true</span>,<br>sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="访问结构体字段"><a href="#访问结构体字段" class="headerlink" title="访问结构体字段"></a>访问结构体字段</h3><p>通过 <code>.</code> 操作符即可访问结构体实例内部的字段值，也可以修改它们：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user1</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>active: <span class="hljs-literal">true</span>,<br>sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br><br>user1.email = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;anotheremail@example.com&quot;</span>);<br></code></pre></td></tr></table></figure><p>需要注意：</p><ul><li>必须要将结构体实例声明为可变的，才能修改其中的字段</li><li>Rust 不支持将某个结构体某个字段标记为可变。</li></ul><h3 id="简化结构体创建"><a href="#简化结构体创建" class="headerlink" title="简化结构体创建"></a>简化结构体创建</h3><p>当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟 TypeScript 中一模一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        email,<br>        username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a>结构体更新语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>..user1<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>..</code> 语法表明凡是我们没有显式声明的字段，全部从 <code>user1</code> 中自动获取。需要注意的是 <code>..user1</code> <strong>必须在结构体的尾部使用</strong>。</p><blockquote><p>结构体更新语法跟赋值语句 <code>=</code> 非常相像，因此在上面代码中，<code>user1</code> 的部分字段所有权被转移到 <code>user2</code> 中：<code>username</code> 字段发生了所有权转移，作为结果，<code>user1</code> 无法再被使用。</p></blockquote><h2 id="元组结构体-Tuple-Struct"><a href="#元组结构体-Tuple-Struct" class="headerlink" title="元组结构体(Tuple Struct)"></a>元组结构体(Tuple Struct)</h2><p>结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = <span class="hljs-title function_ invoke__">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的 <code>Point</code> 元组结构体，众所周知 3D 点是 <code>(x, y, z)</code> 形式的坐标点，因此我们无需再为内部的字段逐一命名为：<code>x</code>, <code>y</code>, <code>z</code>。</p><h2 id="单元结构体-Unit-like-Struct"><a href="#单元结构体-Unit-like-Struct" class="headerlink" title="单元结构体(Unit-like Struct)"></a>单元结构体(Unit-like Struct)</h2><p>如果你定义一个类型，但是不关心该类型的内容，只关心它的行为时，就可以使用 <code>单元结构体</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlwaysEqual</span>;<br><br><span class="hljs-comment">// 实例化不需要花括号或圆括号</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">subject</span> = AlwaysEqual;<br><br><span class="hljs-comment">// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SomeTrait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AlwaysEqual</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h2><ul><li>实现了 <code>Copy</code> 特征的类型无需所有权转移，可以直接在赋值时进行数据拷贝，如<code>active(bool)</code> 和 <code>sign_in_count(u64)</code> 字段。</li><li>没有实现 <code>Copy</code> 特征的类型所有权发生转移，如 <code>username(String)</code>，导致了 <code>user1</code> 无法再被使用，但是 <code>user1</code> 内部的其它字段不受影响。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>    username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>    active: <span class="hljs-literal">true</span>,<br>    sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>    active: user1.active,<br>    username: user1.username,<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>    sign_in_count: user1.sign_in_count,<br>&#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, user1.active);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, user1.email);<br><span class="hljs-comment">// 下面这行会报错</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1);<br></code></pre></td></tr></table></figure><h2 id="使用-derive-Debug-来打印结构体的信息"><a href="#使用-derive-Debug-来打印结构体的信息" class="headerlink" title="使用 #[derive(Debug)] 来打印结构体的信息"></a>使用 <code>#[derive(Debug)]</code> 来打印结构体的信息</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;&#125;&quot;</span>, rect1); <span class="hljs-comment">// 报错</span><br>    <span class="hljs-comment">// error[E0277]: `Rectangle` doesn&#x27;t implement `std::fmt::Display`</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1); <span class="hljs-comment">// 报错</span><br>    <span class="hljs-comment">// error[E0277]: `Rectangle` doesn&#x27;t implement `Debug`</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Rust 默认没有实现 <code>Display</code> 特征，<code>&#123;&#125;</code> 不可用</p></li><li><p>Rust 默认没有实现 <code>Debug</code> 特征，<code>&#123;:?&#125;</code>不可用 ，为了实现，有两种方式可以选择：</p><ul><li>手动实现</li><li>使用 <code>derive</code> 派生实现</li></ul></li></ul><p>后者简单得多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);<br>    <span class="hljs-comment">// 输出结果：rect1 is Rectangle &#123; width: 30, height: 50 &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当结构体较大时，我们可能希望能够有更好的输出表现，此时可以使用 <strong><code>&#123;:#?&#125;</code></strong> 来替代 <code>&#123;:?&#125;</code>，输出如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">rect1 is Rectangle &#123;<br>    width: 30,<br>    height: 50,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 11 元组(tuple)</title>
    <link href="/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2011%20%E5%85%83%E7%BB%84(tuple)/"/>
    <url>/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2011%20%E5%85%83%E7%BB%84(tuple)/</url>
    
    <content type="html"><![CDATA[<p>元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。</p><h2 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h2><p>可以通过以下语法创建一个元组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 变量 tup 被绑定了一个元组值 (500, 6.4, 1)，该元组的类型是 (i32, f64, u8) </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用模式匹配解构元组"><a href="#用模式匹配解构元组" class="headerlink" title="用模式匹配解构元组"></a>用模式匹配解构元组</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> (x, y, z) = tup;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>    <span class="hljs-comment">// 输出结果：The value of y is: 6.4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码首先创建一个元组，然后将其绑定到 <code>tup</code> 上，接着使用 <code>let (x, y, z) = tup;</code> 来完成一次模式匹配，因为元组是 <code>(n1, n2, n3)</code> 形式的，因此我们用一模一样的 <code>(x, y, z)</code> 形式来进行匹配，元组中对应的值会绑定到变量 <code>x</code>， <code>y</code>， <code>z</code>上。这就是解构：用同样的形式把一个复杂对象中的值匹配出来。</p><h2 id="用-来访问元组"><a href="#用-来访问元组" class="headerlink" title="用 . 来访问元组"></a>用 <code>.</code> 来访问元组</h2><p>模式匹配可以让我们一次性把元组中的值全部或者部分获取出来，如果只想要访问某个特定元素，那模式匹配就略显繁琐，对此，Rust 提供了 <code>.</code> 的访问方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">five_hundred</span> = x.<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">six_point_four</span> = x.<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span> = x.<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和其它语言的数组、字符串一样，<strong>元组的索引从 0 开始</strong>。</p><h2 id="元组的使用示例"><a href="#元组的使用示例" class="headerlink" title="元组的使用示例"></a>元组的使用示例</h2><p>元组在函数返回值场景很常用，例如下面的代码，可以使用元组返回多个值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> (s2, len) = <span class="hljs-title function_ invoke__">calculate_length</span>(s1);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>, <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = s.<span class="hljs-title function_ invoke__">len</span>(); <span class="hljs-comment">// len() 返回字符串的长度</span><br><br>    (s, length)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>calculate_length</code> 函数接收 <code>s1</code> 字符串的所有权，然后计算字符串的长度，接着把字符串所有权和字符串长度再返回给 <code>s2</code> 和 <code>len</code> 变量。</p><p>在其他语言中，可以用结构体来声明一个三维空间中的点，例如 <code>Point(10, 20, 30)</code>，虽然使用 Rust 元组也可以做到：<code>(10, 20, 30)</code>，但是这样写有个非常重大的缺陷：</p><p><strong>不具备任何清晰的含义</strong>，在下一章节中，会提到一种与元组类似的结构体，<code>元组结构体</code>，可以解决这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 10 数组(array)</title>
    <link href="/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2010%20%E6%95%B0%E7%BB%84(array)/"/>
    <url>/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2010%20%E6%95%B0%E7%BB%84(array)/</url>
    
    <content type="html"><![CDATA[<p>在 Rust 中，最常用的数组有两种：</p><ul><li>第一种是速度很快但是长度固定的 <code>array</code></li><li>第二种是可动态增长的但是有性能损耗的 <code>Vector</code></li></ul><p>对于本章节，我们的重点还是放在数组 <code>array</code> 上。数组的具体定义很简单：将多个类型相同的元素依次组合在一起，就是一个数组。</p><p>数组的三要素：</p><ul><li>长度固定</li><li>元素必须有相同的类型</li><li>依次线性排列</li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>在 Rust 中，数组是这样定义的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 1. 简单字面量定义, 编译器自动推导出数组的类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <br><span class="hljs-comment">// 2. 显式声明：声明类型和长度</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// 3. 某个值重复出现 N 次的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = [<span class="hljs-number">1</span>; <span class="hljs-number">3</span>];<br><span class="hljs-comment">// let c = [1, 1, 1]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组类型是通过方括号语法声明<code>[T; N]</code>，<code>T</code> 是元素类型，分号后面的 <code>N</code> 是数组长度，数组类型也从侧面说明了<strong>数组的元素类型要统一，长度要固定</strong>。</p><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>因为数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = a[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 获取a数组第一个元素, first = 9</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = a[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 获取第二个元素, second = 8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与许多语言类似，<strong>数组的索引下标是从 0 开始</strong>的。此处，<code>first</code> 获取到的值是 <code>9</code>，<code>second</code> 是 <code>8</code>。</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第一个元素：&#123;&#125;&quot;</span>, arr[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;不存在的元素：&#123;&#125;&quot;</span>, arr[<span class="hljs-number">5</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>cargo run</code> 来运行代码，因为数组只有 5 个元素，如果我们试图输入 <code>5</code> 去访问第 6 个元素，则会访问到不存在的数组元素，最终程序会崩溃退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">error: this operation will panic at runtime<br> --&gt; src/main.rs:4:27<br>  |<br>4 |     println!(<span class="hljs-string">&quot;不存在的元素：&#123;&#125;&quot;</span>, arr[5]);<br>  |                                  ^^^^^^ index out of bounds: the length is 5 but the index is 5<br>  |<br>  = note: `#[deny(unconditional_panic)]` on by default<br><br>error: could not compile `compound_types` (bin <span class="hljs-string">&quot;compound_types&quot;</span>) due to 1 previous error<br></code></pre></td></tr></table></figure><p>这就是数组访问越界，访问了数组中不存在的元素，导致 Rust 运行时错误。程序因此退出并显示错误消息，未执行最后的 <code>println!</code> 语句。</p><h2 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h2><p>切片允许你引用集合中的部分连续片段，而不是整个集合，对于数组也是，数组切片允许我们引用数组的一部分：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span>: &amp;[<span class="hljs-type">i32</span>] = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br><br><span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>上面的数组切片 <code>slice</code> 的类型是<code>&amp;[i32]</code>，与之对比，数组的类型是<code>[i32;5]</code>，简单总结下切片的特点：</p><ul><li>切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置</li><li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li><li>切片类型 [T] 拥有不固定的大小，而切片引用类型 &amp;[T] 则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此 &amp;[T] 更有用，<code>&amp;str</code> 字符串切片也同理</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 编译器自动推导出one的类型</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span>             = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-comment">// 显式类型标注</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">two</span>: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>]    = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">blank1</span>          = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">blank2</span>: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];<br><br>  <span class="hljs-comment">// arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">arrays</span>: [[<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>]; <span class="hljs-number">4</span>]  = [one, two, blank1, blank2];<br><br>  <span class="hljs-comment">// 借用arrays的元素用作循环中</span><br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> &amp;arrays &#123;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;:?&#125;: &quot;</span>, a);<br>    <span class="hljs-comment">// 将a变成一个迭代器，用于循环</span><br>    <span class="hljs-comment">// 你也可以直接用for n in a &#123;&#125;来进行循环</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">n</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>      <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\t&#123;&#125; + 10 = &#123;&#125;&quot;</span>, n, n+<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 0..a.len,是一个 Rust 的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..a.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>      sum += a[i];<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\t(&#123;:?&#125; = &#123;&#125;)&quot;</span>, a, sum);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>做个总结，数组虽然很简单，但是其实还是存在几个要注意的点：</p><ul><li><strong>数组类型容易跟数组切片混淆</strong>，[T;n] 描述了一个数组的类型，而 [T] 描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译期得知，因此不能用 [T;n] 的形式去描述</li><li><code>[u8; 3]</code>和<code>[u8; 4]</code>是不同的类型，数组的长度也是类型的一部分</li><li>**在实际开发中，使用最多的是数组切片[T]**，我们往往通过引用的方式去使用<code>&amp;[T]</code>，因为后者有固定的类型大小</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 8 切片(slice)</title>
    <link href="/2024/11/07/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%208%20%E5%88%87%E7%89%87(slice)/"/>
    <url>/2024/11/07/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%208%20%E5%88%87%E7%89%87(slice)/</url>
    
    <content type="html"><![CDATA[<p>切片并不是 Rust 独有的概念，在 Go 语言中就非常流行，它允许你引用集合中部分连续的元素序列，而不是引用整个集合。</p><p>Rust常见的数据类型中，有三种类型已支持Slice操作: <strong>String类型</strong>、<strong>Array类型</strong>和<strong>Vec类型</strong></p><p>对于字符串而言，切片就是对 <code>String</code> 类型中某一部分的引用，它看起来像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = &amp;s[<span class="hljs-number">6</span>..<span class="hljs-number">11</span>];<br></code></pre></td></tr></table></figure><p><code>hello</code> 没有引用整个 <code>String s</code>，而是引用了 <code>s</code> 的一部分内容，通过 <code>[0..5]</code> 的方式来指定。</p><h2 id="切片语法"><a href="#切片语法" class="headerlink" title="切片语法"></a>切片语法</h2><p>创建切片使用方括号包括的一个序列：<strong>[开始索引..终止索引]</strong></p><blockquote><p>其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置。</p></blockquote><p>对于 <code>let world = &amp;s[6..11];</code> 来说，<code>world</code> 是一个切片，该切片的指针指向 <code>s</code> 的第 7 个字节(索引从 0 开始, 6 是第 7 个字节)，且该切片的长度是 <code>5</code> 个字节。</p><p><img src="/img/rust_slice.jpg"></p><p>在使用 Rust 的 <code>..</code> <a href="https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range">range 序列</a>语法时，如果你想从索引 0 开始，可以使用如下的方式，这两个是等效的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>同样的，如果你的切片想要包含 <code>String</code> 的最后一个字节，则可以这样使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">4</span>..len];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">4</span>..];<br></code></pre></td></tr></table></figure><p>你也可以截取完整的 <code>String</code> 切片：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..len];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..];<br></code></pre></td></tr></table></figure><h2 id="索引边界"><a href="#索引边界" class="headerlink" title="索引边界"></a>索引边界</h2><p>在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节，下面的代码就会崩溃：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;中国人&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,a);<br></code></pre></td></tr></table></figure><p>因为我们只取 <code>s</code> 字符串的前两个字节，但是本例中每个汉字占用三个字节，因此没有落在边界处，也就是连 <code>中</code> 字都取不完整，此时程序会直接崩溃退出，如果改成 <code>&amp;s[0..3]</code>，则可以正常通过编译。 因此，当你需要对字符串做切片索引操作时，需要格外小心这一点，关于该如何操作 UTF-8 字符串，参见<a href="https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2">这里</a>。</p><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><h3 id="字符串字面量是切片"><a href="#字符串字面量是切片" class="headerlink" title="字符串字面量是切片"></a>字符串字面量是切片</h3><p>之前提到过字符串字面量，但是没有提到它的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>实际上，<code>s</code> 的类型是 <code>&amp;str</code>，因此你也可以这样声明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>该切片指向了程序可执行文件中的某个点，这也是为什么字符串字面量是不可变的，因为 <code>&amp;str</code> 是一个不可变引用。</p><p>字符串切片的类型标识是 <code>&amp;str</code>，因此我们可以这样声明一个函数，输入 <code>String</code> 类型，返回它的切片：<code>fn first_word(s: &amp;String) -&gt; &amp;str</code> 。</p><p>有了切片就可以写出这样的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">word</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;s);<br><br>    s.<span class="hljs-title function_ invoke__">clear</span>(); <span class="hljs-comment">// error!</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the first word is: &#123;&#125;&quot;</span>, word);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    &amp;s[..<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器报错如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable<br>  --&gt; src/main.rs:18:5<br>   |<br>16 |     <span class="hljs-built_in">let</span> word = first_word(&amp;s);<br>   |                           -- immutable borrow occurs here<br>17 |<br>18 |     s.clear(); // error!<br>   |     ^^^^^^^^^ mutable borrow occurs here<br>19 |<br>20 |     println!(<span class="hljs-string">&quot;the first word is: &#123;&#125;&quot;</span>, word);<br>   |                                       ---- immutable borrow later used here<br></code></pre></td></tr></table></figure><p>回忆一下借用的规则：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 <code>clear</code> 需要清空改变 <code>String</code>，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 <code>pub fn clear(&amp;mut self)</code> ，参数是对自身的可变借用 ）；而之后的 <code>println!</code> 又使用了不可变借用，也就是在 <code>s.clear()</code> 处可变借用与不可变借用试图同时生效，因此编译无法通过。</p><p>从上述代码可以看出，Rust 不仅让我们的 <code>API</code> 更加容易使用，而且也在编译期就消除了大量错误！</p><h2 id="其他切片"><a href="#其他切片" class="headerlink" title="其他切片"></a>其他切片</h2><p>因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br><br><span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>该数组切片的类型是 <code>&amp;[i32]</code>，数组切片和字符串切片的工作方式是一样的，例如持有一个引用指向原始数组的某个元素和长度。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><code>len()</code> 获取 slice 元素个数</li><li><code>is_empty()</code> 判断slice是否为空</li><li><code>contains()</code> 判断是否包含某个元素</li><li><code>repeat()</code> 重复slice指定次数</li><li><code>reverse()</code> 反转slice</li><li><code>join()</code> 将各元素压平(flatten)并通过指定的分隔符连接起来</li><li><code>swap()</code> 交换两个索引处的元素，如 <code>s.swap(1.3)</code></li><li><code>windows()</code> 以指定大小的窗口进行滚动法代</li><li><code>starts_with()</code> 判断 slice 是否以某个 slice 开头</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 7 引用与借用</title>
    <link href="/2024/11/05/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%207%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/"/>
    <url>/2024/11/05/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%207%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Rust 通过 <code>借用(Borrowing)</code> 这个概念来达成上述的目的，**获取变量的引用，称之为借用(borrowing)**。</p><h2 id="引用与解引用"><a href="#引用与解引用" class="headerlink" title="引用与解引用"></a>引用与解引用</h2><p>常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个 <code>i32</code> 值的引用 <code>y</code>，然后使用解引用运算符来解出 <code>y</code> 所使用的值:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;x;<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br></code></pre></td></tr></table></figure><p>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。<code>y</code> 是 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。然而，如果希望对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来解出引用所指向的值（也就是<strong>解引用</strong>）。一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</p><h2 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h2><p>下面的代码，我们用 <code>s1</code> 的引用作为参数传递给 <code>calculate_length</code> 函数，而不是把 <code>s1</code> 的所有权转移给该函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s1);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>能注意到两点：</p><ol><li>无需像上章一样：先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁</li><li><code>calculate_length</code> 的参数 <code>s</code> 类型从 <code>String</code> 变为 <code>&amp;String</code></li></ol><p>这里，<code>&amp;</code> 符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：</p><p>![[rust_borrowing.jpg]]<br>通过 <code>&amp;s1</code> 语法，我们创建了一个<strong>指向 <code>s1</code> 的引用</strong>，但是并不拥有它。因为并不拥有这个值，当引用离开作用域后，其指向的值也不会被丢弃。</p><p>同理，函数 <code>calculate_length</code> 使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123; <span class="hljs-comment">// s 是对 String 的引用</span><br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125; <span class="hljs-comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span><br>  <span class="hljs-comment">// 所以什么也不会发生</span><br></code></pre></td></tr></table></figure><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><p>修改借用的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">change</span>(&amp;<span class="hljs-keyword">mut</span> s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change</span>(some_string: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    some_string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，声明 <code>s</code> 是可变类型，其次创建一个可变的引用 <code>&amp;mut s</code> 和接受可变引用参数 <code>some_string: &amp;mut String</code> 的函数。</p><h3 id="可变引用同时只能存在一个"><a href="#可变引用同时只能存在一个" class="headerlink" title="可变引用同时只能存在一个"></a>可变引用同时只能存在一个</h3><p>不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制： <strong>同一作用域，特定数据只能有一个可变引用</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);<br></code></pre></td></tr></table></figure><p>以上代码会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0499]: cannot borrow `s` as mutable more than once at a time 同一时间无法对 `s` 进行两次可变借用<br> --&gt; src/main.rs:5:14<br>  |<br>4 |     <span class="hljs-built_in">let</span> r1 = &amp;mut s;<br>  |              ------ first mutable borrow occurs here 首个可变引用在这里借用<br>5 |     <span class="hljs-built_in">let</span> r2 = &amp;mut s;<br>  |              ^^^^^^ second mutable borrow occurs here 第二个可变引用在这里借用<br>6 |<br>7 |     println!(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);<br>  |                        -- first borrow later used here 第一个借用在这里使用<br></code></pre></td></tr></table></figure><p>这段代码出错的原因在于，第一个可变借用 <code>r1</code> 必须要持续到最后一次使用的位置 <code>println!</code>，在 <code>r1</code> 创建和最后一次使用之间，我们又尝试创建第二个可变借用 <code>r2</code>。</p><p>这是 Rust 编译器的 <code>borrow checker</code> 特性之一</p><p>这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：</p><ul><li>两个或更多的指针同时访问同一数据</li><li>至少有一个指针被用来写入数据</li><li>没有同步数据访问的机制</li></ul><p>数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。而 Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</p><p>很多时候，大括号可以帮我们解决一些编译不通过的问题，通过手动限制变量的作用域：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><br>&#125; <span class="hljs-comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br></code></pre></td></tr></table></figure><h3 id="可变引用与不可变引用不能同时存在"><a href="#可变引用与不可变引用不能同时存在" class="headerlink" title="可变引用与不可变引用不能同时存在"></a>可变引用与不可变引用不能同时存在</h3><p>下面的代码会导致一个错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;s; <span class="hljs-comment">// 没问题</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;s; <span class="hljs-comment">// 没问题</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = &amp;<span class="hljs-keyword">mut</span> s; <span class="hljs-comment">// 大问题</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);<br></code></pre></td></tr></table></figure><p>错误如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable<br>        // 无法借用可变 `s` 因为它已经被借用了不可变<br> --&gt; src/main.rs:6:14<br>  |<br>4 |     <span class="hljs-built_in">let</span> r1 = &amp;s; // 没问题<br>  |              -- immutable borrow occurs here 不可变借用发生在这里<br>5 |     <span class="hljs-built_in">let</span> r2 = &amp;s; // 没问题<br>6 |     <span class="hljs-built_in">let</span> r3 = &amp;mut s; // 大问题<br>  |              ^^^^^^ mutable borrow occurs here 可变借用发生在这里<br>7 |<br>8 |     println!(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);<br>  |                                -- immutable borrow later used here 不可变借用在这里使用<br></code></pre></td></tr></table></figure><p>其实这个也很好理解，正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。</p><blockquote><p>注意，引用的作用域 <code>s</code> 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 <code>&#125;</code></p></blockquote><p>Rust 的编译器一直在优化，早期的时候，引用的作用域跟变量作用域是一致的，这对日常使用带来了很大的困扰，你必须非常小心的去安排可变、不可变变量的借用，免得无法通过编译，例如以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;s;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);<br>    <span class="hljs-comment">// 新编译器中，r1,r2作用域在这里结束</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r3);<br>&#125; <span class="hljs-comment">// 老编译器中，r1、r2、r3作用域在这里结束</span><br>  <span class="hljs-comment">// 新编译器中，r3作用域在这里结束</span><br></code></pre></td></tr></table></figure><p>在老版本的编译器中（Rust 1.31 前），将会报错，因为 <code>r1</code> 和 <code>r2</code> 的作用域在花括号 <code>&#125;</code> 处结束，那么 <code>r3</code> 的借用就会触发 <strong>无法同时借用可变和不可变</strong> 的规则。</p><p>但是在新的编译器中，该代码将顺利通过，因为 <strong>引用作用域的结束位置从花括号变成最后一次使用的位置</strong>，因此 <code>r1</code> 借用和 <code>r2</code> 借用在 <code>println!</code> 后，就结束了，此时 <code>r3</code> 可以顺利借用到可变引用。</p><h2 id="悬垂引用-Dangling-References"><a href="#悬垂引用-Dangling-References" class="headerlink" title="悬垂引用(Dangling References)"></a>悬垂引用(Dangling References)</h2><p>悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。</p><p>让我们尝试创建一个悬垂引用，Rust 会抛出一个编译时错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">reference_to_nothing</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &amp;s<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0106]: missing lifetime specifier<br> --&gt; src/main.rs:5:16<br>  |<br>5 | fn dangle() -&gt; &amp;String &#123;<br>  |                ^ expected named lifetime parameter<br>  |<br>  = <span class="hljs-built_in">help</span>: this <span class="hljs-keyword">function</span><span class="hljs-string">&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="hljs-string">help: consider using the `&#x27;</span>static` lifetime<br>  |<br>5 | fn dangle() -&gt; &amp;<span class="hljs-string">&#x27;static String &#123;</span><br><span class="hljs-string">  |                ~~~~~~~~</span><br></code></pre></td></tr></table></figure><p>仔细看看 <code>dangle</code> 代码的每一步到底发生了什么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123; <span class="hljs-comment">// dangle 返回一个字符串的引用</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// s 是一个新字符串</span><br><br>    &amp;s <span class="hljs-comment">// 返回字符串 s 的引用</span><br>&#125; <span class="hljs-comment">// 这里 s 离开作用域并被丢弃。其内存被释放。</span><br>  <span class="hljs-comment">// 危险！</span><br></code></pre></td></tr></table></figure><p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放，但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！</p><p>其中一个很好的解决方法是直接返回 <code>String</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">no_dangle</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    s<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就没有任何错误了，最终 <code>String</code> 的 <strong>所有权被转移给外面的调用者</strong>。</p><h2 id="借用规则总结"><a href="#借用规则总结" class="headerlink" title="借用规则总结"></a>借用规则总结</h2><p>总的来说，借用规则如下：</p><ul><li>同一时刻，你只能拥有要么一个可变引用，要么任意多个不可变引用</li><li>引用必须总是有效的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 6 所有权</title>
    <link href="/2024/11/04/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%206%20%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <url>/2024/11/04/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%206%20%E6%89%80%E6%9C%89%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>零开销内存回收 的一种高效实现方式</p></blockquote><p>Rust是一种系统编程语言，其设计目的是确保内存安全并防止数据竞争，而不依赖垃圾回收器。这种内存安全性主要通过所有权系统来实现。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><h3 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h3><table><thead><tr><th>特性</th><th>静态语言</th><th>动态语言</th></tr></thead><tbody><tr><td><strong>类型检查时间</strong></td><td>编译时</td><td>运行时</td></tr><tr><td><strong>类型安全</strong></td><td>更安全，减少运行时类型错误</td><td>较灵活，但类型错误可能在运行时出现</td></tr><tr><td><strong>性能</strong></td><td>通常更高效，编译器优化</td><td>通常较低，运行时类型检查</td></tr><tr><td><strong>灵活性</strong></td><td>较低，需明确声明类型</td><td>较高，允许在运行时改变类型</td></tr><tr><td><strong>代码简洁性</strong></td><td>需要显式类型声明，代码相对冗长</td><td>通常更简洁，适合快速开发</td></tr><tr><td><strong>开发工具支持</strong></td><td>更强大的静态分析和重构工具</td><td>开发工具支持有限，但在快速开发上占优势</td></tr></tbody></table><h3 id="回收方式对比"><a href="#回收方式对比" class="headerlink" title="回收方式对比"></a>回收方式对比</h3><table><thead><tr><th>特性</th><th>C&#x2F;C++</th><th>JavaScript</th><th>Rust</th></tr></thead><tbody><tr><td><strong>内存管理方式</strong></td><td>手动管理 (Manual Management)</td><td>垃圾回收 (Garbage Collection)</td><td>所有权系统 (Ownership System)</td></tr><tr><td><strong>特点</strong></td><td>- 程序员通过 <code>malloc</code> 和 <code>free</code> (C) 或 <code>new</code> 和 <code>delete</code> (C++) 手动分配和释放内存。<br>- 没有内置的垃圾回收机制。</td><td>- 浏览器和Node.js环境中均使用垃圾回收器（如V8引擎的垃圾回收器）。<br>- 采用标记-清除(Mark-and-Sweep)、标记-压缩(Mark-and-Compact)分代回收等算法。</td><td>- Rust使用所有权系统进行内存管理，编译器在编译时通过静态分析来确保内存安全。<br>- 每个值都有一个所有者，在任何时候只能有一个有效的所有者。<br>- 通过借用（引用）机制来共享数据，同时保证数据竞争和悬垂指针的安全。</td></tr><tr><td><strong>优点</strong></td><td>- 高效且灵活，适用于对性能要求极高的系统级编程。</td><td>- 自动内存管理，适合快速开发和运行在多平台上的应用。</td><td>- 在编译时保证内存安全，没有运行时开销。<br>- 避免了数据竞争和悬垂指针。</td></tr><tr><td><strong>缺点</strong></td><td>- 容易出现内存泄漏、悬垂指针和缓冲区溢出等问题，需要非常小心的内存管理。</td><td>- 垃圾回收机制在某些情况下可能导致性能问题，如UI线程停顿。</td><td>- 需要程序员理解和遵循所有权和借用规则，学习曲线较陡。</td></tr></tbody></table><h2 id="栈-Stack-与堆-Heap"><a href="#栈-Stack-与堆-Heap" class="headerlink" title="栈(Stack)与堆(Heap)"></a>栈(Stack)与堆(Heap)</h2><p>栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要，因为这会影响程序的行为和性能。</p><p>栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈按照顺序存储值并以相反顺序取出值，这也被称作<strong>后进先出</strong>。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p><p>增加数据叫做<strong>进栈</strong>，移出数据则叫做<strong>出栈</strong>。</p><p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p><p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的<strong>指针</strong>，该过程被称为<strong>在堆上分配内存</strong>，有时简称为 “分配”(allocating)。</p><p>接着，该指针会被推入<strong>栈</strong>中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的<strong>指针</strong>，来获取数据在堆上的实际内存位置，进而访问该数据。</p><p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭：进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。</p><h3 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h3><p>在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。</p><h3 id="所有权与堆栈"><a href="#所有权与堆栈" class="headerlink" title="所有权与堆栈"></a>所有权与堆栈</h3><p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p><p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p><p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是<strong>在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助</strong>。</p><h2 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h2><blockquote><ol><li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li><li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li><li>当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)</li></ol></blockquote><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>作用域是一个变量在程序中有效的范围，假如有这样一个变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><p>变量 <code>s</code> 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。<code>s</code> 变量从声明的点开始直到当前作用域的结束都是有效的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;                      <span class="hljs-comment">// s 在这里无效，它尚未声明</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;   <span class="hljs-comment">// 从此处起，s 是有效的</span><br><br>    <span class="hljs-comment">// 使用 s</span><br>&#125;                      <span class="hljs-comment">// 此作用域已结束，s不再有效</span><br></code></pre></td></tr></table></figure><p>简而言之，<code>s</code> 从创建开始就有效，然后有效期持续到它离开作用域为止，可以看出，就作用域来说，Rust 语言跟其他编程语言没有区别。</p><h2 id="变量绑定背后的数据交互"><a href="#变量绑定背后的数据交互" class="headerlink" title="变量绑定背后的数据交互"></a>变量绑定背后的数据交互</h2><h3 id="转移所有权"><a href="#转移所有权" class="headerlink" title="转移所有权"></a>转移所有权</h3><p>先来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br></code></pre></td></tr></table></figure><p>这段代码并没有发生所有权的转移，原因很简单： 代码首先将 <code>5</code> 绑定到变量 <code>x</code>，接着<strong>拷贝</strong> <code>x</code> 的值赋给 <code>y</code>，最终 <code>x</code> 和 <code>y</code> 都等于 <code>5</code>，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过<strong>自动拷贝</strong>的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。</p><p>整个过程中的赋值都是通过值拷贝的方式完成（发生在栈中），因此并不需要所有权转移。</p><p>然后再来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br></code></pre></td></tr></table></figure><p>实际上， <code>String</code> 类型是一个复杂类型，由存储在栈中的<strong>堆指针</strong>、<strong>字符串长度</strong>、<strong>字符串容量</strong>共同组成，其中<strong>堆指针</strong>是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，如果你有 Go 语言的经验，这里就很好理解：容量是堆内存分配空间的大小，长度是目前已经使用的大小。</p><p>总之 <code>String</code> 类型指向了一个堆上的空间，这里存储着它的真实数据，下面对上面代码中的 <code>let s2 = s1</code> 分成两种情况讨论：</p><ol><li><p>拷贝 <code>String</code> 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 <code>String</code> 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响</p></li><li><p>只拷贝 <code>String</code> 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 <code>8字节的指针</code>、<code>8字节的长度</code>、<code>8字节的容量</code>，总计 24 字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是：<strong>一个值只允许有一个所有者</strong>，而现在这个值（堆上的真实字符串数据）有了两个所有者：<code>s1</code> 和 <code>s2</code>。</p></li></ol><p>好吧，就假定一个值可以拥有两个所有者，会发生什么呢？</p><p>当变量离开作用域后，Rust 会自动调用 <code>drop</code> 函数并清理变量的堆内存。不过由于两个 <code>String</code> 变量指向了同一位置。这就有了一个问题：当 <code>s1</code> 和 <code>s2</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放（double free）</strong> 的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>因此，Rust 这样解决问题：<strong>当 <code>s1</code> 被赋予 <code>s2</code> 后，Rust 认为 <code>s1</code> 不再有效，因此也无需在 <code>s1</code> 离开作用域后 <code>drop</code> 任何东西，这就是把所有权从 <code>s1</code> 转移给了 <code>s2</code>，<code>s1</code> 在被赋予 <code>s2</code> 后就马上失效了</strong>。</p><p>再来看看，在所有权转移后再来使用旧的所有者，会发生什么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1: &#123;&#125;&quot;</span>, s1)<br></code></pre></td></tr></table></figure><p>由于 Rust 禁止你使用无效的引用，你会看到以下的错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0382]: borrow of moved value: `s1`<br>  --&gt; src/main.rs:13:24<br>   |<br>11 |     <span class="hljs-built_in">let</span> s1 = String::from(<span class="hljs-string">&quot;Hello&quot;</span>);<br>   |         -- move occurs because `s1` has <span class="hljs-built_in">type</span> `String`, <span class="hljs-built_in">which</span> does not implement the `Copy` trait<br>12 |     <span class="hljs-built_in">let</span> s2 = s1;<br>   |              -- value moved here<br>13 |     println!(<span class="hljs-string">&quot;s1: &#123;&#125;&quot;</span>, s1)<br>   |                        ^^ value borrowed here after move<br>   |<br>   = note: this error originates <span class="hljs-keyword">in</span> the macro `<span class="hljs-variable">$crate</span>::format_args_nl` <span class="hljs-built_in">which</span> comes from the expansion of the macro `println` (<span class="hljs-keyword">in</span> Nightly builds, run with -Z macro-backtrace <span class="hljs-keyword">for</span> more info)<br><span class="hljs-built_in">help</span>: consider cloning the value <span class="hljs-keyword">if</span> the performance cost is acceptable<br>   |<br>12 |     <span class="hljs-built_in">let</span> s2 = s1.clone();<br>   |                ++++++++<br><br>For more information about this error, try `rustc --explain E0382`.<br></code></pre></td></tr></table></figure><p>如果你在其他语言中听说过术语 <strong>浅拷贝(shallow copy)</strong> 和 **深拷贝(deep copy)**，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 <code>s1</code> 无效了，因此这个操作被称为 <strong>移动(move)<strong>，而不是浅拷贝。上面的例子可以解读为 <code>s1</code> 被</strong>移动</strong>到了 <code>s2</code> 中。那么具体发生了什么，用一张图简单说明：</p><p><img src="/img/rust_copy.jpg" alt="拷贝"></p><p>这样就解决了我们之前的问题，<code>s1</code> 不再指向任何数据，只有 <code>s2</code> 是有效的，当 <code>s2</code> 离开作用域，它就会释放内存。 相信此刻，你应该明白了，为什么 Rust 称呼 <code>let a = b</code> 为<strong>变量绑定</strong>了吧？</p><h3 id="克隆（深拷贝）"><a href="#克隆（深拷贝）" class="headerlink" title="克隆（深拷贝）"></a>克隆（深拷贝）</h3><p>首先，<strong>Rust 永远也不会自动创建数据的 “深拷贝”</strong>。因此，任何<strong>自动</strong>的复制都不是深拷贝，可以被认为对运行时性能影响较小。</p><p>如果我们<strong>确实</strong>需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);<br></code></pre></td></tr></table></figure><p>这段代码能够正常运行，说明 <code>s2</code> 确实完整的复制了 <code>s1</code> 的数据。</p><p>如果代码性能无关紧要，例如初始化程序时或者在某段时间只会执行寥寥数次时，你可以使用 <code>clone</code> 来简化编程。但是对于执行较为频繁的代码（热点路径），使用 <code>clone</code> 会极大的降低程序性能，需要小心使用！</p><h3 id="拷贝（浅拷贝）"><a href="#拷贝（浅拷贝）" class="headerlink" title="拷贝（浅拷贝）"></a>拷贝（浅拷贝）</h3><p>浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。</p><p>再回到之前看过的例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);<br></code></pre></td></tr></table></figure><p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过依然实现了类似深拷贝的效果 —— 没有报所有权的错误。</p><p>原因是像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效（<code>x</code>、<code>y</code> 都仍然有效）。换句话说，这里没有深浅拷贝的区别，因此这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它（可以理解成在栈上做了深拷贝）。</p><p>Rust 有一个叫做 <code>Copy</code> 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 <code>Copy</code> 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。</p><p>那么什么类型是可 <code>Copy</code> 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则： <strong>任何基本类型的组合可以 <code>Copy</code> ，不需要分配内存或某种形式资源的类型是可以 <code>Copy</code> 的</strong>。如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code></li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code></li><li>所有浮点数类型，比如 <code>f64</code></li><li>字符类型，<code>char</code></li><li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是</li><li>不可变引用 <code>&amp;T</code> ，例如转移所有权中的最后一个例子，<strong>但是注意：可变引用 <code>&amp;mut T</code> 是不可以 Copy的</strong></li></ul><h2 id="函数传值与返回"><a href="#函数传值与返回" class="headerlink" title="函数传值与返回"></a>函数传值与返回</h2><p>将值传递给函数，一样会发生 <code>移动</code> 或者 <code>复制</code>，就跟 <code>let</code> 语句一样，下面的代码展示了所有权、作用域的规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">takes_ownership</span>(s);             <span class="hljs-comment">// s 的值移动到函数里 ...</span><br>                                    <span class="hljs-comment">// ... 所以到这里不再有效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">makes_copy</span>(x);                  <span class="hljs-comment">// x 应该移动函数里，</span><br>                                    <span class="hljs-comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span><br><br>&#125; <span class="hljs-comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br>  <span class="hljs-comment">// 所以不会有特殊操作</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) &#123; <span class="hljs-comment">// some_string 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) &#123; <span class="hljs-comment">// some_integer 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// 这里，some_integer 移出作用域。不会有特殊操作</span><br></code></pre></td></tr></table></figure><p>同样的，函数返回值也有所有权，例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();         <span class="hljs-comment">// gives_ownership 将返回值</span><br>                                        <span class="hljs-comment">// 移给 s1</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 进入作用域</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="hljs-comment">// s2 被移动到</span><br>                                        <span class="hljs-comment">// takes_and_gives_back 中,</span><br>                                        <span class="hljs-comment">// 它也将返回值移给 s3</span><br>&#125; <span class="hljs-comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br>  <span class="hljs-comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;             <span class="hljs-comment">// gives_ownership 将返回值移动给</span><br>                                             <span class="hljs-comment">// 调用它的函数</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// some_string 进入作用域.</span><br><br>    some_string                              <span class="hljs-comment">// 返回 some_string 并移出给调用的函数</span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <span class="hljs-comment">// a_string 进入作用域</span><br><br>    a_string  <span class="hljs-comment">// 返回 a_string 并移出给调用的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： <strong>总是把一个值传来传去来使用它</strong>。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 5 流程控制</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%205%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%205%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><h3 id="使用-if-来做分支控制"><a href="#使用-if-来做分支控制" class="headerlink" title="使用 if 来做分支控制"></a>使用 if 来做分支控制</h3><p>不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 <code>if</code> 的条件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> condition == <span class="hljs-literal">true</span> &#123;<br>    <span class="hljs-comment">// A...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// B...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该代码读作：若 <code>condition</code> 的值为 <code>true</code>，则执行 <code>A</code> 代码，否则执行 <code>B</code> 代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">condition</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-number">5</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-number">6</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码有以下几点要注意：</p><ul><li><strong><code>if</code> 语句块是表达式</strong>，这里我们使用 <code>if</code> 表达式的返回值来给 <code>number</code> 进行赋值：<code>number</code> 的值是 <code>5</code></li><li>用 <code>if</code> 来赋值时，要保证每个分支返回的类型一样（事实上，这种说法不完全准确，见<a href="https://course.rs/appendix/expressions.html#if%E8%A1%A8%E8%BE%BE%E5%BC%8F">这里</a>），此处返回的 <code>5</code> 和 <code>6</code> 就是同一个类型，如果返回类型不一致就会报错</li></ul><h3 id="使用-else-if-来处理多重条件"><a href="#使用-else-if-来处理多重条件" class="headerlink" title="使用 else if 来处理多重条件"></a>使用 else if 来处理多重条件</h3><p>可以将 <code>else if</code> 与 <code>if</code>、<code>else</code> 组合在一起实现更复杂的条件分支判断：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-number">6</span>;<br><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 4&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 3&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 2&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出 <code>if</code> 语句块，最终本程序会匹配执行 <code>else if n % 3 == 0</code> 的分支，输出 <code>&quot;number is divisible by 3&quot;</code>。</p><blockquote><p>有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！</p></blockquote><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="for-循坏"><a href="#for-循坏" class="headerlink" title="for 循坏"></a>for 循坏</h3><p><code>for</code> 循环是 Rust 的大杀器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码循环输出一个从 1 到 5 的序列，简单粗暴，核心就在于 <code>for</code> 和 <code>in</code> 的联动，语义表达如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> 元素 <span class="hljs-keyword">in</span> 集合 &#123;<br>  <span class="hljs-comment">// 使用元素干一些你懂我不懂的事情</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，使用 <code>for</code> 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 <code>container</code> 的引用）。如果不使用引用的话，所有权会被转移（move）到 <code>for</code> 语句块中，后面就无法再使用这个集合了)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;container &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于实现了 <code>copy</code> 特征的数组（例如 [i32; 10]）而言， <code>for item in arr</code> 并不会把 <code>arr</code> 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 <code>arr</code> 。</p></blockquote><p>如果想在循环中，<strong>修改该元素</strong>，可以使用 <code>mut</code> 关键字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> collection &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结如下：</p><table><thead><tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr></thead><tbody><tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr><tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr><tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr></tbody></table><p>如果想在循环中<strong>获取元素的索引</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// `.iter()` 方法把 `a` 数组变成一个迭代器</span><br>    <span class="hljs-keyword">for</span> (i, v) <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>, i + <span class="hljs-number">1</span>, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>使用 <code>continue</code> 可以跳过当前当次的循环，开始下次的循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码对 1 到 3 的序列进行迭代，且跳过值为 2 时的循环，输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br>3<br></code></pre></td></tr></table></figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>使用 <code>break</code> 可以直接跳出当前整个循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码对 1 到 3 的序列进行迭代，在遇到值为 2 时的跳出整个循环，后面的循环不再执行，输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br></code></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>当条件为 <code>true</code> 时，执行循环；条件为 <code>false</code>，跳出循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">n</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> n &lt;= <span class="hljs-number">5</span>  &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>, n);<br>        n = n + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;我出来了！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该 <code>while</code> 循环，只有当 <code>n</code> 小于等于 <code>5</code> 时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从 <code>0</code> 开始，满足条件，进行循环，然后是 <code>1</code>，满足条件，进行循环，最终到 <code>6</code> 的时候，大于 5，不满足条件，跳出 <code>while</code> 循环，执行 <code>我出来了</code> 的打印，然后程序结束：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">0!<br>1!<br>2!<br>3!<br>4!<br>5!<br>我出来了！<br></code></pre></td></tr></table></figure><h3 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h3><p>对于循环而言，<code>loop</code> 循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景（虽然能用，但是在很多场景下， <code>for</code> 和 <code>while</code> 才是最优选择），因为 <code>loop</code> 就是一个简单的无限循环，你可以在内部实现逻辑通过 <code>break</code> 关键字来控制循环何时结束。</p><p>使用 <code>loop</code> 循环一定要打起精神，否则你会写出下面的跑满你一个 CPU 核心的疯子代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;again!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该循环会不停的在终端打印输出，直到你使用 `Ctrl-C` 结束程序：</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// ^Cagain!</span><br></code></pre></td></tr></table></figure><p>因此，当使用 <code>loop</code> 时，必不可少的伙伴是 <code>break</code> 关键字，它能让循环在满足某个条件时跳出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span> &#123;<br>        counter += <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码当 <code>counter</code> 递增到 <code>10</code> 时，就会通过 <code>break</code> 返回一个 <code>counter * 2</code> 的值，最后赋给 <code>result</code> 并打印出来。</p><p>这里有几点值得注意：</p><ul><li><strong>break 可以单独使用，也可以带一个返回值</strong>，有些类似 <code>return</code></li><li><strong>loop 是一个表达式</strong>，因此可以返回一个值</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 4 基础类型</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%204%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%204%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>Rust 使用一个相对传统的语法来创建整数（<code>1</code>，<code>2</code>，…）和浮点数（<code>1.0</code>，<code>1.1</code>，…）。整数、浮点数的运算和你在其它语言上见过的一致，都是通过常见的运算符来完成。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p><strong>整数</strong>是没有小数部分的数字。之前使用过的 <code>i32</code> 类型，表示有符号的 32 位整数（ <code>i</code> 是英文单词 <em>integer</em> 的首字母，与之相反的是 <code>u</code>，代表无符号 <code>unsigned</code> 类型）。下表显示了 Rust 中的内置的整数类型：</p><table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody><tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128 位</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>类型定义的形式统一为：<code>有无符号 + 类型大小(位数)</code>。<strong>无符号数</strong>表示数字只能取正数和 0，而<strong>有符号</strong>则表示数字可以取正数、负数还有 0。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以<a href="https://en.wikipedia.org/wiki/Two%27s_complement">补码</a>形式存储。</p><p>每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 <code>n</code> 是该定义形式的位长度。因此 <code>i8</code> 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 <code>u8</code> 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。</p><p>此外，<code>isize</code> 和 <code>usize</code> 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。</p><p>整形字面量可以用下表的形式书写：</p><table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody><tr><td>十进制</td><td><code>98_222</code></td></tr><tr><td>十六进制</td><td><code>0xff</code></td></tr><tr><td>八进制</td><td><code>0o77</code></td></tr><tr><td>二进制</td><td><code>0b1111_0000</code></td></tr><tr><td>字节 (仅限于 <code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><blockquote><ul><li>Rust 整型默认使用 <code>i32</code>，例如 <code>let i = 1</code>，那 <code>i</code> 就是 <code>i32</code> 类型，因此可以首选它，同时该类型也往往是性能最好的。</li><li><code>isize</code> 和 <code>usize</code> 的主要应用场景是用作集合的索引。</li></ul></blockquote><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p><p>下面是一个演示浮点数的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">2.0</span>; <span class="hljs-comment">// f64</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">f32</span> = <span class="hljs-number">3.0</span>; <span class="hljs-comment">// f32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>浮点数根据 <code>IEEE-754</code> 标准实现。<code>f32</code> 类型是单精度浮点型，<code>f64</code> 为双精度。</p><h4 id="浮点数陷阱"><a href="#浮点数陷阱" class="headerlink" title="浮点数陷阱"></a>浮点数陷阱</h4><p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p><ol><li><strong>浮点数往往是你想要数字的近似表达</strong></li><li><strong>浮点数在某些特性上是反直觉的</strong></li></ol><p>为了避免上面说的两个陷阱，需要遵守以下准则：</p><ul><li>避免在浮点数上测试相等性</li><li>当结果在数学上可能存在未定义时，需要格外的小心</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 断言0.1 + 0.2与0.3相等</span><br>  <span class="hljs-built_in">assert!</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能以为，这段代码没啥问题吧，实际上它会 _panic_（程序崩溃，抛出异常），因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。</p><p>那如果非要进行比较呢？可以考虑用这种方式 <code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code> ，具体小于多少，取决于你对精度的需求。</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>对于数学上未定义的结果，例如对负数取平方根 <code>-42.1.sqrt()</code> ，会产生一个特殊的结果：Rust 的浮点数类型使用 <code>NaN</code> (not a number) 来处理这些情况。</p><p>**所有跟 <code>NaN</code> 交互的操作，都会返回一个 <code>NaN</code>**，而且 <code>NaN</code> 不能用来比较，下面的代码会崩溃：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = (-<span class="hljs-number">42.0_f32</span>).<span class="hljs-title function_ invoke__">sqrt</span>();<br>  <span class="hljs-built_in">assert_eq!</span>(x, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>出于防御性编程的考虑，可以使用 <code>is_nan()</code> 等方法，可以用来判断一个数值是否是 <code>NaN</code> ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = (-<span class="hljs-number">42.0_f32</span>).<span class="hljs-title function_ invoke__">sqrt</span>();<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">is_nan</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;未定义的数学行为&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数值类型总结"><a href="#数值类型总结" class="headerlink" title="数值类型总结"></a>数值类型总结</h3><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p><ul><li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li><li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li><li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14</code> 的具体类型</li></ul><h2 id="字符类型-char"><a href="#字符类型-char" class="headerlink" title="字符类型(char)"></a>字符类型(char)</h2><p>Rust 的字符不仅仅是 <code>ASCII</code>，所有的 <code>Unicode</code> 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。</p><p>由于 <code>Unicode</code> 都是 4 个字节编码，因此字符类型也是占用 4 个字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-string">&#x27;中&#x27;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;字符&#x27;中&#x27;占用了&#123;&#125;字节的内存大小&quot;</span>,std::mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;x));<br>    <span class="hljs-comment">// 字符&#x27;中&#x27;占用了4字节的内存大小</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型(bool)"></a>布尔类型(bool)</h2><p>Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>，布尔值占用内存的大小为 <code>1</code> 个字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span>: <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 使用类型标注,显式指定f的类型</span><br><br>    <span class="hljs-keyword">if</span> f &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;这是段毫无意义的代码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用布尔类型的场景主要在于流程控制，例如上述代码的中的 <code>if</code> 就是其中之一。</p><h2 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h2><p>单元类型就是 <code>()</code>  ，唯一的值也是 <code>()</code> </p><p> <code>main</code> 函数就返回这个单元类型 <code>()</code>，你不能说 <code>main</code> 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：<code>发散函数( diverge function )</code>，顾名思义，无法收敛的函数。</p><p>例如常见的 <code>println!()</code> 的返回值也是单元类型 <code>()</code>。</p><p>再比如，你可以用 <code>()</code> 作为 <code>map</code> 的值，表示我们不关注具体的值，只关注 <code>key</code>。 这种用法和 Go 语言的 <em><strong>struct{}</strong></em> 类似，可以作为一个值用来占位，但是完全<strong>不占用</strong>任何内存。</p><h2 id="序列-Range"><a href="#序列-Range" class="headerlink" title="序列(Range)"></a>序列(Range)</h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5 ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,i);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最终程序输出:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br>2<br>3<br>4<br>5<br><br></code></pre></td></tr></table></figure><p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;a&#x27;</span>..=<span class="hljs-string">&#x27;z&#x27;</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,i);<br>    <span class="hljs-comment">// 输出 a～z 的字母</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型强制转换"><a href="#类型强制转换" class="headerlink" title="类型强制转换"></a>类型强制转换</h2><p>在Rust中，<code>as</code> 关键字用于在原始类型(如 <code>i64</code>、<code>f64</code>、<code>u64</code>、<code>char</code>等)之间进行类型转换。</p><blockquote><p>注意：<code>as</code>关键字并不适用于复合类型，比如<code>String</code>或其他用户定义的类型。对于复合类型的转换，通常需要使用其他方法或函数。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 3 函数</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%203%20%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%203%20%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="函数组成"><a href="#函数组成" class="headerlink" title="函数组成"></a>函数组成</h2><p>定义一个 <code>add</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(i: <span class="hljs-type">i32</span>, j: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>i + j<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字 <code>fn</code>，函数名 <code>add()</code>，参数 <code>i</code> 和 <code>j</code>，参数类型和返回值类型都是 <code>i32</code>，总之一切那么的普通，但是又那么的自信，直到你看到了下面这张图：</p><p><img src="/img/rust_fn.png" alt="函数组成"></p><h2 id="函数要点"><a href="#函数要点" class="headerlink" title="函数要点"></a>函数要点</h2><ul><li>函数名和变量名使用<a href="https://course.rs/practice/naming.html">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li><li>函数的位置可以<strong>随便放</strong>，Rust 不关心我们在哪里定义了函数，只要有定义即可</li><li><strong>每个函数参数</strong>都需要标注类型</li></ul><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>Rust 是静态类型语言，因此需要你为每一个函数参数都标识出它的具体类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(i: <span class="hljs-type">i32</span>, j) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>i + j<br>&#125;<br></code></pre></td></tr></table></figure><p>错误如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">error: expected one of `:`, `@`, or `|`, found `)`<br>  --&gt; src/main.rs:10:17<br>   |<br>10 | fn add(i: i32, j) -&gt; i32 &#123;<br>   |                 ^ expected one of `:`, `@`, or `|`<br>   |<br>   = note: anonymous parameters are removed <span class="hljs-keyword">in</span> the 2018 edition (see RFC 1685)<br><span class="hljs-built_in">help</span>: <span class="hljs-keyword">if</span> this is a parameter name, give it a <span class="hljs-built_in">type</span><br>   |<br>10 | fn add(i: i32, j: TypeName) -&gt; i32 &#123;<br>   |                 ++++++++++<br><span class="hljs-built_in">help</span>: <span class="hljs-keyword">if</span> this is a <span class="hljs-built_in">type</span>, explicitly ignore the parameter name<br>   |<br>10 | fn add(i: i32, _: j) -&gt; i32 &#123;<br>   |   <br></code></pre></td></tr></table></figure><h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 <code>return</code> 提前返回</p><p>可以简单记住以下两种形态：</p><ul><li><code>return</code></li><li>没有<code>return</code> + 没有分号</li></ul><p>以下这段代码同时使用 <strong><code>return</code></strong> 和<strong>表达式</strong>作为返回值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_or_minus</span>(x:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-keyword">return</span> x - <span class="hljs-number">5</span><br>    &#125;<br>    x + <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">plus_or_minus</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>2 个重点：</p><ol><li><code>let x = plus_or_minus(5)</code>，说明我们用一个函数的返回值来初始化 <code>x</code> 变量，因此侧面说明了在 Rust 中函数也是表达式，这种写法等同于 <code>let x = 5 + 5;</code></li><li><code>x + 5</code> 没有分号，因为它是一条表达式</li></ol><h2 id="Rust-中的特殊返回类型"><a href="#Rust-中的特殊返回类型" class="headerlink" title="Rust 中的特殊返回类型"></a>Rust 中的特殊返回类型</h2><h3 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值()"></a>无返回值()</h3><ul><li>函数没有返回值，那么返回一个 <code>()</code></li><li>通过 <code>;</code> 结尾的语句返回一个 <code>()</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 隐式返回一个 ()</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(i: <span class="hljs-type">i32</span>)&#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);  <br>&#125;<br><br><span class="hljs-comment">// 显式的返回了 ()</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(i:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span>() &#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="永不返回的发散函数"><a href="#永不返回的发散函数" class="headerlink" title="永不返回的发散函数 !"></a>永不返回的发散函数 <code>!</code></h3><p>当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dead_end</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;你已经到了穷途末路，崩溃吧！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">forever</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">forever_panic</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 2 变量和可变类型</title>
    <link href="/2024/10/31/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/10/31/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a>变量可变性</h2><ul><li>Rust 的变量在默认情况下是<strong>不可变的</strong></li><li>通过 <code>mut</code> 关键字让变量变为<strong>可变的</strong></li></ul><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 声明不可变变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>x = <span class="hljs-number">6</span>; <span class="hljs-comment">// 此处会报错，error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br><br><span class="hljs-comment">// 声明可变变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span> = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>y = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量-constant"><a href="#常量-constant" class="headerlink" title="常量(constant)"></a>常量(constant)</h2><ul><li>常量不允许使用<code>mut</code></li><li><strong>常量不仅仅默认不可变，而且自始至终不可变</strong></li><li>常量使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明</li><li>必须显示指定数据类型</li><li>Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词</li><li>必须使用常量表达式进行赋值，即必须是编译期能计算出的值</li><li>常量不支持重定义（遮蔽），这和变量是不同的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 常量声明</span><br><span class="hljs-keyword">const</span> MAX_COUNT: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is: &#123;&#125;&quot;</span>, MAX_COUNT);<br></code></pre></td></tr></table></figure><h3 id="不可变变量和常量的区别？"><a href="#不可变变量和常量的区别？" class="headerlink" title="不可变变量和常量的区别？"></a>不可变变量和常量的区别？</h3><ul><li>常量使用 <code>const</code> 进行声明，不可变变量使用 <code>let</code> 进行声明 。</li><li>常量在编译期就确定了值，不能在运行时改变。不可变变量直到运行期来能确定下来。</li><li>常量不可以修改，不可变变量可以通过 <code>shadowing</code> 来修改。</li><li>常量必须声明类型，不可变变量不需要声明类型</li><li>常量必须使用大写字母，不可变变量不需要</li></ul><h2 id="静态变量-Static"><a href="#静态变量-Static" class="headerlink" title="静态变量 (Static)"></a>静态变量 (Static)</h2><ul><li>静态变量使用 <code>static</code> 关键字进行声明并在编译时分配内存，并且在程序运行期间一直存在</li><li>静态变量可以在整个程序中共享，并且可以在多个线程之间共享。</li><li>静态变量的值在程序运行期间不会改变，因此它们通常用于存储程序的全局状态</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 声明一个静态变量</span><br><span class="hljs-keyword">static</span> NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 声明一个可变的静态变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER2: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of NUM is: &#123;&#125;&quot;</span>, NUM); <span class="hljs-comment">// The value of NUM is: 5</span><br><br><span class="hljs-title function_ invoke__">change_counter_static</span>();<br><span class="hljs-title function_ invoke__">change_counter_static_unsafe</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change_counter_static</span>() &#123;<br>COUNTER += <span class="hljs-number">1</span>; <span class="hljs-comment">// error[E0133]: use of mutable static is unsafe and requires unsafe function or block</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of COUNTER is: &#123;&#125;&quot;</span>, COUNTER);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change_counter_static_unsafe</span>() &#123;<br><span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-comment">// 需要用 unsafe 包裹才生效</span><br>COUNTER += <span class="hljs-number">1</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of COUNTER is: &#123;&#125;&quot;</span>, COUNTER);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与常量的相似点"><a href="#与常量的相似点" class="headerlink" title="与常量的相似点"></a>与常量的相似点</h3><ul><li>名称都要求使用大写，否则会报 Warning</li><li>都必须明确指定类型</li><li>都要求必须使用常量表达式进行赋值，即必须是编译期能计算出的值</li><li>都不支持重定义(遮蔽)，这和变量是不同的</li></ul><h3 id="与常量的区别"><a href="#与常量的区别" class="headerlink" title="与常量的区别"></a>与常量的区别</h3><ul><li>定义关键字: 静态变量使用 <code>static</code>，常量使用 <code>const</code></li><li>常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址。</li><li>常量不可变，而静态变量和普通变量一样，默认不可变但可以通过 <code>mut</code> 关键字定义为可变</li></ul><h2 id="变量遮蔽-variable-shadowing"><a href="#变量遮蔽-variable-shadowing" class="headerlink" title="变量遮蔽(variable shadowing)"></a>变量遮蔽(variable shadowing)</h2><p>变量绑定有一个作用域(scope)，它被限定只在一个代码块(block)中生存(live)。 代码块是一个被 {}包围的语句集合。另外也允许变量遮蔽(variable shadowing)</p><p>Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// 在main函数的作用域内对之前的x进行遮蔽</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x + <span class="hljs-number">1</span>;<br><br>    &#123;<br>        <span class="hljs-comment">// 在当前的花括号作用域内，对之前的x进行遮蔽</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x * <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>将输出以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">The value of x <span class="hljs-keyword">in</span> the inner scope is: 12<br>The value of x is: 6<br></code></pre></td></tr></table></figure><p>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</p><p><strong>变量遮蔽的用处</strong>在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 1 环境搭建</title>
    <link href="/2024/10/29/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%201%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/10/29/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%201%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-Rust-环境"><a href="#安装-Rust-环境" class="headerlink" title="安装 Rust 环境"></a>安装 <strong>Rust</strong> 环境</h2><h3 id="安装-rustup"><a href="#安装-rustup" class="headerlink" title="安装 rustup"></a>安装 <code>rustup</code></h3><p>打开终端并输入下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh<br></code></pre></td></tr></table></figure><p>如果安装成功，将出现下面这行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Rust is installed now. Great!<br></code></pre></td></tr></table></figure><p><strong>可能出现的问题</strong></p><ul><li>下载源速度很慢，解决方案：1. 选择镜像站 2. 使用代理&#x2F;VPN等</li></ul><h3 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h3><p>检查是否正确安装了 Rust，可打开终端并输入下面这行，此时能看到最新发布的稳定版本的版本号、提交哈希值和提交日期：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustc -V<br>rustc 1.81.0 (eeb90cda1 2024-09-04)<br><br>cargo -V<br>cargo 1.81.0 (2dbb1af80 2024-08-20)<br></code></pre></td></tr></table></figure><h3 id="rustup常用命令"><a href="#rustup常用命令" class="headerlink" title="rustup常用命令"></a><code>rustup</code>常用命令</h3><ul><li>更新：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup update<br></code></pre></td></tr></table></figure></li><li>卸载<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup self uninstall<br></code></pre></td></tr></table></figure></li><li>本地文档，让浏览器打开本地文档<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup doc<br></code></pre></td></tr></table></figure></li></ul><h2 id="VS-Code-插件推荐"><a href="#VS-Code-插件推荐" class="headerlink" title="VS Code 插件推荐"></a>VS Code 插件推荐</h2><ol><li><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a>，社区驱动的</li><li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Even Better TOML</a>，支持 <code>.toml</code> 文件的完整特性</li><li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Dependi</a>，依赖管理工具，代替<code>crates</code></li></ol><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><h3 id="编写-Rust-代码"><a href="#编写-Rust-代码" class="headerlink" title="编写 Rust 代码"></a>编写 Rust 代码</h3><p>新建一个源文件，Rust 源文件总是以 <code>.rs</code> 扩展名结尾。如果文件名包含多个单词，那么按照命名习惯，应当使用下划线来分隔单词。例如命名为 <code>hello_world.rs</code>，而不是 <code>helloworld.rs</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> hello_world<br><span class="hljs-built_in">cd</span> hello_world<br><span class="hljs-built_in">touch</span> main.rs<br></code></pre></td></tr></table></figure><p>打开刚创建的<code>main.rs</code> 文件，输入示例 1-1 代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在运行 Rust 程序之前，必须先使用 Rust 编译器编译它，即输入 <code>rustc</code> 命令并传入源文件名称，如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustc main.rs<br></code></pre></td></tr></table></figure><p>编译成功后，Rust会输出一个二进制的可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span><br>main main.rs<br></code></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>Rust 是一种 <strong>预编译静态类型(ahead-of-time compiled)语言</strong>，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">./main<br>Hello, World!<br></code></pre></td></tr></table></figure><h2 id="认识Cargo"><a href="#认识Cargo" class="headerlink" title="认识Cargo"></a>认识Cargo</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo new hello_cargo<br><span class="hljs-built_in">cd</span> hello_cargo<br></code></pre></td></tr></table></figure><p>初始化的项目结构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tree<br>.<br>├── .git<br>├── .gitignore<br>├── Cargo.toml<br>└── src<br>    └── main.rs<br><br></code></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>有两种方式可以运行项目：</p><ol><li><p><code>cargo run</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ cargo run<br>   Compiling hello_cargo v0.1.0 (/Users/vic9527/Documents/rust/hello_cargo)<br>    Finished `dev` profile [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.29s<br>     Running `target/debug/hello_cargo`<br>Hello, Cargo!<br></code></pre></td></tr></table></figure></li><li><p>手动编译和运行项目<br>编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ cargo build<br>    Finished `dev` profile [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.02s<br>    <br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ ./target/debug/hello_cargo<br>Hello, Cargo!<br></code></pre></td></tr></table></figure></li></ol><h3 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h3><p>当项目最终准备好发布时，可以使用 <code>cargo build --release</code> 来优化编译项目</p><ul><li><p><code>debug</code>模式，<strong>代码的编译速度会非常快</strong>，但是<strong>运行速度就慢了</strong>。原因是，在 <code>debug</code> 模式下，Rust 编译器不会做任何的优化，只为了尽快的编译完成，让你的开发流程更加顺畅。</p></li><li><p><code>release</code>模式，<strong>高性能模式</strong>，为用户构建最终程序</p><ul><li><code>cargo run --release</code></li><li><code>cargo build --release</code></li></ul></li></ul><h3 id="Cargo-toml-和-Cargo-lock"><a href="#Cargo-toml-和-Cargo-lock" class="headerlink" title="Cargo.toml 和 Cargo.lock"></a>Cargo.toml 和 Cargo.lock</h3><p><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 是 <code>cargo</code> 的核心文件，它的所有活动均基于此二者。</p><ul><li><p><code>Cargo.toml</code> 是 <code>cargo</code> 特有的<strong>项目数据描述文件</strong>。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 <code>Cargo.toml</code>。</p></li><li><p><code>Cargo.lock</code> 文件是 <code>cargo</code> 工具根据同一项目的 <code>toml</code> 文件生成的<strong>项目依赖详细清单</strong>，因此我们一般不用修改它，只需要对着 <code>Cargo.toml</code> 文件撸就行了。</p><blockquote><p>什么情况下该把 <code>Cargo.lock</code> 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 <code>Cargo.lock</code>，如果是一个依赖库项目，那么请把它添加到 <code>.gitignore</code> 中。</p></blockquote></li></ul><h3 id="package-配置段落"><a href="#package-配置段落" class="headerlink" title="package 配置段落"></a>package 配置段落</h3><p><code>package</code> 中记录了项目的描述信息，典型的如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;hello_cargo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>name</code> 字段定义了项目名称</li><li><code>version</code> 字段定义当前版本，新项目默认是 <code>0.1.0</code></li><li><code>edition</code> 字段定义了我们使用的 Rust 大版本</li></ul><h3 id="定义项目依赖"><a href="#定义项目依赖" class="headerlink" title="定义项目依赖"></a>定义项目依赖</h3><p>使用 <code>cargo</code> 工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。</p><p>在 <code>Cargo.toml</code> 中，主要通过各种依赖段落来描述该项目的各种依赖项：</p><ul><li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li><li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li><li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li></ul><p>这三种形式具体写法如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">rand</span> = <span class="hljs-string">&quot;0.3&quot;</span><br><span class="hljs-attr">hammer</span> = &#123; version = <span class="hljs-string">&quot;0.5.0&quot;</span>&#125;<br><span class="hljs-attr">color</span> = &#123; git = <span class="hljs-string">&quot;https://github.com/bjz/color-rs&quot;</span> &#125;<br><span class="hljs-attr">geometry</span> = &#123; path = <span class="hljs-string">&quot;crates/geometry&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="下载依赖太慢"><a href="#下载依赖太慢" class="headerlink" title="下载依赖太慢"></a>下载依赖太慢</h2><ol><li><p>科技上网，不赘述</p></li><li><p>修改下载镜像</p><p> 修改配置文件，文件位置<code>$HOME/.cargo/config.toml</code></p></li></ol><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment"># 选择的镜像源</span><br><span class="hljs-comment"># 喜欢哪个用哪个吧，没有注释掉的那个就是你选择的</span><br><span class="hljs-comment">#replace-with = &#x27;ustc&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;tuna&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;sjtu&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;rustcc&#x27;</span><br><span class="hljs-attr">replace-with</span> = <span class="hljs-string">&#x27;aliyun&#x27;</span><br><br><span class="hljs-comment"># 源码地址</span><br><span class="hljs-section">[source.crates-io]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 镜像地址</span><br><span class="hljs-comment"># 清华大学</span><br><span class="hljs-section">[source.tuna]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><br><span class="hljs-comment"># 中国科学技术大学</span><br><span class="hljs-section">[source.ustc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 上海交通大学</span><br><span class="hljs-section">[source.sjtu]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><br><span class="hljs-comment"># rustcc社区</span><br><span class="hljs-section">[source.rustcc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 阿里云</span><br><span class="hljs-section">[source.aliyun]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://code.aliyun.com/rustcc/crates.io-index&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
