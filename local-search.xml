<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 17 集合-KV 存储 HashMap</title>
    <link href="/2024/11/14/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2017%20%E9%9B%86%E5%90%88-KV%20%E5%AD%98%E5%82%A8%20HashMap/"/>
    <url>/2024/11/14/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2017%20%E9%9B%86%E5%90%88-KV%20%E5%AD%98%E5%82%A8%20HashMap/</url>
    
    <content type="html"><![CDATA[<p><code>HashMap</code> 中存储的是一一映射的 <code>KV</code> 键值对，并提供了平均复杂度为 <code>O(1)</code> 的查询方法。</p><h2 id="创建-HashMap"><a href="#创建-HashMap" class="headerlink" title="创建 HashMap"></a>创建 HashMap</h2><h3 id="使用-new-方法创建"><a href="#使用-new-方法创建" class="headerlink" title="使用 new 方法创建"></a>使用 new 方法创建</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 `HashMap` 需要手动通过 `use ...` 从标准库中引入到我们当前的作用域中来</span><br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-comment">// 创建一个HashMap，用于存储宝石种类和对应的数量</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">my_gems</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-comment">// 将宝石类型和对应的数量写入表中</span><br>my_gems.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;红宝石&quot;</span>, <span class="hljs-number">1</span>);<br>my_gems.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;蓝宝石&quot;</span>, <span class="hljs-number">2</span>);<br>my_gems.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;河边捡的误以为是宝石的破石头&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><blockquote><p>跟 <code>Vec</code> 一样，如果预先知道要存储的 <code>KV</code> 对个数，可以使用 <code>HashMap::with_capacity(capacity)</code> 创建指定大小的 <code>HashMap</code>，避免频繁的内存分配和拷贝，提升性能。</p></blockquote><h3 id="使用迭代器和-collect-方法创建"><a href="#使用迭代器和-collect-方法创建" class="headerlink" title="使用迭代器和 collect 方法创建"></a>使用迭代器和 collect 方法创建</h3><p>先将 <code>Vec</code> 转为迭代器，接着通过 <code>collect</code> 方法，将迭代器中的元素收集后，转成 <code>HashMap</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">use</span> std::collections::HashMap;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">teams_list</span> = <span class="hljs-built_in">vec!</span>[<br>        (<span class="hljs-string">&quot;中国队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">100</span>),<br>        (<span class="hljs-string">&quot;美国队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">10</span>),<br>        (<span class="hljs-string">&quot;日本队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">50</span>),<br>    ];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">teams_map</span>: HashMap&lt;_,_&gt; = teams_list.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,teams_map)<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，<code>into_iter</code> 方法将列表转为迭代器，接着通过 <code>collect</code> 进行收集，不过需要注意的是，<code>collect</code> 方法在内部实际上支持生成多种类型的目标集合，因此我们需要通过类型标注 <code>HashMap&lt;_,_&gt;</code> 来告诉编译器：请帮我们收集为 <code>HashMap</code> 集合类型</p><h2 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h2><p><code>HashMap</code> 的所有权规则与其它 Rust 类型没有区别：</p><ul><li>若类型实现 <code>Copy</code> 特征，该类型会被复制进 <code>HashMap</code>，因此无所谓所有权</li><li>若没实现 <code>Copy</code> 特征，所有权将被转移给 <code>HashMap</code> 中</li></ul><h2 id="查询-HashMap"><a href="#查询-HashMap" class="headerlink" title="查询 HashMap"></a>查询 HashMap</h2><h3 id="通过-get-方法可以获取元素"><a href="#通过-get-方法可以获取元素" class="headerlink" title="通过 get 方法可以获取元素"></a>通过 <code>get</code> 方法可以获取元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>), <span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">team_name</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">score</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">i32</span>&gt; = scores.<span class="hljs-title function_ invoke__">get</span>(&amp;team_name);<br></code></pre></td></tr></table></figure><p>上面有几点需要注意：</p><ul><li><code>get</code> 方法返回一个 <code>Option&lt;&amp;i32&gt;</code> 类型：当查询不到时，会返回一个 <code>None</code>，查询到时返回 <code>Some(&amp;i32)</code></li><li><code>&amp;i32</code> 是对 <code>HashMap</code> 中值的借用，如果不使用借用，可能会发生所有权的转移</li></ul><h3 id="通过循环的方式依次遍历-KV-对"><a href="#通过循环的方式依次遍历-KV-对" class="headerlink" title="通过循环的方式依次遍历 KV 对"></a>通过循环的方式依次遍历 <code>KV</code> 对</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>), <span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-comment">// Yellow: 50</span><br><span class="hljs-comment">// Blue: 10</span><br><br></code></pre></td></tr></table></figure><h2 id="更新-HashMap-中的值"><a href="#更新-HashMap-中的值" class="headerlink" title="更新 HashMap 中的值"></a>更新 HashMap 中的值</h2><p>更新值的时候，涉及多种情况，咱们在代码中一一进行说明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">use</span> std::collections::HashMap;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 覆盖已有的值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">old</span> = scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(old, <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">10</span>));<br><br>    <span class="hljs-comment">// 查询新插入的值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">new</span> = scores.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;Blue&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(new, <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-number">20</span>));<br><br>    <span class="hljs-comment">// 查询Yellow对应的值，若不存在则插入新值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-string">&quot;Yellow&quot;</span>).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(*v, <span class="hljs-number">5</span>); <span class="hljs-comment">// 不存在，插入5</span><br><br>    <span class="hljs-comment">// 查询Yellow对应的值，若不存在则插入新值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-string">&quot;Yellow&quot;</span>).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(*v, <span class="hljs-number">5</span>); <span class="hljs-comment">// 已经存在，因此50没有插入</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在已有值的基础上更新"><a href="#在已有值的基础上更新" class="headerlink" title="在已有值的基础上更新"></a>在已有值的基础上更新</h3><p>另一个常用场景如下：查询某个 <code>key</code> 对应的值，若不存在则插入新值，若存在则对已有的值进行更新，例如在文本中统计词语出现的次数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = <span class="hljs-string">&quot;hello world wonderful world&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-comment">// 根据空格来切分字符串(英文单词都是通过空格切分)</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">split_whitespace</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = map.<span class="hljs-title function_ invoke__">entry</span>(word).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br>    *count += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, map);<br><span class="hljs-comment">// 输出结果： &#123;&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，新建一个 <code>map</code> 用于保存词语出现的次数，插入一个词语时会进行判断：若之前没有插入过，则使用该词语作 <code>Key</code>，插入次数 0 作为 <code>Value</code>，若之前插入过则取出之前统计的该词语出现的次数，对其加一。</p><p>有两点值得注意：</p><ul><li><code>or_insert</code> 返回了 <code>&amp;mut v</code> 引用，因此可以通过该可变引用直接修改 <code>map</code> 中对应的值</li><li>使用 <code>count</code> 引用时，需要先进行解引用 <code>*count</code>，否则会出现类型不匹配</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 16 集合-动态数组(Vector)</title>
    <link href="/2024/11/14/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2016%20%E9%9B%86%E5%90%88-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84(Vector)/"/>
    <url>/2024/11/14/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2016%20%E9%9B%86%E5%90%88-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84(Vector)/</url>
    
    <content type="html"><![CDATA[<p>动态数组类型用 <code>Vec&lt;T&gt;</code> 表示，Vec 是一个动态数组，可以根据需要动态增长和缩小。适用于需要按顺序存储数据的场景。</p><h2 id="创建-Vector"><a href="#创建-Vector" class="headerlink" title="创建 Vector"></a>创建 Vector</h2><h3 id="Vec-new"><a href="#Vec-new" class="headerlink" title="Vec::new"></a>Vec::new</h3><p>使用 <code>Vec::new</code> 创建动态数组是最 rusty 的方式，它调用了 <code>Vec</code> 中的 <code>new</code> 关联函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这里，`v` 被显式地声明了类型 `Vec&lt;i32&gt;`，这是因为 Rust 编译器无法从 `Vec::new()` 中得到任何关于类型的暗示信息，因此也无法推导出 `v` 的具体类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-comment">// 此时，`v` 就无需手动声明类型，因为编译器通过 `v.push(1)`，推测出 `v` 中的元素类型是 `i32`，因此推导出 `v` 的类型是 `Vec&lt;i32&gt;`。</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v2</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v2.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p>如果预先知道要存储的元素个数，可以使用 <code>Vec::with_capacity(capacity)</code> 创建动态数组，这样可以避免因为插入大量新数据导致频繁的内存分配和拷贝，提升性能</p></blockquote><h3 id="vec"><a href="#vec" class="headerlink" title="vec!"></a>vec!</h3><p>还可以使用宏 <code>vec!</code> 来创建数组，与 <code>Vec::new</code> 有所不同，前者能在创建同时给予初始化值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 此处的 `v` 也无需标注类型，编译器只需检查它内部的元素即可自动推导出 `v` 的类型是 `Vec&lt;i32&gt;`</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="更新-Vector"><a href="#更新-Vector" class="headerlink" title="更新 Vector"></a>更新 Vector</h2><p>向数组尾部添加元素，可以使用 <code>push</code> 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>与其它类型一样，必须将 <code>v</code> 声明为 <code>mut</code> 后，才能进行修改。</p><h2 id="访问-Vector"><a href="#访问-Vector" class="headerlink" title="访问 Vector"></a>访问 Vector</h2><p>读取指定位置的元素有两种方式可选：</p><ul><li>通过下标索引访问。</li><li>使用 <code>get</code> 方法。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">third</span>: &amp;<span class="hljs-type">i32</span> = &amp;v[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第三个元素是 &#123;&#125;&quot;</span>, third);<br><br><span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(third) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第三个元素是 &#123;third&#125;&quot;</span>),<br>    <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;去你的第三个元素，根本没有！&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>和其它语言一样，集合类型的索引下标都是从 <code>0</code> 开始，<code>&amp;v[2]</code> 表示借用 <code>v</code> 中的第三个元素，最终会获得该元素的引用。而 <code>v.get(2)</code> 也是访问第三个元素，但是有所不同的是，它返回了 <code>Option&lt;&amp;T&gt;</code>，因此还需要额外的 <code>match</code> 来匹配解构出具体的值。</p><h3 id="下标索引与-get-的区别"><a href="#下标索引与-get-的区别" class="headerlink" title="下标索引与 .get 的区别"></a>下标索引与 .get 的区别</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">does_not_exist</span> = &amp;v[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">does_not_exist</span> = v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>运行以上代码，<code>&amp;v[100]</code> 的访问方式会导致程序无情报错退出，因为发生了数组越界访问。 但是 <code>v.get</code> 就不会，它在内部做了处理，有值的时候返回 <code>Some(T)</code>，无值的时候返回 <code>None</code>，因此 <code>v.get</code> 的使用方式非常安全。</p><h2 id="迭代遍历-Vector"><a href="#迭代遍历-Vector" class="headerlink" title="迭代遍历 Vector"></a>迭代遍历 Vector</h2><p>如果想要依次访问数组中的元素，可以使用迭代的方式去遍历数组，这种方式比用下标的方式去遍历数组更安全也更高效（每次下标访问都会触发数组边界检查）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;i&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在迭代过程中，修改 <code>Vector</code> 中的元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>    *i += <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;new v: &#123;:?&#125;&quot;</span>, v);<br><span class="hljs-comment">// new v: [11, 12, 13]</span><br></code></pre></td></tr></table></figure><h2 id="存储不同类型的元素"><a href="#存储不同类型的元素" class="headerlink" title="存储不同类型的元素"></a>存储不同类型的元素</h2><p><strong>数组的元素必须类型相同</strong>，但是也提到了解决方案：那就是通过使用<strong>枚举类型</strong>和<strong>特征对象</strong>来实现不同类型元素的存储。先来看看通过枚举如何实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddr</span> &#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>        IpAddr::<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>        IpAddr::<span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-string">&quot;::1&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())<br>    ];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">ip</span> <span class="hljs-keyword">in</span> v &#123;<br>        <span class="hljs-title function_ invoke__">show_addr</span>(ip)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">show_addr</span>(ip: IpAddr) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,ip);<br>&#125;<br></code></pre></td></tr></table></figure><p>数组 <code>v</code> 中存储了两种不同的 <code>ip</code> 地址，但是这两种都属于 <code>IpAddr</code> 枚举类型的成员，因此可以存储在数组中。</p><p>再来看看特征对象的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">IpAddr</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">V4</span>(<span class="hljs-type">String</span>);<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IpAddr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">V4</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ipv4: &#123;:?&#125;&quot;</span>,<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">V6</span>(<span class="hljs-type">String</span>);<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IpAddr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">V6</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ipv6: &#123;:?&#125;&quot;</span>,<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> IpAddr&gt;&gt; = <span class="hljs-built_in">vec!</span>[<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-string">&quot;::1&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>    ];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">ip</span> <span class="hljs-keyword">in</span> v &#123;<br>        ip.<span class="hljs-title function_ invoke__">display</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比枚举实现要稍微复杂一些，我们为 <code>V4</code> 和 <code>V6</code> 都实现了特征 <code>IpAddr</code>，然后将它俩的实例用 <code>Box::new</code> 包裹后，存在了数组 <code>v</code> 中，需要注意的是，这里必须手动地指定类型：<code>Vec&lt;Box&lt;dyn IpAddr&gt;&gt;</code>，表示数组 <code>v</code> 存储的是特征 <code>IpAddr</code> 的对象，这样就实现了在数组中存储不同的类型。</p><p>在实际使用场景中，<strong>特征对象数组要比枚举数组常见很多</strong>，主要原因在于<a href="https://course.rs/basic/trait/trait-object.html">特征对象</a>非常灵活，而编译器对枚举的限制较多，且无法动态增加类型。</p><h2 id="Vector-常用方法"><a href="#Vector-常用方法" class="headerlink" title="Vector 常用方法"></a>Vector 常用方法</h2><p>初始化 vec 的更多方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];   <span class="hljs-comment">// 默认值为 0，初始长度为 3</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v_from</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">from</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(v, v_from);<br>&#125;<br></code></pre></td></tr></table></figure><p>动态数组意味着我们增加元素时，如果<strong>容量不足就会导致 vector 扩容</strong>（目前的策略是重新申请一块 2 倍大小的内存，再将所有元素拷贝到新的内存位置，同时更新指针数据），显然，当频繁扩容或者当元素数量较多且需要扩容时，大量的内存拷贝会降低程序的性能。</p><p>可以考虑在初始化时就指定一个实际的预估容量，尽量减少可能的内存拷贝：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-title function_ invoke__">extend</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);    <span class="hljs-comment">// 附加数据到 v</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector 长度是: &#123;&#125;, 容量是: &#123;&#125;&quot;</span>, v.<span class="hljs-title function_ invoke__">len</span>(), v.<span class="hljs-title function_ invoke__">capacity</span>());<br><br>    v.<span class="hljs-title function_ invoke__">reserve</span>(<span class="hljs-number">100</span>);        <span class="hljs-comment">// 调整 v 的容量，至少要有 100 的容量</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector（reserve） 长度是: &#123;&#125;, 容量是: &#123;&#125;&quot;</span>, v.<span class="hljs-title function_ invoke__">len</span>(), v.<span class="hljs-title function_ invoke__">capacity</span>());<br><br>    v.<span class="hljs-title function_ invoke__">shrink_to_fit</span>();     <span class="hljs-comment">// 释放剩余的容量，一般情况下，不会主动去释放容量</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector（shrink_to_fit） 长度是: &#123;&#125;, 容量是: &#123;&#125;&quot;</span>, v.<span class="hljs-title function_ invoke__">len</span>(), v.<span class="hljs-title function_ invoke__">capacity</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>Vector 常见的一些方法示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> =  <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-built_in">assert!</span>(!v.<span class="hljs-title function_ invoke__">is_empty</span>());         <span class="hljs-comment">// 检查 v 是否为空</span><br><br>v.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);                 <span class="hljs-comment">// 在指定索引插入数据，索引值不能大于 v 的长度， v: [1, 2, 3] </span><br><span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">remove</span>(<span class="hljs-number">1</span>), <span class="hljs-number">2</span>);     <span class="hljs-comment">// 移除指定位置的元素并返回, v: [1, 3]</span><br><span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>));   <span class="hljs-comment">// 删除并返回 v 尾部的元素，v: [1]</span><br><span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>));   <span class="hljs-comment">// v: []</span><br><span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-literal">None</span>);      <span class="hljs-comment">// 记得 pop 方法返回的是 Option 枚举值</span><br>v.<span class="hljs-title function_ invoke__">clear</span>();                      <span class="hljs-comment">// 清空 v, v: []</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>].<span class="hljs-title function_ invoke__">to_vec</span>(); <span class="hljs-comment">// append 操作会导致 v1 清空数据，增加可变声明</span><br>v.<span class="hljs-title function_ invoke__">append</span>(&amp;<span class="hljs-keyword">mut</span> v1);              <span class="hljs-comment">// 将 v1 中的所有元素附加到 v 中, v1: []</span><br>v.<span class="hljs-title function_ invoke__">truncate</span>(<span class="hljs-number">1</span>);                  <span class="hljs-comment">// 截断到指定长度，多余的元素被删除, v: [11]</span><br>v.<span class="hljs-title function_ invoke__">retain</span>(|x| *x &gt; <span class="hljs-number">10</span>);          <span class="hljs-comment">// 保留满足条件的元素，即删除不满足条件的元素</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>];<br><span class="hljs-comment">// 删除指定范围的元素，同时获取被删除元素的迭代器, v: [11, 55], m: [22, 33, 44]</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">drain</span>(<span class="hljs-number">1</span>..=<span class="hljs-number">3</span>).<span class="hljs-title function_ invoke__">collect</span>();    <br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = m.<span class="hljs-title function_ invoke__">split_off</span>(<span class="hljs-number">1</span>);        <span class="hljs-comment">// 指定索引处切分成两个 vec, m: [22], v2: [33, 44]</span><br></code></pre></td></tr></table></figure><p>当然也可以像数组切片的方式获取 vec 的部分元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;v[<span class="hljs-number">1</span>..=<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 15 模式匹配</title>
    <link href="/2024/11/13/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2015%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2024/11/13/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2015%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>在 Rust 中，模式匹配最常用的就是 <code>match</code> 和 <code>if let</code>。</p><h2 id="match-匹配"><a href="#match-匹配" class="headerlink" title="match 匹配"></a>match 匹配</h2><p>有以下几点值得注意：</p><ul><li><code>match</code> 的匹配必须要穷举出所有可能</li><li> <code>_</code> 通配符来代表未列出的所有可能性</li><li><code>match</code> 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</li><li><strong>X | Y</strong>，类似逻辑运算符 <code>或</code>，代表该分支可以匹配 <code>X</code> 也可以匹配 <code>Y</code>，只要满足一个即可</li></ul><p>其实 <code>match</code> 跟其他语言中的 <code>switch</code> 非常像，<code>_</code> 类似于 <code>switch</code> 中的 <code>default</code>。</p><p>首先来看看 <code>match</code> 的通用形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> target &#123;<br>    模式<span class="hljs-number">1</span> =&gt; 表达式<span class="hljs-number">1</span>,<br>    模式<span class="hljs-number">2</span> =&gt; &#123;<br>        语句<span class="hljs-number">1</span>;<br>        语句<span class="hljs-number">2</span>;<br>        表达式<span class="hljs-number">2</span><br>    &#125;,<br>    _ =&gt; 表达式<span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>    East,<br>    West,<br>    North,<br>    South,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dire</span> = Direction::South;<br>    <span class="hljs-keyword">match</span> dire &#123;<br>        Direction::East =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;East&quot;</span>),<br>        Direction::North | Direction::South =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;South or North&quot;</span>);<br>        &#125;,<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;West&quot;</span>),<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if-let-匹配"><a href="#if-let-匹配" class="headerlink" title="if let 匹配"></a>if let 匹配</h2><p>适用于只有一个模式的值需要被处理，其它值直接忽略的场景。</p><p>可以用 <code>if let</code> 的方式来实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3u8</span>);<br>    <span class="hljs-comment">// 用 match 来处理就要写成下面这样</span><br>    <span class="hljs-keyword">match</span> v &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>        _ =&gt; (),<br>    &#125;<br><br><span class="hljs-comment">// 用 if let 的方式来实现</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-number">3</span>) = v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**当你只要匹配一个条件，且忽略其他条件时就用 <code>if let</code> ，否则都用 <code>match</code>**。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 <code>match</code> 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：</p><ul><li>字面值</li><li>解构的数组、枚举、结构体或者元组</li><li>变量</li><li>通配符</li><li>占位符</li></ul><h3 id="所有可能用到模式的地方"><a href="#所有可能用到模式的地方" class="headerlink" title="所有可能用到模式的地方"></a>所有可能用到模式的地方</h3><h4 id="match-分支"><a href="#match-分支" class="headerlink" title="match 分支"></a>match 分支</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> VALUE &#123;<br>    PATTERN =&gt; EXPRESSION,<br>    PATTERN =&gt; EXPRESSION,<br>    PATTERN =&gt; EXPRESSION,<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，<code>match</code> 的每个分支就是一个<strong>模式</strong>，因为 <code>match</code> 匹配是穷尽式的，因此我们往往需要一个特殊的模式 <code>_</code>，来匹配剩余的所有情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> VALUE &#123;<br>    PATTERN =&gt; EXPRESSION,<br>    PATTERN =&gt; EXPRESSION,<br>    _ =&gt; EXPRESSION,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="if-let-分支"><a href="#if-let-分支" class="headerlink" title="if let 分支"></a>if let 分支</h4><p><code>if let</code> 往往用于匹配一个模式，而忽略剩下的所有模式的场景：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">PATTERN</span> = SOME_VALUE &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="while-let-条件循环"><a href="#while-let-条件循环" class="headerlink" title="while let 条件循环"></a>while let 条件循环</h4><p>一个与 <code>if let</code> 类似的结构是 <code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。下面展示了一个使用 <code>while let</code> 的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Vec是动态数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stack</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-comment">// 向数组尾部插入元素</span><br>stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br>stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);<br>stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// stack.pop从数组尾部弹出元素</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(top) = stack.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, top);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子会打印出 <code>3</code>、<code>2</code> 接着是 <code>1</code>。<code>pop</code> 方法取出动态数组的最后一个元素并返回 <code>Some(value)</code>，如果动态数组是空的，将返回 <code>None</code>，对于 <code>while</code> 来说，只要 <code>pop</code> 返回 <code>Some</code> 就会一直不停的循环。一旦其返回 <code>None</code>，<code>while</code> 循环停止。我们可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br><span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>, value, index);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 <code>enumerate</code> 方法产生一个迭代器，该迭代器每次迭代会返回一个 <code>(索引，值)</code> 形式的元组，然后用 <code>(index,value)</code> 来匹配。</p><h4 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a>let 语句</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">PATTERN</span> = EXPRESSION;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>这其中，<code>x</code> 也是一种模式绑定，代表将<strong>匹配的值绑定到变量 x 上</strong>。因此，在 Rust 中，<strong>变量名也是一种模式</strong>，只不过它比较朴素很不起眼罢了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (x, y, z) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>上面将一个元组与模式进行匹配（<strong>模式和值的类型必需相同！</strong>），然后把 <code>1, 2, 3</code> 分别绑定到 <code>x, y, z</code> 上。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数参数也是模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(x: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-comment">// 代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>x</code> 就是一个模式，你还可以在参数中匹配元组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_coordinates</span>(&amp;(x, y): &amp;(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>)) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Current location: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-title function_ invoke__">print_coordinates</span>(&amp;point);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&amp;(3, 5)</code> 会匹配模式 <code>&amp;(x, y)</code>，因此 <code>x</code> 得到了 <code>3</code>，<code>y</code> 得到了 <code>5</code>。</p><h4 id="let-和-if-let"><a href="#let-和-if-let" class="headerlink" title="let 和 if let"></a>let 和 if let</h4><p>对于以下代码，编译器会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = some_option_value;<br></code></pre></td></tr></table></figure><p>因为右边的值可能不为 <code>Some</code>，而是 <code>None</code>，这种时候就不能进行匹配，也就是上面的代码遗漏了 <code>None</code> 的匹配。</p><p>类似 <code>let</code> , <code>for</code>和<code>match</code> 都必须要求完全覆盖匹配，才能通过编译( 不可驳模式匹配 )。</p><p>但是对于 <code>if let</code>，就可以这样使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = some_option_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 <code>if let</code> 允许匹配一种模式，而忽略其余的模式( 可驳模式匹配 )。</p><h4 id="let-else-Rust-1-65-新增"><a href="#let-else-Rust-1-65-新增" class="headerlink" title="let-else(Rust 1.65 新增)"></a>let-else(Rust 1.65 新增)</h4><p>使用 <code>let-else</code> 匹配，即可使 <code>let</code> 变为可驳模式。它可以使用 <code>else</code> 分支来处理模式不匹配的情况，但是 <code>else</code> 分支中必须用发散的代码块处理（例如：<code>break</code>、<code>return</code>、<code>panic</code>）。请看下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::<span class="hljs-type">str</span>::FromStr;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_count_item</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u64</span>, &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">it</span> = s.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(count_str), <span class="hljs-title function_ invoke__">Some</span>(item)) = (it.<span class="hljs-title function_ invoke__">next</span>(), it.<span class="hljs-title function_ invoke__">next</span>()) <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Can&#x27;t segment count item pair: &#x27;&#123;s&#125;&#x27;&quot;</span>);<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(count) = <span class="hljs-type">u64</span>::<span class="hljs-title function_ invoke__">from_str</span>(count_str) <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Can&#x27;t parse integer: &#x27;&#123;count_str&#125;&#x27;&quot;</span>);<br>    &#125;;<br>    <span class="hljs-comment">// error: `else` clause of `let...else` does not diverge</span><br>    <span class="hljs-comment">// let Ok(count) = u64::from_str(count_str) else &#123; 0 &#125;;</span><br>    (count, item)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">get_count_item</span>(<span class="hljs-string">&quot;3 chairs&quot;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;chairs&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>与 <code>match</code> 和 <code>if let</code> 相比，<code>let-else</code> 的一个显著特点在于其解包成功时所创建的变量具有更广的作用域。在 <code>let-else</code> 语句中，成功匹配后的变量不再仅限于特定分支内使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// if let</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = some_option_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>&#125;<br><br><span class="hljs-comment">// let-else</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = some_option_value <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>if let</code> 写法里的 <code>x</code> 只能在 <code>if</code> 分支内使用，而 <code>let-else</code> 写法里的 <code>x</code> 则可以在 <code>let</code> 之外使用。</p><h2 id="全模式列表"><a href="#全模式列表" class="headerlink" title="全模式列表"></a>全模式列表</h2><h3 id="匹配字面值"><a href="#匹配字面值" class="headerlink" title="匹配字面值"></a>匹配字面值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one&quot;</span>), <span class="hljs-comment">// 这段代码会打印 `one` 因为 `x` 的值是 1</span><br>    <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;two&quot;</span>),<br>    <span class="hljs-number">3</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;anything&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">match</span> x &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">50</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got 50&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Some</span>(y) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y), <span class="hljs-comment">// 输出结果： Matched，y = 5</span><br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦 <code>match</code> 表达式执行完毕，其作用域也就结束了，同理内部 <code>y</code> 的作用域也结束了。最后的 <code>println!</code> 会打印 <code>at the end: x = Some(5), y = 10</code>。</p><h3 id="单分支多模式"><a href="#单分支多模式" class="headerlink" title="单分支多模式"></a>单分支多模式</h3><p>在 <code>match</code> 表达式中，可以使用 <code>|</code> 语法匹配多个模式，它代表 <strong>或</strong>的意思。例如，如下代码将 <code>x</code> 的值与匹配分支相比较，第一个分支有 <strong>或</strong> 选项，意味着如果 <code>x</code> 的值匹配此分支的任何一个模式，它就会运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-number">1</span> | <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one or two&quot;</span>), <span class="hljs-comment">// 输出结果：one or two</span><br>    <span class="hljs-number">3</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;anything&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过序列-匹配值的范围"><a href="#通过序列-匹配值的范围" class="headerlink" title="通过序列 ..&#x3D; 匹配值的范围"></a>通过序列 ..&#x3D; 匹配值的范围</h3><p>在数值类型中我们有讲到一个序列语法，该语法不仅可以用于循环中，还能用于匹配模式。</p><p><code>..=</code> 语法允许你匹配一个闭区间序列内的值。在如下代码中，当模式匹配任何在此序列内的值时，该分支会执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one through five&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;something else&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>x</code> 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 <code>|</code> 运算符表达相同的意思更为方便；相比 <code>1..=5</code>，使用 <code>|</code> 则不得不指定 <code>1 | 2 | 3 | 4 | 5</code> 这五个值，而使用 <code>..=</code> 指定序列就简短的多，比如希望匹配比如从 1 到 1000 的数字的时候！</p><p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。</p><p>如下是一个使用字符类型序列的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>..=<span class="hljs-string">&#x27;j&#x27;</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;early ASCII letter&quot;</span>), <span class="hljs-comment">// 输出结果： early ASCII letter</span><br>    <span class="hljs-string">&#x27;k&#x27;</span>..=<span class="hljs-string">&#x27;z&#x27;</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;late ASCII letter&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;something else&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解构并分解值"><a href="#解构并分解值" class="headerlink" title="解构并分解值"></a>解构并分解值</h3><p>也可以使用模式来解构结构体、枚举、元组、数组和引用。</p><h4 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h4><p>下面代码展示了如何用 <code>let</code> 解构一个带有两个字段 <code>x</code> 和 <code>y</code> 的结构体 <code>Point</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">7</span> &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Point</span> &#123; x, y &#125; = p;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">0</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">7</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码创建了变量 <code>x</code> 和 <code>y</code>，与结构体 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 字段相匹配。其结果是变量 <code>x</code> 和 <code>y</code> 包含结构体 <code>p</code> 中的值。</p><p>下文展示了固定某个字段的匹配方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">7</span> &#125;;<br><br>    <span class="hljs-keyword">match</span> p &#123;<br>        Point &#123; x, y: <span class="hljs-number">0</span> &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;On the x axis at &#123;&#125;&quot;</span>, x),<br>        Point &#123; x: <span class="hljs-number">0</span>, y &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;On the y axis at &#123;&#125;&quot;</span>, y),<br>        Point &#123; x, y &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h4><p>下面代码以 <code>Message</code> 枚举为例，编写一个 <code>match</code> 使用模式解构每一个内部值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>);<br><br>    <span class="hljs-keyword">match</span> msg &#123;<br>        Message::Quit =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The Quit variant has no data to destructure.&quot;</span>)<br>        &#125;<br>        Message::Move &#123; x, y &#125; =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>,<br>                x,<br>                y<br>            );<br>        &#125;<br>        Message::<span class="hljs-title function_ invoke__">Write</span>(text) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Text message: &#123;&#125;&quot;</span>, text),<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,<br>                r,<br>                g,<br>                b<br>            )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h4><p>例如使用下面的代码来同时支持 RGB 和 HSV 色彩模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>   <span class="hljs-title function_ invoke__">Rgb</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>   <span class="hljs-title function_ invoke__">Hsv</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(Color),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(Color::<span class="hljs-title function_ invoke__">Hsv</span>(<span class="hljs-number">0</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>));<br><br>    <span class="hljs-keyword">match</span> msg &#123;<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(Color::<span class="hljs-title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,<br>                r,<br>                g,<br>                b<br>            )<br>        &#125;<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(Color::<span class="hljs-title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,<br>                h,<br>                s,<br>                v<br>            )<br>        &#125;<br>        _ =&gt; ()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h4><p>如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>     x: <span class="hljs-type">i32</span>,<br>     y: <span class="hljs-type">i32</span>,<br> &#125;<br><br><span class="hljs-keyword">let</span> ((feet, inches), Point &#123;x, y&#125;) = ((<span class="hljs-number">3</span>, <span class="hljs-number">10</span>), Point &#123; x: <span class="hljs-number">3</span>, y: -<span class="hljs-number">10</span> &#125;);<br></code></pre></td></tr></table></figure><h4 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h4><p>对于数组，我们可以用类似元组的方式解构，分为两种情况：</p><p>定长数组</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">u16</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">114</span>, <span class="hljs-number">514</span>];<br><span class="hljs-keyword">let</span> [x, y] = arr;<br><br><span class="hljs-built_in">assert_eq!</span>(x, <span class="hljs-number">114</span>);<br><span class="hljs-built_in">assert_eq!</span>(y, <span class="hljs-number">514</span>);<br><br></code></pre></td></tr></table></figure><p>不定长数组</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: &amp;[<span class="hljs-type">u16</span>] = &amp;[<span class="hljs-number">114</span>, <span class="hljs-number">514</span>];<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> [x, ..] = arr &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(x, &amp;<span class="hljs-number">114</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> &amp;[.., y] = arr &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(y, <span class="hljs-number">514</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: &amp;[<span class="hljs-type">u16</span>] = &amp;[];<br><br><span class="hljs-built_in">assert!</span>(matches!(arr, [..]));<br><span class="hljs-built_in">assert!</span>(!matches!(arr, [x, ..]));<br></code></pre></td></tr></table></figure><h3 id="忽略模式中的值"><a href="#忽略模式中的值" class="headerlink" title="忽略模式中的值"></a>忽略模式中的值</h3><p>有时忽略模式中的一些值是很有用的，比如在 <code>match</code> 中的最后一个分支使用 <code>_</code> 模式匹配所有剩余的值。 你也可以在另一个模式中使用 <code>_</code> 模式，使用一个以下划线开始的名称，或者使用 <code>..</code> 忽略所剩部分的值。</p><h4 id="使用-忽略整个值"><a href="#使用-忽略整个值" class="headerlink" title="使用 _ 忽略整个值"></a>使用 _ 忽略整个值</h4><p>虽然 <code>_</code> 模式作为 <code>match</code> 表达式最后的分支特别有用，但是它的作用还不限于此。例如可以将其用于函数参数中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这段代码会完全忽略作为第一个参数传递的值 `3`，并会打印出 `This code only uses the y parameter: 4`。</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(_: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This code only uses the y parameter: &#123;&#125;&quot;</span>, y);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">foo</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用嵌套的-忽略部分值"><a href="#使用嵌套的-忽略部分值" class="headerlink" title="使用嵌套的 _ 忽略部分值"></a>使用嵌套的 _ 忽略部分值</h4><p>可以在一个模式内部使用 <code>_</code> 忽略部分值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">setting_value</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">new_setting_value</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">match</span> (setting_value, new_setting_value) &#123;<br><span class="hljs-comment">// 第一个匹配分支，我们不关心里面的值，只关心元组中两个元素的类型，因此对于 `Some` 中的值，直接进行忽略</span><br>    (<span class="hljs-title function_ invoke__">Some</span>(_), <span class="hljs-title function_ invoke__">Some</span>(_)) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can&#x27;t overwrite an existing customized value&quot;</span>);<br>    &#125;<br>    _ =&gt; &#123;<br>        setting_value = new_setting_value;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;setting is &#123;:?&#125;&quot;</span>, setting_value);<br><br><span class="hljs-comment">// 这段代码会打印出 `Can&#x27;t overwrite an existing customized value` 接着是 `setting is Some(5)`。</span><br></code></pre></td></tr></table></figure><p>还可以在一个模式中的多处使用下划线来忽略特定值，如下所示，这里忽略了一个五元元组中的第二和第四个值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">numbers</span> = (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>);<br><br><span class="hljs-keyword">match</span> numbers &#123;<br>    (first, _, third, _, fifth) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Some numbers: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, first, third, fifth)<br>    &#125;,<br>&#125;<br><br><span class="hljs-comment">// 这会打印出 `Some numbers: 2, 8, 32`, 值 4 和 16 会被忽略。</span><br></code></pre></td></tr></table></figure><h4 id="使用下划线开头忽略未使用的变量"><a href="#使用下划线开头忽略未使用的变量" class="headerlink" title="使用下划线开头忽略未使用的变量"></a>使用下划线开头忽略未使用的变量</h4><p>如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-comment">// 这里得到了警告说未使用变量 `y`，至于 `x` 则没有警告。</span><br></code></pre></td></tr></table></figure><p>注意, 只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：比如 <strong><code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello!&quot;</span>));<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(_s) = s &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found a string&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, s);<br></code></pre></td></tr></table></figure><p><code>s</code> 是一个拥有所有权的动态字符串，在上面代码中，我们会得到一个错误，因为 <code>s</code> 的值会被转移给 <code>_s</code>，在 <code>println!</code> 中再次使用 <code>s</code> 会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0382]: borrow of partially moved value: `s`<br> --&gt; src/main.rs:8:22<br>  |<br>4 |     <span class="hljs-keyword">if</span> <span class="hljs-built_in">let</span> Some(_s) = s &#123;<br>  |                 -- value partially moved here<br>...<br>8 |     println!(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, s);<br>  |                      ^ value borrowed here after partial move<br></code></pre></td></tr></table></figure><p>只使用下划线本身，则并不会绑定值，因为 <code>s</code> 没有被移动进 <code>_</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello!&quot;</span>));<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(_) = s &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found a string&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, s);<br></code></pre></td></tr></table></figure><h4 id="用-忽略剩余值"><a href="#用-忽略剩余值" class="headerlink" title="用 .. 忽略剩余值"></a>用 .. 忽略剩余值</h4><p>对于有多个部分的值，可以使用 <code>..</code> 语法来只使用部分值而忽略其它值，这样也不用再为每一个被忽略的值都单独列出下划线。<code>..</code> 模式会忽略模式中剩余的任何没有显式匹配的值部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>    z: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-keyword">match</span> origin &#123;<br>    Point &#123; x, .. &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is &#123;&#125;&quot;</span>, x),<br>&#125;<br></code></pre></td></tr></table></figure><p>这里列出了 <code>x</code> 值，接着使用了 <code>..</code> 模式来忽略其它字段，这样的写法要比一一列出其它字段，然后用 <code>_</code> 忽略简洁的多。</p><p>还可以用 <code>..</code> 来忽略元组中间的某些值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">numbers</span> = (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>);<br><br>    <span class="hljs-keyword">match</span> numbers &#123;<br>        (first, .., last) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;</span>, first, last);<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用 <code>first</code> 和 <code>last</code> 来匹配第一个和最后一个值。<code>..</code> 将匹配并忽略中间的所有值。</p><h3 id="匹配守卫提供的额外条件"><a href="#匹配守卫提供的额外条件" class="headerlink" title="匹配守卫提供的额外条件"></a>匹配守卫提供的额外条件</h3><p><strong>匹配守卫</strong>（_match guard_）是一个位于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它能为分支模式提供更进一步的匹配条件。</p><p>这个条件可以使用模式中创建的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">match</span> num &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(x) <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;less than five: &#123;&#125;&quot;</span>, x),<br>    <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x),<br>    <span class="hljs-literal">None</span> =&gt; (),<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子会打印出 <code>less than five: 4</code>。当 <code>num</code> 与模式中第一个分支匹配时，<code>Some(4)</code> 可以与 <code>Some(x)</code> 匹配，接着匹配守卫检查 <code>x</code> 值是否小于 5，因为 4 小于 5，所以第一个分支被选择。</p><p>也可以在匹配守卫中使用 <strong>或</strong> 运算符 <code>|</code> 来指定多个模式，<strong>同时匹配守卫的条件会作用于所有的模式</strong>。下面代码展示了匹配守卫与 <code>|</code> 的优先级。这个例子中看起来好像 <code>if y</code> 只作用于 <code>6</code>，但实际上匹配守卫 <code>if y</code> 作用于 <code>4</code>、<code>5</code> <strong>和</strong> <code>6</code> ，在满足 <code>x</code> 属于 <code>4 | 5 | 6</code> 后才会判断 <code>y</code> 是否为 <code>true</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span> <span class="hljs-keyword">if</span> y =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;yes&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;no&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>这个匹配条件表明此分支只匹配 <code>x</code> 值为 <code>4</code>、<code>5</code> 或 <code>6</code> <strong>同时</strong> <code>y</code> 为 <code>true</code> 的情况。</p><p>虽然在第一个分支中，<code>x</code> 匹配了模式 <code>4</code> ，但是对于匹配守卫 <code>if y</code> 来说，因为 <code>y</code> 是 <code>false</code>，因此该守卫条件的值永远是 <code>false</code>，也意味着第一个分支永远无法被匹配。</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a>@绑定</h3><p><code>@</code>（读作 at）运算符允许为一个字段绑定另外一个变量。下面例子中，我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否位于 <code>3..=7</code> 范围内，同时也希望能将其值绑定到 <code>id_variable</code> 变量中以便此分支中相关的代码可以使用它。我们可以将 <code>id_variable</code> 命名为 <code>id</code>，与字段同名，不过出于示例的目的这里选择了不同的名称。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Hello &#123; id: <span class="hljs-type">i32</span> &#125;,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = Message::Hello &#123; id: <span class="hljs-number">5</span> &#125;;<br><br><span class="hljs-keyword">match</span> msg &#123;<br>    Message::Hello &#123; id: id_variable @ <span class="hljs-number">3</span>..=<span class="hljs-number">7</span> &#125; =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)<br>    &#125;,<br>    Message::Hello &#123; id: <span class="hljs-number">10</span>..=<span class="hljs-number">12</span> &#125; =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Found an id in another range&quot;</span>)<br>    &#125;,<br>    Message::Hello &#123; id &#125; =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>上例会打印出 <code>Found an id in range: 5</code>。通过在 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们捕获了任何匹配此范围的值并同时将该值绑定到变量 <code>id_variable</code> 上。</p><p>第二个分支只在模式中指定了一个范围，<code>id</code> 字段的值可以是 <code>10、11 或 12</code>，不过这个模式的代码并不知情也不能使用 <code>id</code> 字段中的值，因为没有将 <code>id</code> 值保存进一个变量。</p><p>最后一个分支指定了一个没有范围的变量，此时确实拥有可以用于分支代码的变量 <code>id</code>，因为这里使用了结构体字段简写语法。不过此分支中没有像头两个分支那样对 <code>id</code> 字段的值进行测试：任何值都会匹配此分支。</p><p>当你既想要限定分支范围，又想要使用分支的变量时，就可以用 <code>@</code> 来绑定到一个新的变量上，实现想要的功能。</p><h4 id="前绑定后解构-Rust-1-56-新增"><a href="#前绑定后解构-Rust-1-56-新增" class="headerlink" title="@前绑定后解构(Rust 1.56 新增)"></a>@前绑定后解构(Rust 1.56 新增)</h4><p>使用 <code>@</code> 还可以在绑定新变量的同时，对目标进行解构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 绑定新变量 `p`，同时对 `Point` 进行解构</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> @ Point &#123;x: px, y: py &#125; = Point &#123;x: <span class="hljs-number">10</span>, y: <span class="hljs-number">23</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, px, py);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, p);<br><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = Point &#123;x: <span class="hljs-number">10</span>, y: <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> @ Point &#123;x: <span class="hljs-number">10</span>, y&#125; = point &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is 10 and y is &#123;&#125; in &#123;:?&#125;&quot;</span>, y, p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x was not 10 :(&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="新特性-Rust-1-53-新增"><a href="#新特性-Rust-1-53-新增" class="headerlink" title="@新特性(Rust 1.53 新增)"></a>@新特性(Rust 1.53 新增)</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-number">1</span> &#123;<br>    <span class="hljs-comment">// Rust 1.53 之后的版本才支持</span><br>        num @ (<span class="hljs-number">1</span> | <span class="hljs-number">2</span>) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br>        &#125;<br>        _ =&gt; &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 14 方法(Method)</title>
    <link href="/2024/11/12/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2014%20%E6%96%B9%E6%B3%95(Method)/"/>
    <url>/2024/11/12/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2014%20%E6%96%B9%E6%B3%95(Method)/</url>
    
    <content type="html"><![CDATA[<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><p>Rust 使用 <code>impl</code> 来定义方法，例如以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Circle</span> &#123;<br>    x: <span class="hljs-type">f64</span>,<br>    y: <span class="hljs-type">f64</span>,<br>    radius: <span class="hljs-type">f64</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-comment">// new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字</span><br>    <span class="hljs-comment">// 这种方法往往用于初始化当前结构体的实例</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: <span class="hljs-type">f64</span>, y: <span class="hljs-type">f64</span>, radius: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> Circle &#123;<br>        Circle &#123;<br>            x: x,<br>            y: y,<br>            radius: radius,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Circle的方法，&amp;self表示借用当前的Circle结构体</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        std::<span class="hljs-type">f64</span>::consts::PI * (<span class="hljs-keyword">self</span>.radius * <span class="hljs-keyword">self</span>.radius)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里先不详细展开讲解，只是先建立对方法定义的大致印象。下面的图片将 Rust 方法定义与其它语言的方法定义做了对比：</p><p><img src="/img/rust_method.png"></p><p>可以看出，其它语言中所有定义都在 <code>class</code> 中，但是 Rust 的对象定义和方法定义是分离的，这种数据和使用分离的方式，会给予使用者极高的灵活度。</p><p>再来看一个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,<br>        rect1.<span class="hljs-title function_ invoke__">area</span>()<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>该例子定义了一个 <code>Rectangle</code> 结构体，并且在其上定义了一个 <code>area</code> 方法，用于计算该矩形的面积。</p><p><code>impl Rectangle &#123;&#125;</code> 表示为 <code>Rectangle</code> 实现方法（<code>impl</code> 是实现 <em>implementation</em> 的缩写），这样的写法表明 <code>impl</code> 语句块中的一切都是跟 <code>Rectangle</code> 相关联的。</p><h3 id="self、-self-和-mut-self"><a href="#self、-self-和-mut-self" class="headerlink" title="self、&amp;self 和 &amp;mut self"></a>self、&amp;self 和 &amp;mut self</h3><p> <code>area</code> 的签名中，我们使用 <code>&amp;self</code> 替代 <code>rectangle: &amp;Rectangle</code>，<code>&amp;self</code> 其实是 <code>self: &amp;Self</code> 的简写（注意大小写）。在一个 <code>impl</code> 块内，<code>Self</code> 指代被实现方法的结构体类型，<code>self</code> 指代此类型的实例，换句话说，<code>self</code> 指代的是 <code>Rectangle</code> 结构体实例，这样的写法会让我们的代码简洁很多，而且非常便于理解：我们为哪个结构体实现方法，那么 <code>self</code> 就是指代哪个结构体的实例。</p><p>需要注意的是，<code>self</code> 依然有所有权的概念：</p><ul><li><code>self</code> 表示 <code>Rectangle</code> 的所有权转移到该方法中，这种形式用的较少</li><li><code>&amp;self</code> 表示该方法对 <code>Rectangle</code> 的不可变借用</li><li><code>&amp;mut self</code> 表示可变借用</li></ul><p>总之，<code>self</code> 的使用就跟函数参数一样，要严格遵守 Rust 的所有权规则。</p><p>简单总结下，使用方法代替函数有以下好处：</p><ul><li>不用在函数签名中重复书写 <code>self</code> 对应的类型</li><li>代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大</li></ul><h3 id="方法名跟结构体字段名相同"><a href="#方法名跟结构体字段名相同" class="headerlink" title="方法名跟结构体字段名相同"></a>方法名跟结构体字段名相同</h3><p>在 Rust 中，允许方法名跟结构体的字段名相同：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">width</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt; <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> rect1.<span class="hljs-title function_ invoke__">width</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The rectangle has a nonzero width; it is &#123;&#125;&quot;</span>, rect1.width);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用 <code>rect1.width()</code> 时，Rust 知道我们调用的是它的方法，如果使用 <code>rect1.width</code>，则是访问它的字段。</p><p>一般来说，方法跟字段同名，往往适用于实现 <code>getter</code> 访问器，例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>        width: <span class="hljs-type">u32</span>,<br>        <span class="hljs-keyword">pub</span> height: <span class="hljs-type">u32</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(width: <span class="hljs-type">u32</span>, height: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            Rectangle &#123; width, height &#125;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">width</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.width;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">height</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.height;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = my::Rectangle::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">30</span>, <span class="hljs-number">50</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="hljs-title function_ invoke__">width</span>()); <span class="hljs-comment">// OK</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="hljs-title function_ invoke__">height</span>()); <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, rect1.width); // Error - the visibility of field defaults to private</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, rect1.height); <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当从模块外部访问结构体时，结构体的字段默认是私有的，其目的是隐藏信息（封装）。我们如果想要从模块外部获取 <code>Rectangle</code> 的字段，只需把它的 <code>new</code>， <code>width</code> 和 <code>height</code> 方法设置为公开可见，那么用户就可以创建一个矩形，同时通过访问器 <code>rect1.width()</code> 和 <code>rect1.height()</code> 方法来获取矩形的宽度和高度。</p><p>因为 <code>width</code> 字段是私有的，当用户访问 <code>rect1.width</code> 字段时，就会报错。注意在此例中，<code>Self</code> 指代的就是被实现方法的结构体 <code>Rectangle</code>。</p><p>特别的是，这种默认的可见性（私有的）可以通过 <code>pub</code> 进行覆盖，这样对于模块外部来说，就可以直接访问使用 <code>pub</code> 修饰的字段而无需通过访问器。这种可见性仅当从定义结构的模块外部访问时才重要，并且具有隐藏信息（封装）的目的。</p><h2 id="带有多个参数的方法"><a href="#带有多个参数的方法" class="headerlink" title="带有多个参数的方法"></a>带有多个参数的方法</h2><p>方法和函数一样，可以使用多个参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt; other.width &amp;&amp; <span class="hljs-keyword">self</span>.height &gt; other.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect2</span> = Rectangle &#123; width: <span class="hljs-number">10</span>, height: <span class="hljs-number">40</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect3</span> = Rectangle &#123; width: <span class="hljs-number">60</span>, height: <span class="hljs-number">45</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can rect1 hold rect2? &#123;&#125;&quot;</span>, rect1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;rect2));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can rect1 hold rect3? &#123;&#125;&quot;</span>, rect1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;rect3));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>这种定义在 <code>impl</code> 中且没有 <code>self</code> 的函数被称之为<strong>关联函数</strong>： 因为它没有 <code>self</code>，不能用 <code>f.read()</code> 的形式调用，因此它是一个函数而不是方法，它又在 <code>impl</code> 中，与结构体紧密关联，因此称为关联函数。</p><p>在之前的代码中，我们已经多次使用过关联函数，例如 <code>String::from</code>，用于创建一个动态字符串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(w: <span class="hljs-type">u32</span>, h: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> Rectangle &#123;<br>        Rectangle &#123; width: w, height: h &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Rust 中有一个约定俗成的规则，使用 <code>new</code> 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 <code>new</code> 作为关键字。</p></blockquote><p>因为是函数，所以不能用 <code>.</code> 的方式来调用，我们需要用 <code>::</code> 来调用，例如 <code>let sq = Rectangle::new(3, 3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。</p><h2 id="多个-impl-定义"><a href="#多个-impl-定义" class="headerlink" title="多个 impl 定义"></a>多个 impl 定义</h2><p>Rust 允许我们为一个结构体定义多个 <code>impl</code> 块，目的是提供更多的灵活性和代码组织性，例如当方法多了后，可以把相关的方法组织在同一个 <code>impl</code> 块中，那么就可以形成多个 <code>impl</code> 块，各自完成一块儿目标：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt; other.width &amp;&amp; <span class="hljs-keyword">self</span>.height &gt; other.height<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为枚举实现方法"><a href="#为枚举实现方法" class="headerlink" title="为枚举实现方法"></a>为枚举实现方法</h2><p>枚举类型之所以强大，不仅仅在于它好用、可以<a href="https://course.rs/basic/compound-type/enum.html#%E5%90%8C%E4%B8%80%E5%8C%96%E7%B1%BB%E5%9E%8B">同一化类型</a>，还在于，我们可以像结构体一样，为枚举实现方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Message</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 在这里定义方法体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Message::<span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    m.<span class="hljs-title function_ invoke__">call</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 13 枚举</title>
    <link href="/2024/11/12/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2013%20%E6%9E%9A%E4%B8%BE/"/>
    <url>/2024/11/12/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2013%20%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<p>枚举(enum 或 enumeration)允许你通过列举可能的成员来定义一个<strong>枚举类型</strong>，例如扑克牌花色：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PokerSuit</span> &#123;<br>  Clubs,<br>  Spades,<br>  Diamonds,<br>  Hearts,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员的实例。</strong></p><h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>我们通过 <code>::</code> 操作符来访问 <code>PokerSuit</code> 下的具体成员，从代码可以清晰看出，<code>heart</code> 和 <code>diamond</code> 都是 <code>PokerSuit</code> 枚举类型的，接着可以定义一个函数来使用它们：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">heart</span> = PokerSuit::Hearts;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">diamond</span> = PokerSuit::Diamonds;<br><br>    <span class="hljs-title function_ invoke__">print_suit</span>(heart); <span class="hljs-comment">// 输出结果：Hearts</span><br>    <span class="hljs-title function_ invoke__">print_suit</span>(diamond); <span class="hljs-comment">// 输出结果：Diamonds</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_suit</span>(card: PokerSuit) &#123;<br>    <span class="hljs-comment">// 需要在定义 enum PokerSuit 的上面添加上 #[derive(Debug)]，否则会报 card 没有实现 Debug</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,card);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>任何类型的数据都可以放入枚举成员中</strong>：例如字符串、数值、结构体甚至另一个枚举。</p><p>看以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m1</span> = Message::Quit;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m2</span> = Message::Move&#123;x:<span class="hljs-number">1</span>,y:<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m3</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该枚举类型代表一条消息，它包含四个不同的成员：</p><ul><li><code>Quit</code> 没有任何关联数据</li><li><code>Move</code> 包含一个匿名结构体</li><li><code>Write</code> 包含一个 <code>String</code> 字符串</li><li><code>ChangeColor</code> 包含三个 <code>i32</code></li></ul><h2 id="同一化类型"><a href="#同一化类型" class="headerlink" title="同一化类型"></a>同一化类型</h2><p>同一化类型的用途：</p><ol><li>类型安全：枚举确保一个值只能是其变体之一，这提供了类型安全，防止了不匹配的情况。</li><li>模式匹配：Rust 的  <code>match</code>  语句允许你根据枚举的变体执行不同的代码块，这是处理枚举值的强大工具。</li><li>代码清晰：使用枚举可以更清晰地表达代码的意图，尤其是在处理有限数量的不同情况时。</li></ol><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 考虑一个简单的IP地址枚举，它有两种变体：IPv4和IPv6：</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    V4,<br>    V6,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">route</span>(ip_kind: IpAddrKind) &#123;<br>    <span class="hljs-comment">// 这里的代码适用于任何IpAddrKind类型的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，  <code>IpAddrKind::V4</code>  和  <code>IpAddrKind::V6</code>  都是  <code>IpAddrKind</code>  类型的值。你可以将它们传递给接受  <code>IpAddrKind</code>  类型的函数，如  <code>route</code>  函数。尽管  <code>V4</code>  和  <code>V6</code>  是不同的变体，它们都被统一视为  <code>IpAddrKind</code>  类型。</p><h2 id="Option-枚举用于处理空值"><a href="#Option-枚举用于处理空值" class="headerlink" title="Option 枚举用于处理空值"></a>Option 枚举用于处理空值</h2><p><code>Option</code> 枚举包含两个成员，一个成员表示含有值：<code>Some(T)</code>, 另一个表示没有值：<code>None</code>，定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>T</code> 是泛型参数，<code>Some(T)</code>表示该枚举成员的数据类型是 <code>T</code>，换句话说，<code>Some</code> 可以包含任何类型的数据。</p><p>再来看以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">some_number</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;a string&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">absent_number</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br></code></pre></td></tr></table></figure><p>如果使用 <code>None</code> 而不是 <code>Some</code>，需要告诉 Rust <code>Option&lt;T&gt;</code> 是什么类型的，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 成员保存的值的类型。</p><p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。</p><p>简而言之，因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，例如，这段代码不能编译，因为它尝试将 <code>Option&lt;i8&gt;</code>(<code>Option&lt;T&gt;</code>) 与 <code>i8</code>(<code>T</code>) 相加：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i8</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = x + y;<br></code></pre></td></tr></table></figure><p>如果运行这些代码，将得到类似这样的错误信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is<br>not satisfied<br> --&gt;<br>  |<br>5 |     <span class="hljs-built_in">let</span> <span class="hljs-built_in">sum</span> = x + y;<br>  |                 ^ no implementation <span class="hljs-keyword">for</span> `i8 + std::option::Option&lt;i8&gt;`<br>  |<br></code></pre></td></tr></table></figure><p>事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值，我们可以放心使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候才需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p><p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行 <code>T</code> 的运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：期望某值不为空但实际上为空的情况。</p><p>不再担心会错误的使用一个空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 12 结构体</title>
    <link href="/2024/11/11/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2012%20%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2024/11/11/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2012%20%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h2 id="结构体语法"><a href="#结构体语法" class="headerlink" title="结构体语法"></a>结构体语法</h2><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>一个结构体由几部分组成：</p><ul><li>通过关键字 <code>struct</code> 定义</li><li>一个清晰明确的结构体 <code>名称</code></li><li>几个有名字的结构体 <code>字段</code></li></ul><p>例如, 以下结构体定义了某网站的用户：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    active: <span class="hljs-type">bool</span>,<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体名称是 <code>User</code>，拥有 4 个字段，且每个字段都有对应的字段名及类型声明，例如 <code>username</code> 代表了用户名，是一个可变的 <code>String</code> 类型。</p><h3 id="创建结构体实例"><a href="#创建结构体实例" class="headerlink" title="创建结构体实例"></a>创建结构体实例</h3><p>有几点值得注意:</p><ul><li>初始化实例时，<strong>每个字段</strong>都需要进行初始化</li><li>初始化时的字段顺序<strong>不需要</strong>和结构体定义时的顺序一致</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>active: <span class="hljs-literal">true</span>,<br>sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="访问结构体字段"><a href="#访问结构体字段" class="headerlink" title="访问结构体字段"></a>访问结构体字段</h3><p>通过 <code>.</code> 操作符即可访问结构体实例内部的字段值，也可以修改它们：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user1</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>active: <span class="hljs-literal">true</span>,<br>sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br><br>user1.email = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;anotheremail@example.com&quot;</span>);<br></code></pre></td></tr></table></figure><p>需要注意：</p><ul><li>必须要将结构体实例声明为可变的，才能修改其中的字段</li><li>Rust 不支持将某个结构体某个字段标记为可变。</li></ul><h3 id="简化结构体创建"><a href="#简化结构体创建" class="headerlink" title="简化结构体创建"></a>简化结构体创建</h3><p>当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟 TypeScript 中一模一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        email,<br>        username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a>结构体更新语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>..user1<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>..</code> 语法表明凡是我们没有显式声明的字段，全部从 <code>user1</code> 中自动获取。需要注意的是 <code>..user1</code> <strong>必须在结构体的尾部使用</strong>。</p><blockquote><p>结构体更新语法跟赋值语句 <code>=</code> 非常相像，因此在上面代码中，<code>user1</code> 的部分字段所有权被转移到 <code>user2</code> 中：<code>username</code> 字段发生了所有权转移，作为结果，<code>user1</code> 无法再被使用。</p></blockquote><h2 id="元组结构体-Tuple-Struct"><a href="#元组结构体-Tuple-Struct" class="headerlink" title="元组结构体(Tuple Struct)"></a>元组结构体(Tuple Struct)</h2><p>结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = <span class="hljs-title function_ invoke__">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的 <code>Point</code> 元组结构体，众所周知 3D 点是 <code>(x, y, z)</code> 形式的坐标点，因此我们无需再为内部的字段逐一命名为：<code>x</code>, <code>y</code>, <code>z</code>。</p><h2 id="单元结构体-Unit-like-Struct"><a href="#单元结构体-Unit-like-Struct" class="headerlink" title="单元结构体(Unit-like Struct)"></a>单元结构体(Unit-like Struct)</h2><p>如果你定义一个类型，但是不关心该类型的内容，只关心它的行为时，就可以使用 <code>单元结构体</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlwaysEqual</span>;<br><br><span class="hljs-comment">// 实例化不需要花括号或圆括号</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">subject</span> = AlwaysEqual;<br><br><span class="hljs-comment">// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SomeTrait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AlwaysEqual</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h2><ul><li>实现了 <code>Copy</code> 特征的类型无需所有权转移，可以直接在赋值时进行数据拷贝，如<code>active(bool)</code> 和 <code>sign_in_count(u64)</code> 字段。</li><li>没有实现 <code>Copy</code> 特征的类型所有权发生转移，如 <code>username(String)</code>，导致了 <code>user1</code> 无法再被使用，但是 <code>user1</code> 内部的其它字段不受影响。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>    username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>    active: <span class="hljs-literal">true</span>,<br>    sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>    active: user1.active,<br>    username: user1.username,<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>    sign_in_count: user1.sign_in_count,<br>&#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, user1.active);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, user1.email);<br><span class="hljs-comment">// 下面这行会报错</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1);<br></code></pre></td></tr></table></figure><h2 id="使用-derive-Debug-来打印结构体的信息"><a href="#使用-derive-Debug-来打印结构体的信息" class="headerlink" title="使用 #[derive(Debug)] 来打印结构体的信息"></a>使用 <code>#[derive(Debug)]</code> 来打印结构体的信息</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;&#125;&quot;</span>, rect1); <span class="hljs-comment">// 报错</span><br>    <span class="hljs-comment">// error[E0277]: `Rectangle` doesn&#x27;t implement `std::fmt::Display`</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1); <span class="hljs-comment">// 报错</span><br>    <span class="hljs-comment">// error[E0277]: `Rectangle` doesn&#x27;t implement `Debug`</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Rust 默认没有实现 <code>Display</code> 特征，<code>&#123;&#125;</code> 不可用</p></li><li><p>Rust 默认没有实现 <code>Debug</code> 特征，<code>&#123;:?&#125;</code>不可用 ，为了实现，有两种方式可以选择：</p><ul><li>手动实现</li><li>使用 <code>derive</code> 派生实现</li></ul></li></ul><p>后者简单得多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);<br>    <span class="hljs-comment">// 输出结果：rect1 is Rectangle &#123; width: 30, height: 50 &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当结构体较大时，我们可能希望能够有更好的输出表现，此时可以使用 <strong><code>&#123;:#?&#125;</code></strong> 来替代 <code>&#123;:?&#125;</code>，输出如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">rect1 is Rectangle &#123;<br>    width: 30,<br>    height: 50,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 11 元组(tuple)</title>
    <link href="/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2011%20%E5%85%83%E7%BB%84(tuple)/"/>
    <url>/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2011%20%E5%85%83%E7%BB%84(tuple)/</url>
    
    <content type="html"><![CDATA[<p>元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。</p><h2 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h2><p>可以通过以下语法创建一个元组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 变量 tup 被绑定了一个元组值 (500, 6.4, 1)，该元组的类型是 (i32, f64, u8) </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用模式匹配解构元组"><a href="#用模式匹配解构元组" class="headerlink" title="用模式匹配解构元组"></a>用模式匹配解构元组</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> (x, y, z) = tup;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>    <span class="hljs-comment">// 输出结果：The value of y is: 6.4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码首先创建一个元组，然后将其绑定到 <code>tup</code> 上，接着使用 <code>let (x, y, z) = tup;</code> 来完成一次模式匹配，因为元组是 <code>(n1, n2, n3)</code> 形式的，因此我们用一模一样的 <code>(x, y, z)</code> 形式来进行匹配，元组中对应的值会绑定到变量 <code>x</code>， <code>y</code>， <code>z</code>上。这就是解构：用同样的形式把一个复杂对象中的值匹配出来。</p><h2 id="用-来访问元组"><a href="#用-来访问元组" class="headerlink" title="用 . 来访问元组"></a>用 <code>.</code> 来访问元组</h2><p>模式匹配可以让我们一次性把元组中的值全部或者部分获取出来，如果只想要访问某个特定元素，那模式匹配就略显繁琐，对此，Rust 提供了 <code>.</code> 的访问方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">five_hundred</span> = x.<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">six_point_four</span> = x.<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span> = x.<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和其它语言的数组、字符串一样，<strong>元组的索引从 0 开始</strong>。</p><h2 id="元组的使用示例"><a href="#元组的使用示例" class="headerlink" title="元组的使用示例"></a>元组的使用示例</h2><p>元组在函数返回值场景很常用，例如下面的代码，可以使用元组返回多个值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> (s2, len) = <span class="hljs-title function_ invoke__">calculate_length</span>(s1);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>, <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = s.<span class="hljs-title function_ invoke__">len</span>(); <span class="hljs-comment">// len() 返回字符串的长度</span><br><br>    (s, length)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>calculate_length</code> 函数接收 <code>s1</code> 字符串的所有权，然后计算字符串的长度，接着把字符串所有权和字符串长度再返回给 <code>s2</code> 和 <code>len</code> 变量。</p><p>在其他语言中，可以用结构体来声明一个三维空间中的点，例如 <code>Point(10, 20, 30)</code>，虽然使用 Rust 元组也可以做到：<code>(10, 20, 30)</code>，但是这样写有个非常重大的缺陷：</p><p><strong>不具备任何清晰的含义</strong>，在下一章节中，会提到一种与元组类似的结构体，<code>元组结构体</code>，可以解决这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 10 数组(array)</title>
    <link href="/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2010%20%E6%95%B0%E7%BB%84(array)/"/>
    <url>/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2010%20%E6%95%B0%E7%BB%84(array)/</url>
    
    <content type="html"><![CDATA[<p>在 Rust 中，最常用的数组有两种：</p><ul><li>第一种是速度很快但是长度固定的 <code>array</code></li><li>第二种是可动态增长的但是有性能损耗的 <code>Vector</code></li></ul><p>对于本章节，我们的重点还是放在数组 <code>array</code> 上。数组的具体定义很简单：将多个类型相同的元素依次组合在一起，就是一个数组。</p><p>数组的三要素：</p><ul><li>长度固定</li><li>元素必须有相同的类型</li><li>依次线性排列</li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>在 Rust 中，数组是这样定义的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 1. 简单字面量定义, 编译器自动推导出数组的类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <br><span class="hljs-comment">// 2. 显式声明：声明类型和长度</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// 3. 某个值重复出现 N 次的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = [<span class="hljs-number">1</span>; <span class="hljs-number">3</span>];<br><span class="hljs-comment">// let c = [1, 1, 1]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组类型是通过方括号语法声明<code>[T; N]</code>，<code>T</code> 是元素类型，分号后面的 <code>N</code> 是数组长度，数组类型也从侧面说明了<strong>数组的元素类型要统一，长度要固定</strong>。</p><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>因为数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = a[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 获取a数组第一个元素, first = 9</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = a[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 获取第二个元素, second = 8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与许多语言类似，<strong>数组的索引下标是从 0 开始</strong>的。此处，<code>first</code> 获取到的值是 <code>9</code>，<code>second</code> 是 <code>8</code>。</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第一个元素：&#123;&#125;&quot;</span>, arr[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;不存在的元素：&#123;&#125;&quot;</span>, arr[<span class="hljs-number">5</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>cargo run</code> 来运行代码，因为数组只有 5 个元素，如果我们试图输入 <code>5</code> 去访问第 6 个元素，则会访问到不存在的数组元素，最终程序会崩溃退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">error: this operation will panic at runtime<br> --&gt; src/main.rs:4:27<br>  |<br>4 |     println!(<span class="hljs-string">&quot;不存在的元素：&#123;&#125;&quot;</span>, arr[5]);<br>  |                                  ^^^^^^ index out of bounds: the length is 5 but the index is 5<br>  |<br>  = note: `#[deny(unconditional_panic)]` on by default<br><br>error: could not compile `compound_types` (bin <span class="hljs-string">&quot;compound_types&quot;</span>) due to 1 previous error<br></code></pre></td></tr></table></figure><p>这就是数组访问越界，访问了数组中不存在的元素，导致 Rust 运行时错误。程序因此退出并显示错误消息，未执行最后的 <code>println!</code> 语句。</p><h2 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h2><p>切片允许你引用集合中的部分连续片段，而不是整个集合，对于数组也是，数组切片允许我们引用数组的一部分：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span>: &amp;[<span class="hljs-type">i32</span>] = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br><br><span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>上面的数组切片 <code>slice</code> 的类型是<code>&amp;[i32]</code>，与之对比，数组的类型是<code>[i32;5]</code>，简单总结下切片的特点：</p><ul><li>切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置</li><li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li><li>切片类型 [T] 拥有不固定的大小，而切片引用类型 &amp;[T] 则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此 &amp;[T] 更有用，<code>&amp;str</code> 字符串切片也同理</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 编译器自动推导出one的类型</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span>             = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-comment">// 显式类型标注</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">two</span>: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>]    = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">blank1</span>          = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">blank2</span>: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];<br><br>  <span class="hljs-comment">// arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">arrays</span>: [[<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>]; <span class="hljs-number">4</span>]  = [one, two, blank1, blank2];<br><br>  <span class="hljs-comment">// 借用arrays的元素用作循环中</span><br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> &amp;arrays &#123;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;:?&#125;: &quot;</span>, a);<br>    <span class="hljs-comment">// 将a变成一个迭代器，用于循环</span><br>    <span class="hljs-comment">// 你也可以直接用for n in a &#123;&#125;来进行循环</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">n</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>      <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\t&#123;&#125; + 10 = &#123;&#125;&quot;</span>, n, n+<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 0..a.len,是一个 Rust 的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..a.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>      sum += a[i];<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\t(&#123;:?&#125; = &#123;&#125;)&quot;</span>, a, sum);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>做个总结，数组虽然很简单，但是其实还是存在几个要注意的点：</p><ul><li><strong>数组类型容易跟数组切片混淆</strong>，[T;n] 描述了一个数组的类型，而 [T] 描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译期得知，因此不能用 [T;n] 的形式去描述</li><li><code>[u8; 3]</code>和<code>[u8; 4]</code>是不同的类型，数组的长度也是类型的一部分</li><li>**在实际开发中，使用最多的是数组切片[T]**，我们往往通过引用的方式去使用<code>&amp;[T]</code>，因为后者有固定的类型大小</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 8 切片(slice)</title>
    <link href="/2024/11/07/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%208%20%E5%88%87%E7%89%87(slice)/"/>
    <url>/2024/11/07/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%208%20%E5%88%87%E7%89%87(slice)/</url>
    
    <content type="html"><![CDATA[<p>切片并不是 Rust 独有的概念，在 Go 语言中就非常流行，它允许你引用集合中部分连续的元素序列，而不是引用整个集合。</p><p>Rust常见的数据类型中，有三种类型已支持Slice操作: <strong>String类型</strong>、<strong>Array类型</strong>和<strong>Vec类型</strong></p><p>对于字符串而言，切片就是对 <code>String</code> 类型中某一部分的引用，它看起来像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = &amp;s[<span class="hljs-number">6</span>..<span class="hljs-number">11</span>];<br></code></pre></td></tr></table></figure><p><code>hello</code> 没有引用整个 <code>String s</code>，而是引用了 <code>s</code> 的一部分内容，通过 <code>[0..5]</code> 的方式来指定。</p><h2 id="切片语法"><a href="#切片语法" class="headerlink" title="切片语法"></a>切片语法</h2><p>创建切片使用方括号包括的一个序列：<strong>[开始索引..终止索引]</strong></p><blockquote><p>其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置。</p></blockquote><p>对于 <code>let world = &amp;s[6..11];</code> 来说，<code>world</code> 是一个切片，该切片的指针指向 <code>s</code> 的第 7 个字节(索引从 0 开始, 6 是第 7 个字节)，且该切片的长度是 <code>5</code> 个字节。</p><p><img src="/img/rust_slice.jpg"></p><p>在使用 Rust 的 <code>..</code> <a href="https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range">range 序列</a>语法时，如果你想从索引 0 开始，可以使用如下的方式，这两个是等效的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>同样的，如果你的切片想要包含 <code>String</code> 的最后一个字节，则可以这样使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">4</span>..len];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">4</span>..];<br></code></pre></td></tr></table></figure><p>你也可以截取完整的 <code>String</code> 切片：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..len];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..];<br></code></pre></td></tr></table></figure><h2 id="索引边界"><a href="#索引边界" class="headerlink" title="索引边界"></a>索引边界</h2><p>在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节，下面的代码就会崩溃：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;中国人&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,a);<br></code></pre></td></tr></table></figure><p>因为我们只取 <code>s</code> 字符串的前两个字节，但是本例中每个汉字占用三个字节，因此没有落在边界处，也就是连 <code>中</code> 字都取不完整，此时程序会直接崩溃退出，如果改成 <code>&amp;s[0..3]</code>，则可以正常通过编译。 因此，当你需要对字符串做切片索引操作时，需要格外小心这一点，关于该如何操作 UTF-8 字符串，参见<a href="https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2">这里</a>。</p><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><h3 id="字符串字面量是切片"><a href="#字符串字面量是切片" class="headerlink" title="字符串字面量是切片"></a>字符串字面量是切片</h3><p>之前提到过字符串字面量，但是没有提到它的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>实际上，<code>s</code> 的类型是 <code>&amp;str</code>，因此你也可以这样声明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>该切片指向了程序可执行文件中的某个点，这也是为什么字符串字面量是不可变的，因为 <code>&amp;str</code> 是一个不可变引用。</p><p>字符串切片的类型标识是 <code>&amp;str</code>，因此我们可以这样声明一个函数，输入 <code>String</code> 类型，返回它的切片：<code>fn first_word(s: &amp;String) -&gt; &amp;str</code> 。</p><p>有了切片就可以写出这样的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">word</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;s);<br><br>    s.<span class="hljs-title function_ invoke__">clear</span>(); <span class="hljs-comment">// error!</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the first word is: &#123;&#125;&quot;</span>, word);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    &amp;s[..<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器报错如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable<br>  --&gt; src/main.rs:18:5<br>   |<br>16 |     <span class="hljs-built_in">let</span> word = first_word(&amp;s);<br>   |                           -- immutable borrow occurs here<br>17 |<br>18 |     s.clear(); // error!<br>   |     ^^^^^^^^^ mutable borrow occurs here<br>19 |<br>20 |     println!(<span class="hljs-string">&quot;the first word is: &#123;&#125;&quot;</span>, word);<br>   |                                       ---- immutable borrow later used here<br></code></pre></td></tr></table></figure><p>回忆一下借用的规则：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 <code>clear</code> 需要清空改变 <code>String</code>，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 <code>pub fn clear(&amp;mut self)</code> ，参数是对自身的可变借用 ）；而之后的 <code>println!</code> 又使用了不可变借用，也就是在 <code>s.clear()</code> 处可变借用与不可变借用试图同时生效，因此编译无法通过。</p><p>从上述代码可以看出，Rust 不仅让我们的 <code>API</code> 更加容易使用，而且也在编译期就消除了大量错误！</p><h2 id="其他切片"><a href="#其他切片" class="headerlink" title="其他切片"></a>其他切片</h2><p>因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br><br><span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>该数组切片的类型是 <code>&amp;[i32]</code>，数组切片和字符串切片的工作方式是一样的，例如持有一个引用指向原始数组的某个元素和长度。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><code>len()</code> 获取 slice 元素个数</li><li><code>is_empty()</code> 判断slice是否为空</li><li><code>contains()</code> 判断是否包含某个元素</li><li><code>repeat()</code> 重复slice指定次数</li><li><code>reverse()</code> 反转slice</li><li><code>join()</code> 将各元素压平(flatten)并通过指定的分隔符连接起来</li><li><code>swap()</code> 交换两个索引处的元素，如 <code>s.swap(1.3)</code></li><li><code>windows()</code> 以指定大小的窗口进行滚动法代</li><li><code>starts_with()</code> 判断 slice 是否以某个 slice 开头</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 7 引用与借用</title>
    <link href="/2024/11/05/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%207%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/"/>
    <url>/2024/11/05/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%207%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Rust 通过 <code>借用(Borrowing)</code> 这个概念来达成上述的目的，**获取变量的引用，称之为借用(borrowing)**。</p><h2 id="引用与解引用"><a href="#引用与解引用" class="headerlink" title="引用与解引用"></a>引用与解引用</h2><p>常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个 <code>i32</code> 值的引用 <code>y</code>，然后使用解引用运算符来解出 <code>y</code> 所使用的值:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;x;<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br></code></pre></td></tr></table></figure><p>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。<code>y</code> 是 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。然而，如果希望对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来解出引用所指向的值（也就是<strong>解引用</strong>）。一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</p><h2 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h2><p>下面的代码，我们用 <code>s1</code> 的引用作为参数传递给 <code>calculate_length</code> 函数，而不是把 <code>s1</code> 的所有权转移给该函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s1);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>能注意到两点：</p><ol><li>无需像上章一样：先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁</li><li><code>calculate_length</code> 的参数 <code>s</code> 类型从 <code>String</code> 变为 <code>&amp;String</code></li></ol><p>这里，<code>&amp;</code> 符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：</p><p>![[rust_borrowing.jpg]]<br>通过 <code>&amp;s1</code> 语法，我们创建了一个<strong>指向 <code>s1</code> 的引用</strong>，但是并不拥有它。因为并不拥有这个值，当引用离开作用域后，其指向的值也不会被丢弃。</p><p>同理，函数 <code>calculate_length</code> 使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123; <span class="hljs-comment">// s 是对 String 的引用</span><br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125; <span class="hljs-comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span><br>  <span class="hljs-comment">// 所以什么也不会发生</span><br></code></pre></td></tr></table></figure><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><p>修改借用的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">change</span>(&amp;<span class="hljs-keyword">mut</span> s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change</span>(some_string: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    some_string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，声明 <code>s</code> 是可变类型，其次创建一个可变的引用 <code>&amp;mut s</code> 和接受可变引用参数 <code>some_string: &amp;mut String</code> 的函数。</p><h3 id="可变引用同时只能存在一个"><a href="#可变引用同时只能存在一个" class="headerlink" title="可变引用同时只能存在一个"></a>可变引用同时只能存在一个</h3><p>不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制： <strong>同一作用域，特定数据只能有一个可变引用</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);<br></code></pre></td></tr></table></figure><p>以上代码会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0499]: cannot borrow `s` as mutable more than once at a time 同一时间无法对 `s` 进行两次可变借用<br> --&gt; src/main.rs:5:14<br>  |<br>4 |     <span class="hljs-built_in">let</span> r1 = &amp;mut s;<br>  |              ------ first mutable borrow occurs here 首个可变引用在这里借用<br>5 |     <span class="hljs-built_in">let</span> r2 = &amp;mut s;<br>  |              ^^^^^^ second mutable borrow occurs here 第二个可变引用在这里借用<br>6 |<br>7 |     println!(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);<br>  |                        -- first borrow later used here 第一个借用在这里使用<br></code></pre></td></tr></table></figure><p>这段代码出错的原因在于，第一个可变借用 <code>r1</code> 必须要持续到最后一次使用的位置 <code>println!</code>，在 <code>r1</code> 创建和最后一次使用之间，我们又尝试创建第二个可变借用 <code>r2</code>。</p><p>这是 Rust 编译器的 <code>borrow checker</code> 特性之一</p><p>这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：</p><ul><li>两个或更多的指针同时访问同一数据</li><li>至少有一个指针被用来写入数据</li><li>没有同步数据访问的机制</li></ul><p>数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。而 Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</p><p>很多时候，大括号可以帮我们解决一些编译不通过的问题，通过手动限制变量的作用域：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><br>&#125; <span class="hljs-comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br></code></pre></td></tr></table></figure><h3 id="可变引用与不可变引用不能同时存在"><a href="#可变引用与不可变引用不能同时存在" class="headerlink" title="可变引用与不可变引用不能同时存在"></a>可变引用与不可变引用不能同时存在</h3><p>下面的代码会导致一个错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;s; <span class="hljs-comment">// 没问题</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;s; <span class="hljs-comment">// 没问题</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = &amp;<span class="hljs-keyword">mut</span> s; <span class="hljs-comment">// 大问题</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);<br></code></pre></td></tr></table></figure><p>错误如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable<br>        // 无法借用可变 `s` 因为它已经被借用了不可变<br> --&gt; src/main.rs:6:14<br>  |<br>4 |     <span class="hljs-built_in">let</span> r1 = &amp;s; // 没问题<br>  |              -- immutable borrow occurs here 不可变借用发生在这里<br>5 |     <span class="hljs-built_in">let</span> r2 = &amp;s; // 没问题<br>6 |     <span class="hljs-built_in">let</span> r3 = &amp;mut s; // 大问题<br>  |              ^^^^^^ mutable borrow occurs here 可变借用发生在这里<br>7 |<br>8 |     println!(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);<br>  |                                -- immutable borrow later used here 不可变借用在这里使用<br></code></pre></td></tr></table></figure><p>其实这个也很好理解，正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。</p><blockquote><p>注意，引用的作用域 <code>s</code> 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 <code>&#125;</code></p></blockquote><p>Rust 的编译器一直在优化，早期的时候，引用的作用域跟变量作用域是一致的，这对日常使用带来了很大的困扰，你必须非常小心的去安排可变、不可变变量的借用，免得无法通过编译，例如以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;s;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);<br>    <span class="hljs-comment">// 新编译器中，r1,r2作用域在这里结束</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r3);<br>&#125; <span class="hljs-comment">// 老编译器中，r1、r2、r3作用域在这里结束</span><br>  <span class="hljs-comment">// 新编译器中，r3作用域在这里结束</span><br></code></pre></td></tr></table></figure><p>在老版本的编译器中（Rust 1.31 前），将会报错，因为 <code>r1</code> 和 <code>r2</code> 的作用域在花括号 <code>&#125;</code> 处结束，那么 <code>r3</code> 的借用就会触发 <strong>无法同时借用可变和不可变</strong> 的规则。</p><p>但是在新的编译器中，该代码将顺利通过，因为 <strong>引用作用域的结束位置从花括号变成最后一次使用的位置</strong>，因此 <code>r1</code> 借用和 <code>r2</code> 借用在 <code>println!</code> 后，就结束了，此时 <code>r3</code> 可以顺利借用到可变引用。</p><h2 id="悬垂引用-Dangling-References"><a href="#悬垂引用-Dangling-References" class="headerlink" title="悬垂引用(Dangling References)"></a>悬垂引用(Dangling References)</h2><p>悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。</p><p>让我们尝试创建一个悬垂引用，Rust 会抛出一个编译时错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">reference_to_nothing</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &amp;s<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0106]: missing lifetime specifier<br> --&gt; src/main.rs:5:16<br>  |<br>5 | fn dangle() -&gt; &amp;String &#123;<br>  |                ^ expected named lifetime parameter<br>  |<br>  = <span class="hljs-built_in">help</span>: this <span class="hljs-keyword">function</span><span class="hljs-string">&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="hljs-string">help: consider using the `&#x27;</span>static` lifetime<br>  |<br>5 | fn dangle() -&gt; &amp;<span class="hljs-string">&#x27;static String &#123;</span><br><span class="hljs-string">  |                ~~~~~~~~</span><br></code></pre></td></tr></table></figure><p>仔细看看 <code>dangle</code> 代码的每一步到底发生了什么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123; <span class="hljs-comment">// dangle 返回一个字符串的引用</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// s 是一个新字符串</span><br><br>    &amp;s <span class="hljs-comment">// 返回字符串 s 的引用</span><br>&#125; <span class="hljs-comment">// 这里 s 离开作用域并被丢弃。其内存被释放。</span><br>  <span class="hljs-comment">// 危险！</span><br></code></pre></td></tr></table></figure><p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放，但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！</p><p>其中一个很好的解决方法是直接返回 <code>String</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">no_dangle</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    s<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就没有任何错误了，最终 <code>String</code> 的 <strong>所有权被转移给外面的调用者</strong>。</p><h2 id="借用规则总结"><a href="#借用规则总结" class="headerlink" title="借用规则总结"></a>借用规则总结</h2><p>总的来说，借用规则如下：</p><ul><li>同一时刻，你只能拥有要么一个可变引用，要么任意多个不可变引用</li><li>引用必须总是有效的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 6 所有权</title>
    <link href="/2024/11/04/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%206%20%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <url>/2024/11/04/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%206%20%E6%89%80%E6%9C%89%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>零开销内存回收 的一种高效实现方式</p></blockquote><p>Rust是一种系统编程语言，其设计目的是确保内存安全并防止数据竞争，而不依赖垃圾回收器。这种内存安全性主要通过所有权系统来实现。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><h3 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h3><table><thead><tr><th>特性</th><th>静态语言</th><th>动态语言</th></tr></thead><tbody><tr><td><strong>类型检查时间</strong></td><td>编译时</td><td>运行时</td></tr><tr><td><strong>类型安全</strong></td><td>更安全，减少运行时类型错误</td><td>较灵活，但类型错误可能在运行时出现</td></tr><tr><td><strong>性能</strong></td><td>通常更高效，编译器优化</td><td>通常较低，运行时类型检查</td></tr><tr><td><strong>灵活性</strong></td><td>较低，需明确声明类型</td><td>较高，允许在运行时改变类型</td></tr><tr><td><strong>代码简洁性</strong></td><td>需要显式类型声明，代码相对冗长</td><td>通常更简洁，适合快速开发</td></tr><tr><td><strong>开发工具支持</strong></td><td>更强大的静态分析和重构工具</td><td>开发工具支持有限，但在快速开发上占优势</td></tr></tbody></table><h3 id="回收方式对比"><a href="#回收方式对比" class="headerlink" title="回收方式对比"></a>回收方式对比</h3><table><thead><tr><th>特性</th><th>C&#x2F;C++</th><th>JavaScript</th><th>Rust</th></tr></thead><tbody><tr><td><strong>内存管理方式</strong></td><td>手动管理 (Manual Management)</td><td>垃圾回收 (Garbage Collection)</td><td>所有权系统 (Ownership System)</td></tr><tr><td><strong>特点</strong></td><td>- 程序员通过 <code>malloc</code> 和 <code>free</code> (C) 或 <code>new</code> 和 <code>delete</code> (C++) 手动分配和释放内存。<br>- 没有内置的垃圾回收机制。</td><td>- 浏览器和Node.js环境中均使用垃圾回收器（如V8引擎的垃圾回收器）。<br>- 采用标记-清除(Mark-and-Sweep)、标记-压缩(Mark-and-Compact)分代回收等算法。</td><td>- Rust使用所有权系统进行内存管理，编译器在编译时通过静态分析来确保内存安全。<br>- 每个值都有一个所有者，在任何时候只能有一个有效的所有者。<br>- 通过借用（引用）机制来共享数据，同时保证数据竞争和悬垂指针的安全。</td></tr><tr><td><strong>优点</strong></td><td>- 高效且灵活，适用于对性能要求极高的系统级编程。</td><td>- 自动内存管理，适合快速开发和运行在多平台上的应用。</td><td>- 在编译时保证内存安全，没有运行时开销。<br>- 避免了数据竞争和悬垂指针。</td></tr><tr><td><strong>缺点</strong></td><td>- 容易出现内存泄漏、悬垂指针和缓冲区溢出等问题，需要非常小心的内存管理。</td><td>- 垃圾回收机制在某些情况下可能导致性能问题，如UI线程停顿。</td><td>- 需要程序员理解和遵循所有权和借用规则，学习曲线较陡。</td></tr></tbody></table><h2 id="栈-Stack-与堆-Heap"><a href="#栈-Stack-与堆-Heap" class="headerlink" title="栈(Stack)与堆(Heap)"></a>栈(Stack)与堆(Heap)</h2><p>栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要，因为这会影响程序的行为和性能。</p><p>栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈按照顺序存储值并以相反顺序取出值，这也被称作<strong>后进先出</strong>。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p><p>增加数据叫做<strong>进栈</strong>，移出数据则叫做<strong>出栈</strong>。</p><p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p><p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的<strong>指针</strong>，该过程被称为<strong>在堆上分配内存</strong>，有时简称为 “分配”(allocating)。</p><p>接着，该指针会被推入<strong>栈</strong>中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的<strong>指针</strong>，来获取数据在堆上的实际内存位置，进而访问该数据。</p><p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭：进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。</p><h3 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h3><p>在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。</p><h3 id="所有权与堆栈"><a href="#所有权与堆栈" class="headerlink" title="所有权与堆栈"></a>所有权与堆栈</h3><p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p><p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p><p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是<strong>在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助</strong>。</p><h2 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h2><blockquote><ol><li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li><li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li><li>当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)</li></ol></blockquote><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>作用域是一个变量在程序中有效的范围，假如有这样一个变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><p>变量 <code>s</code> 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。<code>s</code> 变量从声明的点开始直到当前作用域的结束都是有效的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;                      <span class="hljs-comment">// s 在这里无效，它尚未声明</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;   <span class="hljs-comment">// 从此处起，s 是有效的</span><br><br>    <span class="hljs-comment">// 使用 s</span><br>&#125;                      <span class="hljs-comment">// 此作用域已结束，s不再有效</span><br></code></pre></td></tr></table></figure><p>简而言之，<code>s</code> 从创建开始就有效，然后有效期持续到它离开作用域为止，可以看出，就作用域来说，Rust 语言跟其他编程语言没有区别。</p><h2 id="变量绑定背后的数据交互"><a href="#变量绑定背后的数据交互" class="headerlink" title="变量绑定背后的数据交互"></a>变量绑定背后的数据交互</h2><h3 id="转移所有权"><a href="#转移所有权" class="headerlink" title="转移所有权"></a>转移所有权</h3><p>先来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br></code></pre></td></tr></table></figure><p>这段代码并没有发生所有权的转移，原因很简单： 代码首先将 <code>5</code> 绑定到变量 <code>x</code>，接着<strong>拷贝</strong> <code>x</code> 的值赋给 <code>y</code>，最终 <code>x</code> 和 <code>y</code> 都等于 <code>5</code>，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过<strong>自动拷贝</strong>的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。</p><p>整个过程中的赋值都是通过值拷贝的方式完成（发生在栈中），因此并不需要所有权转移。</p><p>然后再来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br></code></pre></td></tr></table></figure><p>实际上， <code>String</code> 类型是一个复杂类型，由存储在栈中的<strong>堆指针</strong>、<strong>字符串长度</strong>、<strong>字符串容量</strong>共同组成，其中<strong>堆指针</strong>是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，如果你有 Go 语言的经验，这里就很好理解：容量是堆内存分配空间的大小，长度是目前已经使用的大小。</p><p>总之 <code>String</code> 类型指向了一个堆上的空间，这里存储着它的真实数据，下面对上面代码中的 <code>let s2 = s1</code> 分成两种情况讨论：</p><ol><li><p>拷贝 <code>String</code> 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 <code>String</code> 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响</p></li><li><p>只拷贝 <code>String</code> 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 <code>8字节的指针</code>、<code>8字节的长度</code>、<code>8字节的容量</code>，总计 24 字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是：<strong>一个值只允许有一个所有者</strong>，而现在这个值（堆上的真实字符串数据）有了两个所有者：<code>s1</code> 和 <code>s2</code>。</p></li></ol><p>好吧，就假定一个值可以拥有两个所有者，会发生什么呢？</p><p>当变量离开作用域后，Rust 会自动调用 <code>drop</code> 函数并清理变量的堆内存。不过由于两个 <code>String</code> 变量指向了同一位置。这就有了一个问题：当 <code>s1</code> 和 <code>s2</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放（double free）</strong> 的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>因此，Rust 这样解决问题：<strong>当 <code>s1</code> 被赋予 <code>s2</code> 后，Rust 认为 <code>s1</code> 不再有效，因此也无需在 <code>s1</code> 离开作用域后 <code>drop</code> 任何东西，这就是把所有权从 <code>s1</code> 转移给了 <code>s2</code>，<code>s1</code> 在被赋予 <code>s2</code> 后就马上失效了</strong>。</p><p>再来看看，在所有权转移后再来使用旧的所有者，会发生什么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1: &#123;&#125;&quot;</span>, s1)<br></code></pre></td></tr></table></figure><p>由于 Rust 禁止你使用无效的引用，你会看到以下的错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0382]: borrow of moved value: `s1`<br>  --&gt; src/main.rs:13:24<br>   |<br>11 |     <span class="hljs-built_in">let</span> s1 = String::from(<span class="hljs-string">&quot;Hello&quot;</span>);<br>   |         -- move occurs because `s1` has <span class="hljs-built_in">type</span> `String`, <span class="hljs-built_in">which</span> does not implement the `Copy` trait<br>12 |     <span class="hljs-built_in">let</span> s2 = s1;<br>   |              -- value moved here<br>13 |     println!(<span class="hljs-string">&quot;s1: &#123;&#125;&quot;</span>, s1)<br>   |                        ^^ value borrowed here after move<br>   |<br>   = note: this error originates <span class="hljs-keyword">in</span> the macro `<span class="hljs-variable">$crate</span>::format_args_nl` <span class="hljs-built_in">which</span> comes from the expansion of the macro `println` (<span class="hljs-keyword">in</span> Nightly builds, run with -Z macro-backtrace <span class="hljs-keyword">for</span> more info)<br><span class="hljs-built_in">help</span>: consider cloning the value <span class="hljs-keyword">if</span> the performance cost is acceptable<br>   |<br>12 |     <span class="hljs-built_in">let</span> s2 = s1.clone();<br>   |                ++++++++<br><br>For more information about this error, try `rustc --explain E0382`.<br></code></pre></td></tr></table></figure><p>如果你在其他语言中听说过术语 <strong>浅拷贝(shallow copy)</strong> 和 **深拷贝(deep copy)**，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 <code>s1</code> 无效了，因此这个操作被称为 <strong>移动(move)<strong>，而不是浅拷贝。上面的例子可以解读为 <code>s1</code> 被</strong>移动</strong>到了 <code>s2</code> 中。那么具体发生了什么，用一张图简单说明：</p><p><img src="/img/rust_copy.jpg" alt="拷贝"></p><p>这样就解决了我们之前的问题，<code>s1</code> 不再指向任何数据，只有 <code>s2</code> 是有效的，当 <code>s2</code> 离开作用域，它就会释放内存。 相信此刻，你应该明白了，为什么 Rust 称呼 <code>let a = b</code> 为<strong>变量绑定</strong>了吧？</p><h3 id="克隆（深拷贝）"><a href="#克隆（深拷贝）" class="headerlink" title="克隆（深拷贝）"></a>克隆（深拷贝）</h3><p>首先，<strong>Rust 永远也不会自动创建数据的 “深拷贝”</strong>。因此，任何<strong>自动</strong>的复制都不是深拷贝，可以被认为对运行时性能影响较小。</p><p>如果我们<strong>确实</strong>需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);<br></code></pre></td></tr></table></figure><p>这段代码能够正常运行，说明 <code>s2</code> 确实完整的复制了 <code>s1</code> 的数据。</p><p>如果代码性能无关紧要，例如初始化程序时或者在某段时间只会执行寥寥数次时，你可以使用 <code>clone</code> 来简化编程。但是对于执行较为频繁的代码（热点路径），使用 <code>clone</code> 会极大的降低程序性能，需要小心使用！</p><h3 id="拷贝（浅拷贝）"><a href="#拷贝（浅拷贝）" class="headerlink" title="拷贝（浅拷贝）"></a>拷贝（浅拷贝）</h3><p>浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。</p><p>再回到之前看过的例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);<br></code></pre></td></tr></table></figure><p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过依然实现了类似深拷贝的效果 —— 没有报所有权的错误。</p><p>原因是像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效（<code>x</code>、<code>y</code> 都仍然有效）。换句话说，这里没有深浅拷贝的区别，因此这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它（可以理解成在栈上做了深拷贝）。</p><p>Rust 有一个叫做 <code>Copy</code> 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 <code>Copy</code> 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。</p><p>那么什么类型是可 <code>Copy</code> 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则： <strong>任何基本类型的组合可以 <code>Copy</code> ，不需要分配内存或某种形式资源的类型是可以 <code>Copy</code> 的</strong>。如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code></li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code></li><li>所有浮点数类型，比如 <code>f64</code></li><li>字符类型，<code>char</code></li><li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是</li><li>不可变引用 <code>&amp;T</code> ，例如转移所有权中的最后一个例子，<strong>但是注意：可变引用 <code>&amp;mut T</code> 是不可以 Copy的</strong></li></ul><h2 id="函数传值与返回"><a href="#函数传值与返回" class="headerlink" title="函数传值与返回"></a>函数传值与返回</h2><p>将值传递给函数，一样会发生 <code>移动</code> 或者 <code>复制</code>，就跟 <code>let</code> 语句一样，下面的代码展示了所有权、作用域的规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">takes_ownership</span>(s);             <span class="hljs-comment">// s 的值移动到函数里 ...</span><br>                                    <span class="hljs-comment">// ... 所以到这里不再有效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">makes_copy</span>(x);                  <span class="hljs-comment">// x 应该移动函数里，</span><br>                                    <span class="hljs-comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span><br><br>&#125; <span class="hljs-comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br>  <span class="hljs-comment">// 所以不会有特殊操作</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) &#123; <span class="hljs-comment">// some_string 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) &#123; <span class="hljs-comment">// some_integer 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// 这里，some_integer 移出作用域。不会有特殊操作</span><br></code></pre></td></tr></table></figure><p>同样的，函数返回值也有所有权，例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();         <span class="hljs-comment">// gives_ownership 将返回值</span><br>                                        <span class="hljs-comment">// 移给 s1</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 进入作用域</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="hljs-comment">// s2 被移动到</span><br>                                        <span class="hljs-comment">// takes_and_gives_back 中,</span><br>                                        <span class="hljs-comment">// 它也将返回值移给 s3</span><br>&#125; <span class="hljs-comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br>  <span class="hljs-comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;             <span class="hljs-comment">// gives_ownership 将返回值移动给</span><br>                                             <span class="hljs-comment">// 调用它的函数</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// some_string 进入作用域.</span><br><br>    some_string                              <span class="hljs-comment">// 返回 some_string 并移出给调用的函数</span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <span class="hljs-comment">// a_string 进入作用域</span><br><br>    a_string  <span class="hljs-comment">// 返回 a_string 并移出给调用的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： <strong>总是把一个值传来传去来使用它</strong>。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 5 流程控制</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%205%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%205%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><h3 id="使用-if-来做分支控制"><a href="#使用-if-来做分支控制" class="headerlink" title="使用 if 来做分支控制"></a>使用 if 来做分支控制</h3><p>不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 <code>if</code> 的条件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> condition == <span class="hljs-literal">true</span> &#123;<br>    <span class="hljs-comment">// A...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// B...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该代码读作：若 <code>condition</code> 的值为 <code>true</code>，则执行 <code>A</code> 代码，否则执行 <code>B</code> 代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">condition</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-number">5</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-number">6</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码有以下几点要注意：</p><ul><li><strong><code>if</code> 语句块是表达式</strong>，这里我们使用 <code>if</code> 表达式的返回值来给 <code>number</code> 进行赋值：<code>number</code> 的值是 <code>5</code></li><li>用 <code>if</code> 来赋值时，要保证每个分支返回的类型一样（事实上，这种说法不完全准确，见<a href="https://course.rs/appendix/expressions.html#if%E8%A1%A8%E8%BE%BE%E5%BC%8F">这里</a>），此处返回的 <code>5</code> 和 <code>6</code> 就是同一个类型，如果返回类型不一致就会报错</li></ul><h3 id="使用-else-if-来处理多重条件"><a href="#使用-else-if-来处理多重条件" class="headerlink" title="使用 else if 来处理多重条件"></a>使用 else if 来处理多重条件</h3><p>可以将 <code>else if</code> 与 <code>if</code>、<code>else</code> 组合在一起实现更复杂的条件分支判断：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-number">6</span>;<br><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 4&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 3&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 2&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出 <code>if</code> 语句块，最终本程序会匹配执行 <code>else if n % 3 == 0</code> 的分支，输出 <code>&quot;number is divisible by 3&quot;</code>。</p><blockquote><p>有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！</p></blockquote><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="for-循坏"><a href="#for-循坏" class="headerlink" title="for 循坏"></a>for 循坏</h3><p><code>for</code> 循环是 Rust 的大杀器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码循环输出一个从 1 到 5 的序列，简单粗暴，核心就在于 <code>for</code> 和 <code>in</code> 的联动，语义表达如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> 元素 <span class="hljs-keyword">in</span> 集合 &#123;<br>  <span class="hljs-comment">// 使用元素干一些你懂我不懂的事情</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，使用 <code>for</code> 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 <code>container</code> 的引用）。如果不使用引用的话，所有权会被转移（move）到 <code>for</code> 语句块中，后面就无法再使用这个集合了)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;container &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于实现了 <code>copy</code> 特征的数组（例如 [i32; 10]）而言， <code>for item in arr</code> 并不会把 <code>arr</code> 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 <code>arr</code> 。</p></blockquote><p>如果想在循环中，<strong>修改该元素</strong>，可以使用 <code>mut</code> 关键字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> collection &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结如下：</p><table><thead><tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr></thead><tbody><tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr><tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr><tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr></tbody></table><p>如果想在循环中<strong>获取元素的索引</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// `.iter()` 方法把 `a` 数组变成一个迭代器</span><br>    <span class="hljs-keyword">for</span> (i, v) <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>, i + <span class="hljs-number">1</span>, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>使用 <code>continue</code> 可以跳过当前当次的循环，开始下次的循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码对 1 到 3 的序列进行迭代，且跳过值为 2 时的循环，输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br>3<br></code></pre></td></tr></table></figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>使用 <code>break</code> 可以直接跳出当前整个循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码对 1 到 3 的序列进行迭代，在遇到值为 2 时的跳出整个循环，后面的循环不再执行，输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br></code></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>当条件为 <code>true</code> 时，执行循环；条件为 <code>false</code>，跳出循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">n</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> n &lt;= <span class="hljs-number">5</span>  &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>, n);<br>        n = n + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;我出来了！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该 <code>while</code> 循环，只有当 <code>n</code> 小于等于 <code>5</code> 时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从 <code>0</code> 开始，满足条件，进行循环，然后是 <code>1</code>，满足条件，进行循环，最终到 <code>6</code> 的时候，大于 5，不满足条件，跳出 <code>while</code> 循环，执行 <code>我出来了</code> 的打印，然后程序结束：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">0!<br>1!<br>2!<br>3!<br>4!<br>5!<br>我出来了！<br></code></pre></td></tr></table></figure><h3 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h3><p>对于循环而言，<code>loop</code> 循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景（虽然能用，但是在很多场景下， <code>for</code> 和 <code>while</code> 才是最优选择），因为 <code>loop</code> 就是一个简单的无限循环，你可以在内部实现逻辑通过 <code>break</code> 关键字来控制循环何时结束。</p><p>使用 <code>loop</code> 循环一定要打起精神，否则你会写出下面的跑满你一个 CPU 核心的疯子代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;again!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该循环会不停的在终端打印输出，直到你使用 `Ctrl-C` 结束程序：</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// ^Cagain!</span><br></code></pre></td></tr></table></figure><p>因此，当使用 <code>loop</code> 时，必不可少的伙伴是 <code>break</code> 关键字，它能让循环在满足某个条件时跳出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span> &#123;<br>        counter += <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码当 <code>counter</code> 递增到 <code>10</code> 时，就会通过 <code>break</code> 返回一个 <code>counter * 2</code> 的值，最后赋给 <code>result</code> 并打印出来。</p><p>这里有几点值得注意：</p><ul><li><strong>break 可以单独使用，也可以带一个返回值</strong>，有些类似 <code>return</code></li><li><strong>loop 是一个表达式</strong>，因此可以返回一个值</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 4 基础类型</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%204%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%204%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>Rust 使用一个相对传统的语法来创建整数（<code>1</code>，<code>2</code>，…）和浮点数（<code>1.0</code>，<code>1.1</code>，…）。整数、浮点数的运算和你在其它语言上见过的一致，都是通过常见的运算符来完成。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p><strong>整数</strong>是没有小数部分的数字。之前使用过的 <code>i32</code> 类型，表示有符号的 32 位整数（ <code>i</code> 是英文单词 <em>integer</em> 的首字母，与之相反的是 <code>u</code>，代表无符号 <code>unsigned</code> 类型）。下表显示了 Rust 中的内置的整数类型：</p><table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody><tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128 位</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>类型定义的形式统一为：<code>有无符号 + 类型大小(位数)</code>。<strong>无符号数</strong>表示数字只能取正数和 0，而<strong>有符号</strong>则表示数字可以取正数、负数还有 0。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以<a href="https://en.wikipedia.org/wiki/Two%27s_complement">补码</a>形式存储。</p><p>每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 <code>n</code> 是该定义形式的位长度。因此 <code>i8</code> 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 <code>u8</code> 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。</p><p>此外，<code>isize</code> 和 <code>usize</code> 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。</p><p>整形字面量可以用下表的形式书写：</p><table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody><tr><td>十进制</td><td><code>98_222</code></td></tr><tr><td>十六进制</td><td><code>0xff</code></td></tr><tr><td>八进制</td><td><code>0o77</code></td></tr><tr><td>二进制</td><td><code>0b1111_0000</code></td></tr><tr><td>字节 (仅限于 <code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><blockquote><ul><li>Rust 整型默认使用 <code>i32</code>，例如 <code>let i = 1</code>，那 <code>i</code> 就是 <code>i32</code> 类型，因此可以首选它，同时该类型也往往是性能最好的。</li><li><code>isize</code> 和 <code>usize</code> 的主要应用场景是用作集合的索引。</li></ul></blockquote><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p><p>下面是一个演示浮点数的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">2.0</span>; <span class="hljs-comment">// f64</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">f32</span> = <span class="hljs-number">3.0</span>; <span class="hljs-comment">// f32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>浮点数根据 <code>IEEE-754</code> 标准实现。<code>f32</code> 类型是单精度浮点型，<code>f64</code> 为双精度。</p><h4 id="浮点数陷阱"><a href="#浮点数陷阱" class="headerlink" title="浮点数陷阱"></a>浮点数陷阱</h4><p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p><ol><li><strong>浮点数往往是你想要数字的近似表达</strong></li><li><strong>浮点数在某些特性上是反直觉的</strong></li></ol><p>为了避免上面说的两个陷阱，需要遵守以下准则：</p><ul><li>避免在浮点数上测试相等性</li><li>当结果在数学上可能存在未定义时，需要格外的小心</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 断言0.1 + 0.2与0.3相等</span><br>  <span class="hljs-built_in">assert!</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能以为，这段代码没啥问题吧，实际上它会 _panic_（程序崩溃，抛出异常），因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。</p><p>那如果非要进行比较呢？可以考虑用这种方式 <code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code> ，具体小于多少，取决于你对精度的需求。</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>对于数学上未定义的结果，例如对负数取平方根 <code>-42.1.sqrt()</code> ，会产生一个特殊的结果：Rust 的浮点数类型使用 <code>NaN</code> (not a number) 来处理这些情况。</p><p>**所有跟 <code>NaN</code> 交互的操作，都会返回一个 <code>NaN</code>**，而且 <code>NaN</code> 不能用来比较，下面的代码会崩溃：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = (-<span class="hljs-number">42.0_f32</span>).<span class="hljs-title function_ invoke__">sqrt</span>();<br>  <span class="hljs-built_in">assert_eq!</span>(x, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>出于防御性编程的考虑，可以使用 <code>is_nan()</code> 等方法，可以用来判断一个数值是否是 <code>NaN</code> ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = (-<span class="hljs-number">42.0_f32</span>).<span class="hljs-title function_ invoke__">sqrt</span>();<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">is_nan</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;未定义的数学行为&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数值类型总结"><a href="#数值类型总结" class="headerlink" title="数值类型总结"></a>数值类型总结</h3><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p><ul><li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li><li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li><li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14</code> 的具体类型</li></ul><h2 id="字符类型-char"><a href="#字符类型-char" class="headerlink" title="字符类型(char)"></a>字符类型(char)</h2><p>Rust 的字符不仅仅是 <code>ASCII</code>，所有的 <code>Unicode</code> 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。</p><p>由于 <code>Unicode</code> 都是 4 个字节编码，因此字符类型也是占用 4 个字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-string">&#x27;中&#x27;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;字符&#x27;中&#x27;占用了&#123;&#125;字节的内存大小&quot;</span>,std::mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;x));<br>    <span class="hljs-comment">// 字符&#x27;中&#x27;占用了4字节的内存大小</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型(bool)"></a>布尔类型(bool)</h2><p>Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>，布尔值占用内存的大小为 <code>1</code> 个字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span>: <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 使用类型标注,显式指定f的类型</span><br><br>    <span class="hljs-keyword">if</span> f &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;这是段毫无意义的代码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用布尔类型的场景主要在于流程控制，例如上述代码的中的 <code>if</code> 就是其中之一。</p><h2 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h2><p>单元类型就是 <code>()</code>  ，唯一的值也是 <code>()</code> </p><p> <code>main</code> 函数就返回这个单元类型 <code>()</code>，你不能说 <code>main</code> 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：<code>发散函数( diverge function )</code>，顾名思义，无法收敛的函数。</p><p>例如常见的 <code>println!()</code> 的返回值也是单元类型 <code>()</code>。</p><p>再比如，你可以用 <code>()</code> 作为 <code>map</code> 的值，表示我们不关注具体的值，只关注 <code>key</code>。 这种用法和 Go 语言的 <em><strong>struct{}</strong></em> 类似，可以作为一个值用来占位，但是完全<strong>不占用</strong>任何内存。</p><h2 id="序列-Range"><a href="#序列-Range" class="headerlink" title="序列(Range)"></a>序列(Range)</h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5 ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,i);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最终程序输出:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br>2<br>3<br>4<br>5<br><br></code></pre></td></tr></table></figure><p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;a&#x27;</span>..=<span class="hljs-string">&#x27;z&#x27;</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,i);<br>    <span class="hljs-comment">// 输出 a～z 的字母</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型强制转换"><a href="#类型强制转换" class="headerlink" title="类型强制转换"></a>类型强制转换</h2><p>在Rust中，<code>as</code> 关键字用于在原始类型(如 <code>i64</code>、<code>f64</code>、<code>u64</code>、<code>char</code>等)之间进行类型转换。</p><blockquote><p>注意：<code>as</code>关键字并不适用于复合类型，比如<code>String</code>或其他用户定义的类型。对于复合类型的转换，通常需要使用其他方法或函数。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 3 函数</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%203%20%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%203%20%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="函数组成"><a href="#函数组成" class="headerlink" title="函数组成"></a>函数组成</h2><p>定义一个 <code>add</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(i: <span class="hljs-type">i32</span>, j: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>i + j<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字 <code>fn</code>，函数名 <code>add()</code>，参数 <code>i</code> 和 <code>j</code>，参数类型和返回值类型都是 <code>i32</code>，总之一切那么的普通，但是又那么的自信，直到你看到了下面这张图：</p><p><img src="/img/rust_fn.png" alt="函数组成"></p><h2 id="函数要点"><a href="#函数要点" class="headerlink" title="函数要点"></a>函数要点</h2><ul><li>函数名和变量名使用<a href="https://course.rs/practice/naming.html">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li><li>函数的位置可以<strong>随便放</strong>，Rust 不关心我们在哪里定义了函数，只要有定义即可</li><li><strong>每个函数参数</strong>都需要标注类型</li></ul><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>Rust 是静态类型语言，因此需要你为每一个函数参数都标识出它的具体类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(i: <span class="hljs-type">i32</span>, j) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>i + j<br>&#125;<br></code></pre></td></tr></table></figure><p>错误如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">error: expected one of `:`, `@`, or `|`, found `)`<br>  --&gt; src/main.rs:10:17<br>   |<br>10 | fn add(i: i32, j) -&gt; i32 &#123;<br>   |                 ^ expected one of `:`, `@`, or `|`<br>   |<br>   = note: anonymous parameters are removed <span class="hljs-keyword">in</span> the 2018 edition (see RFC 1685)<br><span class="hljs-built_in">help</span>: <span class="hljs-keyword">if</span> this is a parameter name, give it a <span class="hljs-built_in">type</span><br>   |<br>10 | fn add(i: i32, j: TypeName) -&gt; i32 &#123;<br>   |                 ++++++++++<br><span class="hljs-built_in">help</span>: <span class="hljs-keyword">if</span> this is a <span class="hljs-built_in">type</span>, explicitly ignore the parameter name<br>   |<br>10 | fn add(i: i32, _: j) -&gt; i32 &#123;<br>   |   <br></code></pre></td></tr></table></figure><h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 <code>return</code> 提前返回</p><p>可以简单记住以下两种形态：</p><ul><li><code>return</code></li><li>没有<code>return</code> + 没有分号</li></ul><p>以下这段代码同时使用 <strong><code>return</code></strong> 和<strong>表达式</strong>作为返回值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_or_minus</span>(x:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-keyword">return</span> x - <span class="hljs-number">5</span><br>    &#125;<br>    x + <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">plus_or_minus</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>2 个重点：</p><ol><li><code>let x = plus_or_minus(5)</code>，说明我们用一个函数的返回值来初始化 <code>x</code> 变量，因此侧面说明了在 Rust 中函数也是表达式，这种写法等同于 <code>let x = 5 + 5;</code></li><li><code>x + 5</code> 没有分号，因为它是一条表达式</li></ol><h2 id="Rust-中的特殊返回类型"><a href="#Rust-中的特殊返回类型" class="headerlink" title="Rust 中的特殊返回类型"></a>Rust 中的特殊返回类型</h2><h3 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值()"></a>无返回值()</h3><ul><li>函数没有返回值，那么返回一个 <code>()</code></li><li>通过 <code>;</code> 结尾的语句返回一个 <code>()</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 隐式返回一个 ()</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(i: <span class="hljs-type">i32</span>)&#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);  <br>&#125;<br><br><span class="hljs-comment">// 显式的返回了 ()</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(i:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span>() &#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="永不返回的发散函数"><a href="#永不返回的发散函数" class="headerlink" title="永不返回的发散函数 !"></a>永不返回的发散函数 <code>!</code></h3><p>当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dead_end</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;你已经到了穷途末路，崩溃吧！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">forever</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">forever_panic</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 2 变量和可变类型</title>
    <link href="/2024/10/31/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/10/31/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a>变量可变性</h2><ul><li>Rust 的变量在默认情况下是<strong>不可变的</strong></li><li>通过 <code>mut</code> 关键字让变量变为<strong>可变的</strong></li></ul><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 声明不可变变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>x = <span class="hljs-number">6</span>; <span class="hljs-comment">// 此处会报错，error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br><br><span class="hljs-comment">// 声明可变变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span> = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>y = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量-constant"><a href="#常量-constant" class="headerlink" title="常量(constant)"></a>常量(constant)</h2><ul><li>常量不允许使用<code>mut</code></li><li><strong>常量不仅仅默认不可变，而且自始至终不可变</strong></li><li>常量使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明</li><li>必须显示指定数据类型</li><li>Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词</li><li>必须使用常量表达式进行赋值，即必须是编译期能计算出的值</li><li>常量不支持重定义（遮蔽），这和变量是不同的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 常量声明</span><br><span class="hljs-keyword">const</span> MAX_COUNT: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is: &#123;&#125;&quot;</span>, MAX_COUNT);<br></code></pre></td></tr></table></figure><h3 id="不可变变量和常量的区别？"><a href="#不可变变量和常量的区别？" class="headerlink" title="不可变变量和常量的区别？"></a>不可变变量和常量的区别？</h3><ul><li>常量使用 <code>const</code> 进行声明，不可变变量使用 <code>let</code> 进行声明 。</li><li>常量在编译期就确定了值，不能在运行时改变。不可变变量直到运行期来能确定下来。</li><li>常量不可以修改，不可变变量可以通过 <code>shadowing</code> 来修改。</li><li>常量必须声明类型，不可变变量不需要声明类型</li><li>常量必须使用大写字母，不可变变量不需要</li></ul><h2 id="静态变量-Static"><a href="#静态变量-Static" class="headerlink" title="静态变量 (Static)"></a>静态变量 (Static)</h2><ul><li>静态变量使用 <code>static</code> 关键字进行声明并在编译时分配内存，并且在程序运行期间一直存在</li><li>静态变量可以在整个程序中共享，并且可以在多个线程之间共享。</li><li>静态变量的值在程序运行期间不会改变，因此它们通常用于存储程序的全局状态</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 声明一个静态变量</span><br><span class="hljs-keyword">static</span> NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 声明一个可变的静态变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER2: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of NUM is: &#123;&#125;&quot;</span>, NUM); <span class="hljs-comment">// The value of NUM is: 5</span><br><br><span class="hljs-title function_ invoke__">change_counter_static</span>();<br><span class="hljs-title function_ invoke__">change_counter_static_unsafe</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change_counter_static</span>() &#123;<br>COUNTER += <span class="hljs-number">1</span>; <span class="hljs-comment">// error[E0133]: use of mutable static is unsafe and requires unsafe function or block</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of COUNTER is: &#123;&#125;&quot;</span>, COUNTER);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change_counter_static_unsafe</span>() &#123;<br><span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-comment">// 需要用 unsafe 包裹才生效</span><br>COUNTER += <span class="hljs-number">1</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of COUNTER is: &#123;&#125;&quot;</span>, COUNTER);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与常量的相似点"><a href="#与常量的相似点" class="headerlink" title="与常量的相似点"></a>与常量的相似点</h3><ul><li>名称都要求使用大写，否则会报 Warning</li><li>都必须明确指定类型</li><li>都要求必须使用常量表达式进行赋值，即必须是编译期能计算出的值</li><li>都不支持重定义(遮蔽)，这和变量是不同的</li></ul><h3 id="与常量的区别"><a href="#与常量的区别" class="headerlink" title="与常量的区别"></a>与常量的区别</h3><ul><li>定义关键字: 静态变量使用 <code>static</code>，常量使用 <code>const</code></li><li>常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址。</li><li>常量不可变，而静态变量和普通变量一样，默认不可变但可以通过 <code>mut</code> 关键字定义为可变</li></ul><h2 id="变量遮蔽-variable-shadowing"><a href="#变量遮蔽-variable-shadowing" class="headerlink" title="变量遮蔽(variable shadowing)"></a>变量遮蔽(variable shadowing)</h2><p>变量绑定有一个作用域(scope)，它被限定只在一个代码块(block)中生存(live)。 代码块是一个被 {}包围的语句集合。另外也允许变量遮蔽(variable shadowing)</p><p>Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// 在main函数的作用域内对之前的x进行遮蔽</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x + <span class="hljs-number">1</span>;<br><br>    &#123;<br>        <span class="hljs-comment">// 在当前的花括号作用域内，对之前的x进行遮蔽</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x * <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>将输出以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">The value of x <span class="hljs-keyword">in</span> the inner scope is: 12<br>The value of x is: 6<br></code></pre></td></tr></table></figure><p>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</p><p><strong>变量遮蔽的用处</strong>在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 1 环境搭建</title>
    <link href="/2024/10/29/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%201%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/10/29/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%201%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-Rust-环境"><a href="#安装-Rust-环境" class="headerlink" title="安装 Rust 环境"></a>安装 <strong>Rust</strong> 环境</h2><h3 id="安装-rustup"><a href="#安装-rustup" class="headerlink" title="安装 rustup"></a>安装 <code>rustup</code></h3><p>打开终端并输入下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh<br></code></pre></td></tr></table></figure><p>如果安装成功，将出现下面这行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Rust is installed now. Great!<br></code></pre></td></tr></table></figure><p><strong>可能出现的问题</strong></p><ul><li>下载源速度很慢，解决方案：1. 选择镜像站 2. 使用代理&#x2F;VPN等</li></ul><h3 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h3><p>检查是否正确安装了 Rust，可打开终端并输入下面这行，此时能看到最新发布的稳定版本的版本号、提交哈希值和提交日期：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustc -V<br>rustc 1.81.0 (eeb90cda1 2024-09-04)<br><br>cargo -V<br>cargo 1.81.0 (2dbb1af80 2024-08-20)<br></code></pre></td></tr></table></figure><h3 id="rustup常用命令"><a href="#rustup常用命令" class="headerlink" title="rustup常用命令"></a><code>rustup</code>常用命令</h3><ul><li>更新：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup update<br></code></pre></td></tr></table></figure></li><li>卸载<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup self uninstall<br></code></pre></td></tr></table></figure></li><li>本地文档，让浏览器打开本地文档<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup doc<br></code></pre></td></tr></table></figure></li></ul><h2 id="VS-Code-插件推荐"><a href="#VS-Code-插件推荐" class="headerlink" title="VS Code 插件推荐"></a>VS Code 插件推荐</h2><ol><li><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a>，社区驱动的</li><li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Even Better TOML</a>，支持 <code>.toml</code> 文件的完整特性</li><li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Dependi</a>，依赖管理工具，代替<code>crates</code></li></ol><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><h3 id="编写-Rust-代码"><a href="#编写-Rust-代码" class="headerlink" title="编写 Rust 代码"></a>编写 Rust 代码</h3><p>新建一个源文件，Rust 源文件总是以 <code>.rs</code> 扩展名结尾。如果文件名包含多个单词，那么按照命名习惯，应当使用下划线来分隔单词。例如命名为 <code>hello_world.rs</code>，而不是 <code>helloworld.rs</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> hello_world<br><span class="hljs-built_in">cd</span> hello_world<br><span class="hljs-built_in">touch</span> main.rs<br></code></pre></td></tr></table></figure><p>打开刚创建的<code>main.rs</code> 文件，输入示例 1-1 代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在运行 Rust 程序之前，必须先使用 Rust 编译器编译它，即输入 <code>rustc</code> 命令并传入源文件名称，如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustc main.rs<br></code></pre></td></tr></table></figure><p>编译成功后，Rust会输出一个二进制的可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span><br>main main.rs<br></code></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>Rust 是一种 <strong>预编译静态类型(ahead-of-time compiled)语言</strong>，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">./main<br>Hello, World!<br></code></pre></td></tr></table></figure><h2 id="认识Cargo"><a href="#认识Cargo" class="headerlink" title="认识Cargo"></a>认识Cargo</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo new hello_cargo<br><span class="hljs-built_in">cd</span> hello_cargo<br></code></pre></td></tr></table></figure><p>初始化的项目结构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tree<br>.<br>├── .git<br>├── .gitignore<br>├── Cargo.toml<br>└── src<br>    └── main.rs<br><br></code></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>有两种方式可以运行项目：</p><ol><li><p><code>cargo run</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ cargo run<br>   Compiling hello_cargo v0.1.0 (/Users/vic9527/Documents/rust/hello_cargo)<br>    Finished `dev` profile [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.29s<br>     Running `target/debug/hello_cargo`<br>Hello, Cargo!<br></code></pre></td></tr></table></figure></li><li><p>手动编译和运行项目<br>编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ cargo build<br>    Finished `dev` profile [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.02s<br>    <br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ ./target/debug/hello_cargo<br>Hello, Cargo!<br></code></pre></td></tr></table></figure></li></ol><h3 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h3><p>当项目最终准备好发布时，可以使用 <code>cargo build --release</code> 来优化编译项目</p><ul><li><p><code>debug</code>模式，<strong>代码的编译速度会非常快</strong>，但是<strong>运行速度就慢了</strong>。原因是，在 <code>debug</code> 模式下，Rust 编译器不会做任何的优化，只为了尽快的编译完成，让你的开发流程更加顺畅。</p></li><li><p><code>release</code>模式，<strong>高性能模式</strong>，为用户构建最终程序</p><ul><li><code>cargo run --release</code></li><li><code>cargo build --release</code></li></ul></li></ul><h3 id="Cargo-toml-和-Cargo-lock"><a href="#Cargo-toml-和-Cargo-lock" class="headerlink" title="Cargo.toml 和 Cargo.lock"></a>Cargo.toml 和 Cargo.lock</h3><p><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 是 <code>cargo</code> 的核心文件，它的所有活动均基于此二者。</p><ul><li><p><code>Cargo.toml</code> 是 <code>cargo</code> 特有的<strong>项目数据描述文件</strong>。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 <code>Cargo.toml</code>。</p></li><li><p><code>Cargo.lock</code> 文件是 <code>cargo</code> 工具根据同一项目的 <code>toml</code> 文件生成的<strong>项目依赖详细清单</strong>，因此我们一般不用修改它，只需要对着 <code>Cargo.toml</code> 文件撸就行了。</p><blockquote><p>什么情况下该把 <code>Cargo.lock</code> 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 <code>Cargo.lock</code>，如果是一个依赖库项目，那么请把它添加到 <code>.gitignore</code> 中。</p></blockquote></li></ul><h3 id="package-配置段落"><a href="#package-配置段落" class="headerlink" title="package 配置段落"></a>package 配置段落</h3><p><code>package</code> 中记录了项目的描述信息，典型的如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;hello_cargo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>name</code> 字段定义了项目名称</li><li><code>version</code> 字段定义当前版本，新项目默认是 <code>0.1.0</code></li><li><code>edition</code> 字段定义了我们使用的 Rust 大版本</li></ul><h3 id="定义项目依赖"><a href="#定义项目依赖" class="headerlink" title="定义项目依赖"></a>定义项目依赖</h3><p>使用 <code>cargo</code> 工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。</p><p>在 <code>Cargo.toml</code> 中，主要通过各种依赖段落来描述该项目的各种依赖项：</p><ul><li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li><li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li><li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li></ul><p>这三种形式具体写法如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">rand</span> = <span class="hljs-string">&quot;0.3&quot;</span><br><span class="hljs-attr">hammer</span> = &#123; version = <span class="hljs-string">&quot;0.5.0&quot;</span>&#125;<br><span class="hljs-attr">color</span> = &#123; git = <span class="hljs-string">&quot;https://github.com/bjz/color-rs&quot;</span> &#125;<br><span class="hljs-attr">geometry</span> = &#123; path = <span class="hljs-string">&quot;crates/geometry&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="下载依赖太慢"><a href="#下载依赖太慢" class="headerlink" title="下载依赖太慢"></a>下载依赖太慢</h2><ol><li><p>科技上网，不赘述</p></li><li><p>修改下载镜像</p><p> 修改配置文件，文件位置<code>$HOME/.cargo/config.toml</code></p></li></ol><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment"># 选择的镜像源</span><br><span class="hljs-comment"># 喜欢哪个用哪个吧，没有注释掉的那个就是你选择的</span><br><span class="hljs-comment">#replace-with = &#x27;ustc&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;tuna&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;sjtu&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;rustcc&#x27;</span><br><span class="hljs-attr">replace-with</span> = <span class="hljs-string">&#x27;aliyun&#x27;</span><br><br><span class="hljs-comment"># 源码地址</span><br><span class="hljs-section">[source.crates-io]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 镜像地址</span><br><span class="hljs-comment"># 清华大学</span><br><span class="hljs-section">[source.tuna]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><br><span class="hljs-comment"># 中国科学技术大学</span><br><span class="hljs-section">[source.ustc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 上海交通大学</span><br><span class="hljs-section">[source.sjtu]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><br><span class="hljs-comment"># rustcc社区</span><br><span class="hljs-section">[source.rustcc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 阿里云</span><br><span class="hljs-section">[source.aliyun]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://code.aliyun.com/rustcc/crates.io-index&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
