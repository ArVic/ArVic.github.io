<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust 进阶 - Day 28 多线程并发编程</title>
    <link href="/2024/12/10/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2028%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/12/10/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2028%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p><code>Erlang</code> 之父 <a href="https://en.wikipedia.org/wiki/Joe_Armstrong_(programmer)"><code>Joe Armstrong</code></a>（伟大的异步编程先驱，开创一个时代的殿堂级计算机科学家，我还犹记得当年刚学到 <code>Erlang</code> 时的震撼，respect！）用一张 5 岁小孩都能看懂的图片解释了并发与并行的区别：</p><p><img src="/img/rust_concurrent.png"></p><p>上图很直观的体现了：</p><ul><li><strong>并发(Concurrent)</strong> 是多个队列使用同一个咖啡机，然后两个队列轮换着使用（未必是 1:1 轮换，也可能是其它轮换规则），最终每个人都能接到咖啡</li><li><strong>并行(Parallel)</strong> 是每个队列都拥有一个咖啡机，最终也是每个人都能接到咖啡，但是效率更高，因为同时可以有两个人在接咖啡</li></ul><p>结论：<strong>并发和并行都是对“多任务”处理的描述，其中并发是轮流处理，而并行是同时处理</strong>。</p><h3 id="编程语言的并发模型"><a href="#编程语言的并发模型" class="headerlink" title="编程语言的并发模型"></a>编程语言的并发模型</h3><ul><li>由于操作系统提供了创建线程的 API，因此部分语言会直接调用该 API 来创建线程，因此最终程序内的线程数和该程序占用的操作系统线程数相等，一般称之为<strong>1:1 线程模型</strong>，例如 Rust。</li><li>还有些语言在内部实现了自己的线程模型（绿色线程、协程），程序内部的 M 个线程最后会以某种映射方式使用 N 个操作系统线程去运行，因此称之为<strong>M:N 线程模型</strong>，其中 M 和 N 并没有特定的彼此限制关系。一个典型的代表就是 Go 语言。</li><li>还有些语言使用了 Actor 模型，基于消息传递进行并发，例如 Erlang 语言。</li></ul><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li>在大部分0S里,代码运行在进程(process)中,OS同时管理里多个进程</li><li>在你的程序里,各独立部分可以同时运行，运行这些独立部分的就是线程(thread)</li><li>多线程运行:<ul><li>提升性能表现</li><li>增加复杂性:无法保障各线程的执行顺序</li></ul></li></ul><h3 id="多线程编程的风险"><a href="#多线程编程的风险" class="headerlink" title="多线程编程的风险"></a>多线程编程的风险</h3><ul><li>竞态条件(race conditions)，多个线程以非一致性的顺序同时访问数据资源</li><li>死锁(deadlocks)，两个线程都想使用某个资源，但是又都在等待对方释放资源后才能使用，结果最终都无法继续执行</li><li>一些因为多线程导致的很隐晦的 BUG，难以复现和解决</li></ul><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>使用 <code>thread::spawn</code> 可以创建线程：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有几点值得注意：</p><ul><li>线程内部的代码使用闭包来执行</li><li><code>main</code> 线程一旦结束，程序就立刻结束，因此需要保持它的存活，直到其它子线程完成自己的任务</li><li><code>thread::sleep</code> 会让当前线程休眠指定的时间，随后其它线程会被调度运行（上一节并发与并行中有简单介绍过），因此就算你的电脑只有一个 CPU 核心，该程序也会表现的如同多 CPU 核心一般，这就是并发！</li></ul><h3 id="等待子线程的结束"><a href="#等待子线程的结束" class="headerlink" title="等待子线程的结束"></a>等待子线程的结束</h3><p>上面的代码你不但可能无法让子线程从 1 顺序打印到 10，而且可能打印的数字会变少，因为主线程会提前结束，导致子线程也随之结束，更过分的是，如果当前系统繁忙，甚至该子线程还没被创建，主线程就已经结束了！</p><p>因此我们需要一个方法，让主线程安全、可靠地等所有子线程完成任务后，再 kill self：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the spawned thread!&quot;</span>, i);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hi number &#123;&#125; from the main thread!&quot;</span>, i);<br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用 <code>handle.join</code>，可以让当前线程阻塞，直到它等待的子线程的结束，在上面代码中，由于 <code>main</code> 线程会被阻塞，因此它直到子线程结束后才会输出自己的 <code>1..5</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">hi number 1 from the spawned thread!<br>hi number 2 from the spawned thread!<br>hi number 3 from the spawned thread!<br>hi number 4 from the spawned thread!<br>hi number 1 from the main thread!<br>hi number 2 from the main thread!<br>hi number 3 from the main thread!<br>hi number 4 from the main thread!<br></code></pre></td></tr></table></figure><h3 id="在线程闭包中使用-move"><a href="#在线程闭包中使用-move" class="headerlink" title="在线程闭包中使用 move"></a>在线程闭包中使用 move</h3><p> <code>move</code> 关键字在闭包中的使用可以让该闭包拿走环境中某个值的所有权，同样地，你可以使用 <code>move</code> 来将所有权从一个线程转移到另外一个线程。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Here&#x27;s a vector: &#123;:?&#125;&quot;</span>, v);<br>    &#125;);<br><br>    handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 下面代码会报错borrow of moved value: `v`</span><br>    <span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;,v);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ul><li>一种很流行且能保证安全并发的技术就是：消息传递线程(或 <code>Actor</code>)通过彼此发送消息(数据)来进行通信</li><li>Go 语言的名言:不要用共享内存来通信,要用通信来共与享内存。</li><li><code>Rust:Channel</code>（标准库提供）</li></ul><h4 id="消息通道"><a href="#消息通道" class="headerlink" title="消息通道"></a>消息通道</h4><p>Rust 是在标准库里提供了消息通道(<code>channel</code>)</p><ul><li><code>channel</code> 包含：发送端、接收端</li><li>调用发送端的方法,发送数据</li><li>接收端会检查和接收到达的数据</li><li>如果发送端、接收端中任意一端被丢弃了,那么 <code>channel</code> 就优”关闭”了</li></ul><h4 id="创建-channel"><a href="#创建-channel" class="headerlink" title="创建 channel"></a>创建 channel</h4><ul><li><p>使用 <code>mpsc::channel</code> 函数来创建 <code>channel</code></p><ul><li><code>mpsc</code> 表示 multiple producer, single consumer(多个生产者、一个消费者)</li><li>返回一个 <code>tuple</code> (元组):里面元素分别是发送端、接收端</li></ul></li><li><p>使用 <code>mpsc::sync_channel</code> 来创建带缓冲区的 <code>channel</code></p><ul><li>入参为缓冲区大小，当缓冲区塞满时进行阻塞</li></ul></li></ul><p>单发送者、单接收者的简单例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个消息通道, 返回一个元组：(发送者，接收者)</span><br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-comment">// 创建线程，并发送消息</span><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-comment">// 发送一个数字1, send方法返回Result&lt;T,E&gt;，通过unwrap进行快速错误处理</span><br>        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>        <span class="hljs-comment">// 下面代码将报错，因为编译器自动推导出通道传递的值是i32类型，那么Option&lt;i32&gt;类型将产生不匹配错误</span><br>        <span class="hljs-comment">// tx.send(Some(1)).unwrap()</span><br>    &#125;);<br><br>    <span class="hljs-comment">// 在主线程中接收子线程发送的消息并输出</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;receive &#123;&#125;&quot;</span>, rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码并不复杂，但仍有几点需要注意：</p><ul><li><code>tx</code>,<code>rx</code>对应发送者和接收者，它们的类型由编译器自动推导: <code>tx.send(1)</code>发送了整数，因此它们分别是<code>mpsc::Sender&lt;i32&gt;</code>和<code>mpsc::Receiver&lt;i32&gt;</code>类型，需要注意，由于内部是泛型实现，一旦类型被推导确定，该通道就只能传递对应类型的值, 例如此例中非<code>i32</code>类型的值将导致编译错误</li><li>接收消息的操作<code>rx.recv()</code>会阻塞当前线程，直到读取到值，或者通道被关闭</li><li>需要使用<code>move</code>将<code>tx</code>的所有权转移到子线程的闭包中</li></ul><h5 id="方法小结"><a href="#方法小结" class="headerlink" title="方法小结"></a>方法小结</h5><ul><li><p>发送端 <code>send</code> 方法</p><ul><li>参数：要发送的数据</li><li>返回：<code>Result&lt;T,E&gt;</code><ul><li>有可能返回一个错误（例如接收者被<code>drop</code>导致了发送的值不会被任何人接收）</li></ul></li></ul></li><li><p>接收端的方法</p><ul><li><code>recv</code>方法：阻塞当前线程，直到读取到值，或者通道被关闭。<ul><li>一旦有值收到，返回 <code>Result&lt;T,E&gt;</code></li><li>当发送端关闭，就会收到一个错误</li></ul></li><li><code>try_recv</code>方法：不会阻塞线程<ul><li>立即返回 <code>Result&lt;T,E&gt;</code>：<ul><li>有数据达到：返回 <code>Ok</code>，里面包含数据</li><li>否则，返回错误</li></ul></li><li>通常会使用循环调用来检查结果</li></ul></li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;receive &#123;:?&#125;&quot;</span>, rx.<span class="hljs-title function_ invoke__">try_recv</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-for-进行循环接收"><a href="#使用-for-进行循环接收" class="headerlink" title="使用 for 进行循环接收"></a>使用 for 进行循环接收</h4><p>下面来看看如何连续接收通道中的值:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">vals</span> = <span class="hljs-built_in">vec!</span>[<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;from&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;the&quot;</span>),<br>            <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;thread&quot;</span>),<br>        ];<br><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> vals &#123;<br>            tx.<span class="hljs-title function_ invoke__">send</span>(val).<span class="hljs-title function_ invoke__">unwrap</span>();<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码中，主线程和子线程是并发运行的，子线程在不停的<strong>发送消息 -&gt; 休眠 1 秒</strong>，与此同时，主线程使用<code>for</code>循环<strong>阻塞</strong>的从<code>rx</code><strong>迭代器</strong>中接收消息，当子线程运行完成时，发送者<code>tx</code>会随之被<code>drop</code>，此时<code>for</code>循环将被终止，最终<code>main</code>线程成功结束。</p><h4 id="使用多发送者"><a href="#使用多发送者" class="headerlink" title="使用多发送者"></a>使用多发送者</h4><p>由于子线程会拿走发送者的所有权，因此我们必须对发送者进行克隆，然后让每个线程拿走它的一份拷贝:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::mpsc;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tx1</span> = tx.<span class="hljs-title function_ invoke__">clone</span>();<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi from raw tx&quot;</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        tx1.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hi from cloned tx&quot;</span>)).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">received</span> <span class="hljs-keyword">in</span> rx &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got: &#123;&#125;&quot;</span>, received);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码并无太大区别，就多了一个对发送者的克隆<code>let tx1 = tx.clone();</code>，然后一个子线程拿走<code>tx</code>的所有权，另一个子线程拿走<code>tx1</code>的所有权，皆大欢喜。</p><p>但是有几点需要注意:</p><ul><li>需要所有的发送者都被<code>drop</code>掉后，接收者<code>rx</code>才会收到错误，进而跳出<code>for</code>循环，最终结束主线程</li><li>这里虽然用了<code>clone</code>但是并不会影响性能，因为它并不在热点代码路径中，仅仅会被执行一次</li><li>由于两个子线程谁先创建完成是未知的，因此哪条消息先发送也是未知的，最终主线程的输出顺序也不确定</li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><h4 id="该如何选择"><a href="#该如何选择" class="headerlink" title="该如何选择"></a>该如何选择</h4><p>共享内存可以说是同步的灵魂，因为消息传递的底层实际上也是通过共享内存来实现，两者的区别如下：</p><ul><li>共享内存相对消息传递能节省多次内存拷贝的成本</li><li>共享内存的实现简洁的多</li><li>共享内存的锁竞争更多</li></ul><p>消息传递适用的场景很多，我们下面列出了几个主要的使用场景:</p><ul><li>需要可靠和简单的(简单不等于简洁)实现时</li><li>需要模拟现实世界，例如用消息去通知某个目标执行相应的操作时</li><li>需要一个任务处理流水线(管道)时，等等</li></ul><p>而使用共享内存(并发原语)的场景往往就比较简单粗暴：</p><ul><li>需要简洁的实现以及更高的性能时。</li></ul><p>总结：</p><ul><li>消息传递类似一个单所有权的系统<ul><li>一个值同时只能有一个所有者，如果另一个线程需要该值的所有权，需要将所有权通过消息传递进行转移。</li></ul></li><li>共享内存类似于一个多所有权的系统<ul><li>多个线程可以同时访问同一个值。</li></ul></li></ul><h4 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h4><p>互斥锁<code>Mutex</code>(mutual exclusion 的缩写)。</p><p><code>Mutex</code>让多个线程并发的访问同一个值变成了排队访问：同一时间，只允许一个线程<code>A</code>访问该值，其它线程需要等待<code>A</code>访问完成后才能继续。</p><ul><li>通过 <code>Mutex::new(数据)</code> 来创建 <code>Mutex&lt;T&gt;</code><ul><li><code>Mutex&lt;T&gt;</code> 是一个智能指针</li></ul></li><li>访问数据前，通过 <code>lock</code> 方法来获取锁<ul><li><strong>阻塞当前线程，直到获取到锁</strong></li><li><code>lock</code> 可能会失败，返回一个错误</li><li>返回的是 <code>MutexGuard&lt;T&gt;</code>(智能指针，实现了 <code>Deref</code> 和 <code>Drop</code> )<ul><li><code>Deref</code>特征，会被自动解引用后获得一个引用类型，该引用指向<code>Mutex</code>内部的数据</li><li><code>Drop</code>特征，在超出作用域后，自动释放锁，以便其它线程能继续获取锁</li></ul></li></ul></li></ul><h5 id="单线程中使用Mutex"><a href="#单线程中使用Mutex" class="headerlink" title="单线程中使用Mutex"></a>单线程中使用Mutex</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 使用`Mutex`结构体的关联函数创建新的互斥锁实例</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><br>    &#123;<br>        <span class="hljs-comment">// 获取锁，然后deref为`m`的引用</span><br>        <span class="hljs-comment">// lock返回的是Result</span><br>        <span class="hljs-comment">// `m.lock()`返回一个智能指针`MutexGuard&lt;T&gt;`，实现了`Deref` 和 `Drop` 特征</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        *num = <span class="hljs-number">6</span>;<br>        <span class="hljs-comment">// 锁自动被drop</span><br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;m = &#123;:?&#125;&quot;</span>, m);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="多线程中使用-Mutex"><a href="#多线程中使用-Mutex" class="headerlink" title="多线程中使用 Mutex"></a>多线程中使用 Mutex</h5><p>在多线程环境中使用多线程安全的 <code>Arc&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;<br><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 通过`Arc`实现`Mutex`的多所有权</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-built_in">vec!</span>[];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);<br>        <span class="hljs-comment">// 创建子线程，并将`Mutex`的所有权拷贝传入到子线程中</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>            *num += <span class="hljs-number">1</span>;<br>        &#125;);<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br>    <br><span class="hljs-comment">// 等待所有子线程完成</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br><br><span class="hljs-comment">// 输出最终的计数结果</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Result: &#123;&#125;&quot;</span>, *counter.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>    <span class="hljs-comment">// 输出结果：Result: 10</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用-Mutex-的规则"><a href="#使用-Mutex-的规则" class="headerlink" title="使用 Mutex 的规则"></a>使用 Mutex 的规则</h5><ul><li>在使用数据前必须先获取锁</li><li>在数据使用完成后，必须<strong>及时</strong>的释放锁，比如文章开头的例子，使用内部语句块的目的就是为了及时的释放锁</li></ul><h2 id="Atomic-原子类型"><a href="#Atomic-原子类型" class="headerlink" title="Atomic 原子类型"></a>Atomic 原子类型</h2><ul><li>原子操作是通过指令提供的支持</li><li>性能相比锁和消息传递会好很多</li><li>原子类型不需要开发者处理加锁和释放锁的问题</li><li>支持修改，读取等操作，还具备较高的并发性能</li><li>原子类型是无锁类型</li><li>原子类型内部使用了<code>CAS</code>循环</li></ul><h3 id="多线程中使用-Atomic"><a href="#多线程中使用-Atomic" class="headerlink" title="多线程中使用 Atomic"></a>多线程中使用 Atomic</h3><p>在多线程环境中要使用<code>Atomic</code>需要配合<code>Arc</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Arc;<br><span class="hljs-keyword">use</span> std::sync::atomic::&#123;AtomicUsize, Ordering&#125;;<br><span class="hljs-keyword">use</span> std::&#123;hint, thread&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">spinlock</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">spinlock_clone</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;spinlock);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">thread</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span>|| &#123;<br>        spinlock_clone.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">0</span>, Ordering::SeqCst);<br>    &#125;);<br><br>    <span class="hljs-comment">// 等待其它线程释放锁</span><br>    <span class="hljs-keyword">while</span> spinlock.<span class="hljs-title function_ invoke__">load</span>(Ordering::SeqCst) != <span class="hljs-number">0</span> &#123;<br>        hint::<span class="hljs-title function_ invoke__">spin_loop</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Err</span>(panic) = thread.<span class="hljs-title function_ invoke__">join</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Thread had an error: &#123;:?&#125;&quot;</span>, panic);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Atomic-的应用场景"><a href="#Atomic-的应用场景" class="headerlink" title="Atomic 的应用场景"></a>Atomic 的应用场景</h3><p>事实上，<code>Atomic</code>虽然对于用户不太常用，但是对于高性能库的开发者、标准库开发者都非常常用，它是并发原语的基石，除此之外，还有一些场景适用：</p><ul><li>无锁(lock free)数据结构</li><li>全局变量，例如全局自增 ID, 在后续章节会介绍</li><li>跨线程计数器，例如可以用于统计指标</li></ul><p>以上列出的只是<code>Atomic</code>适用的部分场景，具体场景需要大家未来根据自己的需求进行权衡选择。</p><h2 id="基于-Send-和-Sync-的线程安全"><a href="#基于-Send-和-Sync-的线程安全" class="headerlink" title="基于 Send 和 Sync 的线程安全"></a>基于 Send 和 Sync 的线程安全</h2><p><code>Send</code>和<code>Sync</code>是 Rust 安全并发的重中之重，但是实际上它们只是标记特征(marker trait，该特征未定义任何行为，因此非常适合用于标记), 来看看它们的作用：</p><ul><li>实现<code>Send</code>的类型可以在线程间安全的传递其所有权</li><li>实现<code>Sync</code>的类型可以在线程间安全的共享(通过引用)</li></ul><p>这里还有一个潜在的依赖：一个类型要在线程间安全的共享的前提是，指向它的引用必须能在线程间传递。因为如果引用都不能被传递，我们就无法在多个线程间使用引用去访问同一个数据了。</p><p>由上可知，**若类型 T 的引用<code>&amp;T</code>是<code>Send</code>，则<code>T</code>是<code>Sync</code>**。</p><h3 id="为裸指针实现Send-和-Sync"><a href="#为裸指针实现Send-和-Sync" class="headerlink" title="为裸指针实现Send 和 Sync"></a>为裸指针实现<code>Send</code> 和 <code>Sync</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::sync::Arc;<br><span class="hljs-keyword">use</span> std::sync::Mutex;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>(*<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>);<br><span class="hljs-comment">// `Send`和`Sync`是`unsafe`特征，实现时需要用`unsafe`代码块包裹。</span><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span> &#123;&#125;<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span> &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;<span class="hljs-title function_ invoke__">MyBox</span>(<span class="hljs-number">5</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">u8</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(b));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">_v1</span> =  v.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br><br>    t.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>实现<code>Send</code>的类型可以在线程间安全的传递其所有权, 实现<code>Sync</code>的类型可以在线程间安全的共享(通过引用)</li><li>绝大部分类型都实现了<code>Send</code>和<code>Sync</code>，常见的未实现的有：裸指针、<code>Cell</code>、<code>RefCell</code>、<code>Rc</code> 等</li><li>可以为自定义类型实现<code>Send</code>和<code>Sync</code>，但是需要<code>unsafe</code>代码块</li><li>可以为部分 Rust 中的类型实现<code>Send</code>、<code>Sync</code>，但是需要使用<code>newtype</code>，例如文中的裸指针例子</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 进阶 - Day 27 Marco 宏</title>
    <link href="/2024/12/09/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2027%20Marco%20%E5%AE%8F/"/>
    <url>/2024/12/09/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2027%20Marco%20%E5%AE%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Rust-宏介绍"><a href="#Rust-宏介绍" class="headerlink" title="Rust 宏介绍"></a>Rust 宏介绍</h2><p>在 Rust 中宏分为两大类：<strong>声明式宏( <em>declarative macros</em> )</strong> <code>macro_rules!</code> 和三种<strong>过程宏( <em>procedural macros</em> )</strong>:</p><ul><li><code>#[derive]</code>，在之前多次见到的<strong>派生宏</strong>，可以为目标结构体或枚举派生指定的代码，例如 <code>Debug</code> 特征</li><li><strong>类属性宏</strong>(Attribute-like macro)，用于为目标添加自定义的属性</li><li><strong>类函数宏</strong>(Function-like macro)，看上去就像是函数调用</li></ul><p>宏的参数可以使用 <code>()</code>、<code>[]</code> 以及 <code>&#123;&#125;</code>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;aaaa&quot;</span>);<br>    <span class="hljs-built_in">println!</span>[<span class="hljs-string">&quot;aaaa&quot;</span>];<br>    <span class="hljs-built_in">println!</span>&#123;<span class="hljs-string">&quot;aaaa&quot;</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="声明式宏-macro-rules"><a href="#声明式宏-macro-rules" class="headerlink" title="声明式宏 macro_rules!"></a>声明式宏 <code>macro_rules!</code></h2><p>在 Rust 中使用最广的就是声明式宏，它们也有一些其它的称呼，例如示例宏( macros by example )、<code>macro_rules!</code> 或干脆直接称呼为<strong>宏</strong>。</p><p>声明式宏允许我们写出类似 <code>match</code> 的代码。<code>match</code> 表达式是一个控制结构，其接收一个表达式，然后将表达式的结果与多个模式进行匹配，一旦匹配了某个模式，则该模式相关联的代码将被执行:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> target &#123;<br>    模式<span class="hljs-number">1</span> =&gt; 表达式<span class="hljs-number">1</span>,<br>    模式<span class="hljs-number">2</span> =&gt; &#123;<br>        语句<span class="hljs-number">1</span>;<br>        语句<span class="hljs-number">2</span>;<br>        表达式<span class="hljs-number">2</span><br>    &#125;,<br>    _ =&gt; 表达式<span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而<strong>宏也是将一个值跟对应的模式进行匹配，且该模式会与特定的代码相关联</strong>。但是与 <code>match</code> 不同的是，<strong>宏里的值是一段 Rust 源代码</strong>(字面量)，模式用于跟这段源代码的结构相比较，一旦匹配，传入宏的那段源代码将被模式关联的代码所替换，最终实现宏展开。值得注意的是，<strong>所有的这些都是在编译期发生，并没有运行期的性能损耗</strong>。</p><h2 id="过程宏"><a href="#过程宏" class="headerlink" title="过程宏"></a>过程宏</h2><p>第二种常用的宏就是<a href="https://doc.rust-lang.org/reference/procedural-macros.html"><em>过程宏</em></a> ( <em>procedural macros</em> )，从形式上来看，过程宏跟函数较为相像，但过程宏是使用源代码作为输入参数，基于代码进行一系列操作后，再输出一段全新的代码。<strong>注意，过程宏中的 derive 宏输出的代码并不会替换之前的代码，这一点与声明宏有很大的不同！</strong></p><p>至于前文提到的过程宏的三种类型(自定义 <code>derive</code>、属性宏、函数宏)，它们的工作方式都是类似的。</p><p>当<strong>创建过程宏</strong>时，它的定义必须要放入一个独立的包中，且包的类型也是特殊的，这么做的原因相当复杂，大家只要知道这种限制在未来可能会有所改变即可。</p><h3 id="自定义-derive-过程宏"><a href="#自定义-derive-过程宏" class="headerlink" title="自定义 derive 过程宏"></a>自定义 derive 过程宏</h3><p>首先，在 <code>hello_macro_derive/Cargo.toml</code> 文件中添加以下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[lib]</span><br><span class="hljs-attr">proc-macro</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">syn</span> = <span class="hljs-string">&quot;2.0.74&quot;</span><br><span class="hljs-attr">quote</span> = <span class="hljs-string">&quot;1.0.36&quot;</span><br></code></pre></td></tr></table></figure><p>其中 <code>syn</code> 和 <code>quote</code> 依赖包都是定义过程宏所必需的，同时，还需要在 <code>[lib]</code> 中将过程宏的开关开启 : <code>proc-macro = true</code>。</p><p>其次，在 <code>hello_macro_derive/src/lib.rs</code> 中添加如下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> proc_macro;<br><br><span class="hljs-keyword">use</span> proc_macro::TokenStream;<br><span class="hljs-keyword">use</span> quote::quote;<br><span class="hljs-keyword">use</span> syn;<br><span class="hljs-keyword">use</span> syn::DeriveInput;<br><br><span class="hljs-meta">#[proc_macro_derive(HelloMacro)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_macro_derive</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;<br>    <span class="hljs-comment">// 基于 input 构建 AST 语法树</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">ast</span>:DeriveInput = syn::<span class="hljs-title function_ invoke__">parse</span>(input).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-comment">// 构建特征实现代码</span><br>    <span class="hljs-title function_ invoke__">impl_hello_macro</span>(&amp;ast)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类属性宏-Attribute-like-macros"><a href="#类属性宏-Attribute-like-macros" class="headerlink" title="类属性宏(Attribute-like macros)"></a>类属性宏(Attribute-like macros)</h3><p>类属性过程宏跟 <code>derive</code> 宏类似，但是前者允许我们定义自己的属性。除此之外，<code>derive</code> 只能用于结构体和枚举，而类属性宏可以用于其它类型项，例如函数。</p><p>假设我们在开发一个 <code>web</code> 框架，当用户通过 <code>HTTP GET</code> 请求访问 <code>/</code> 根路径时，使用 <code>index</code> 函数为其提供服务:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[route(GET, <span class="hljs-string">&quot;/&quot;</span>)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">index</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>如上所示，代码功能非常清晰、简洁，这里的 <code>#[route]</code> 属性就是一个过程宏，它的定义函数大概如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[proc_macro_attribute]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">route</span>(attr: TokenStream, item: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;&#125;<br></code></pre></td></tr></table></figure><p>与 <code>derive</code> 宏不同，类属性宏的定义函数有两个参数：</p><ul><li>第一个参数时用于说明属性包含的内容：<code>Get, &quot;/&quot;</code> 部分</li><li>第二个是属性所标注的类型项，在这里是 <code>fn index() &#123;...&#125;</code>，注意，函数体也被包含其中</li></ul><p>除此之外，类属性宏跟 <code>derive</code> 宏的工作方式并无区别：创建一个包，类型是 <code>proc-macro</code>，接着实现一个函数用于生成想要的代码。</p><h3 id="类函数宏-Function-like-macros"><a href="#类函数宏-Function-like-macros" class="headerlink" title="类函数宏(Function-like macros)"></a>类函数宏(Function-like macros)</h3><p>类函数宏可以让我们定义像函数那样调用的宏，从这个角度来看，它跟声明宏 <code>macro_rules</code> 较为类似。</p><p>区别在于，<code>macro_rules</code> 的定义形式与 <code>match</code> 匹配非常相像，而类函数宏的定义形式则类似于之前讲过的两种过程宏:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[proc_macro]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">sql</span>(input: TokenStream) <span class="hljs-punctuation">-&gt;</span> TokenStream &#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 进阶 - Day 26 迭代器</title>
    <link href="/2024/12/06/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2026%20%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2024/12/06/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2026%20%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在 Rust 中，迭代器是一种用于遍历集合（如数组、向量、链表等）元素的工具。迭代器提供了一种抽象的方式来处理序列数据，而不需要关心数据是如何存储的。</p><h2 id="惰性初始化"><a href="#惰性初始化" class="headerlink" title="惰性初始化"></a>惰性初始化</h2><p>在 Rust 中，迭代器是惰性的，这意味着它们只有在需要时才会计算序列中的下一个元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// 这里不使用时不会调用</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v1_iter</span> = v1.<span class="hljs-title function_ invoke__">iter</span>();<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">val</span> <span class="hljs-keyword">in</span> v1_iter &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, val);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种惰性初始化的方式确保了创建迭代器不会有任何额外的性能损耗，其中的元素也不会被消耗，只有使用到该迭代器的时候，一切才开始。</p><h2 id="实现迭代器"><a href="#实现迭代器" class="headerlink" title="实现迭代器"></a>实现迭代器</h2><ul><li><p>迭代器是一个能够逐一生成元素的对象。它提供了一个统一的接口，用于遍历容器中的元素，同时保证了类型安全和内存安全。</p></li><li><p><strong>迭代器之所以成为迭代器，就是因为实现了 <code>Iterator</code> 特征</strong>，要实现该特征，最主要的就是实现其中的 <code>next</code> 方法，该方法控制如何从集合中取值，最终返回值的类型是<a href="https://course.rs/basic/trait/advance-trait#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B">关联类型</a> <code>Item</code>。</p><ul><li>所有迭代器都实现了 <code>Iterator Trait</code>, 定义于标准库，定义大致如下:</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br><br>    <span class="hljs-comment">// 省略其余有默认实现的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>type Item</code>  ：定义了迭代器产生的元素的类型。 </li><li><code>fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;</code>  ：返回序列中的下一个元素，如果没有更多元素，则返回   None  。</li></ul><h2 id="创建迭代器"><a href="#创建迭代器" class="headerlink" title="创建迭代器"></a>创建迭代器</h2><p>可以调用 <code>into_iter</code>, <code>iter</code>, <code>iter_mut</code> 3个方法对于集合类型（如   <code>Vec\&lt;T\&gt;</code>  、  <code>String</code>  、  <code>Array</code>   等）创建迭代器，3 个方法的区别：</p><ul><li><code>into_iter</code> 会夺走所有权</li><li><code>iter</code> 是借用</li><li><code>iter_mut</code> 是可变借用</li></ul><p>使用一段代码来解释下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> values.<span class="hljs-title function_ invoke__">into_iter</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, v)<br>    &#125;<br><br>    <span class="hljs-comment">// 下面的代码将报错，因为 values 的所有权在上面 `for` 循环中已经被转移走</span><br>    <span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;,values);</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_values_iter</span> = values.<span class="hljs-title function_ invoke__">iter</span>();<br><br>    <span class="hljs-comment">// 不会报错，因为 values_iter 只是借用了 values 中的元素</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, values);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-comment">// 对 values 中的元素进行可变借用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">values_iter_mut</span> = values.<span class="hljs-title function_ invoke__">iter_mut</span>();<br><br>    <span class="hljs-comment">// 取出第一个元素，并修改为0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(v) = values_iter_mut.<span class="hljs-title function_ invoke__">next</span>() &#123;<br>        *v = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出[0, 2, 3]</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, values);<br>&#125;<br></code></pre></td></tr></table></figure><p>具体解释在代码注释中，就不再赘述，不过有两点需要注意的是：</p><ul><li><code>.iter()</code> 方法实现的迭代器，调用 <code>next</code> 方法返回的类型是 <code>Some(&amp;T)</code></li><li><code>.iter_mut()</code> 方法实现的迭代器，调用 <code>next</code> 方法返回的类型是 <code>Some(&amp;mut T)</code>，因此在 <code>if let Some(v) = values_iter_mut.next()</code> 中，<code>v</code> 的类型是 <code>&amp;mut i32</code>，最终我们可以通过 <code>*v = 0</code> 的方式修改其值</li></ul><h2 id="消费者与适配器"><a href="#消费者与适配器" class="headerlink" title="消费者与适配器"></a>消费者与适配器</h2><p>消费者是迭代器上的方法，它会消费掉迭代器中的元素，然后返回其类型的值，这些消费者都有一个共同的特点：在它们的定义中，都依赖 <code>next</code> 方法来消费元素，因此这也是为什么迭代器要实现 <code>Iterator</code> 特征，而该特征必须要实现 <code>next</code> 方法的原因。</p><h3 id="消费者适配器"><a href="#消费者适配器" class="headerlink" title="消费者适配器"></a>消费者适配器</h3><p>只要迭代器上的某个方法 <code>A</code> 在其内部调用了 <code>next</code> 方法，那么 <code>A</code> 就被称为<strong>消费性适配器</strong>：因为 <code>next</code> 方法会消耗掉迭代器上的元素，所以方法 <code>A</code> 的调用也会消耗掉迭代器上的元素。</p><p>常用的有以下方法：</p><ul><li><code>collect</code>  ：将迭代器的元素收集到一个集合中。</li><li><code>sum</code>  ：计算迭代器中所有元素的和。</li><li><code>max</code>   和   <code>min</code>  ：找出迭代器中的最大值或最小值。</li><li><code>fold</code>   和   <code>reduce</code>  ：对迭代器的元素进行累积操作。</li></ul><h3 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h3><p>迭代器适配器，顾名思义，会返回一个新的迭代器，这是实现链式方法调用的关键：<code>v.iter().map().filter()...</code>。</p><p>与消费者适配器不同，迭代器适配器是惰性的，意味着你<strong>需要一个消费者适配器来收尾，最终将迭代器转换成一个具体的值</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x + <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">collect</span>();<br><br><span class="hljs-built_in">assert_eq!</span>(v2, <span class="hljs-built_in">vec!</span>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);<br><br></code></pre></td></tr></table></figure><p>常用的还有以下方法：</p><ul><li><code>map</code>  ：对迭代器的每个元素应用一个函数，并返回一个新的迭代器。</li><li><code>filter</code>  ：根据一个条件函数过滤迭代器的元素。</li><li><code>filter_map</code>  ：结合   <code>map</code>   和   <code>filter</code>   的功能。</li><li><code>flat_map</code>  ：将迭代器中的每个元素映射成一个迭代器，并将它们连接起来。</li><li><code>take</code>  ：从迭代器中取出指定数量的元素。</li><li><code>skip</code>  ：跳过迭代器中的前 N 个元素。</li><li><code>enumerate</code>  ：给迭代器的每个元素加上索引。</li><li><code>rev</code>  ：反转迭代器的方向。</li><li><code>zip</code>：将两个迭代器“压缩”在一起，每次迭代返回一个元组，其中包含两个迭代器的元素。</li><li><code>inspect</code>：对迭代器中的每个元素应用一个函数，但不改变迭代器中的元素。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 进阶 - Day 25 闭包</title>
    <link href="/2024/12/05/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2025%20%E9%97%AD%E5%8C%85/"/>
    <url>/2024/12/05/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2025%20%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="闭包介绍"><a href="#闭包介绍" class="headerlink" title="闭包介绍"></a>闭包介绍</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>闭包是<strong>一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值</strong>，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = |y| x + y;<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, <span class="hljs-title function_ invoke__">sum</span>(<span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码展示了非常简单的闭包 <code>sum</code>，它拥有一个入参 <code>y</code>，同时捕获了作用域中的 <code>x</code> 的值，因此调用 <code>sum(2)</code> 意味着将 2（参数 <code>y</code>）跟 1（<code>x</code>）进行相加，最终返回它们的和：<code>3</code>。</p><p>可以看到 <code>sum</code> 非常符合闭包的定义：可以赋值给变量，允许捕获调用者作用域中的值。</p><h2 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h2><ul><li>可以捕获周围作用域的变量。</li><li>支持作为参数传递给其他函数</li><li>可以返回闭包作为函数的返回值。</li><li>类型推断：闭包通常通过类型推断来确定参数和返回值的类型。</li></ul><h2 id="闭包的定义"><a href="#闭包的定义" class="headerlink" title="闭包的定义"></a>闭包的定义</h2><p>闭包的形式定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">|param1, param2,...| &#123;<br>    语句<span class="hljs-number">1</span>;<br>    语句<span class="hljs-number">2</span>;<br>    返回表达式<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只有一个返回表达式的话，定义可以简化为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">|param1| 返回表达式<br></code></pre></td></tr></table></figure><p>上例中还有两点值得注意：</p><ul><li><strong>闭包中最后一行表达式返回的值，就是闭包执行后的返回值</strong>&#96;</li><li><code>let sum = ||...</code> 只是把闭包赋值给变量 <code>sum</code>，并不是把闭包执行后的结果赋值给 <code>sum</code>，因此这里 <code>sum</code> 就相当于闭包函数，可以跟函数一样进行调用：<code>sum()</code></li></ul><h2 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h2><h3 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h3><p>闭包可以作为函数的参数传递，从而实现更灵活的代码结构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">double</span> = |x| x * <span class="hljs-number">2</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">apply_to_3</span>(double));<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">apply_to_3</span>&lt;F&gt;(f: F) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br><span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>,<br>&#123;<br><span class="hljs-title function_ invoke__">f</span>(<span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="捕获作用域中的值"><a href="#捕获作用域中的值" class="headerlink" title="捕获作用域中的值"></a>捕获作用域中的值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">equal_to_x</span> = |z| z == x;<br><br><span class="hljs-comment">// 用函数定义的话不能访问 x</span><br><span class="hljs-comment">// fn equal_to_x(z: i32) -&gt; bool &#123; z == x &#125; </span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="三种-Fn-特征"><a href="#三种-Fn-特征" class="headerlink" title="三种 Fn 特征"></a>三种 Fn 特征</h4><p>闭包捕获变量有三种途径，恰好对应函数参数的三种传入方式：转移所有权、可变借用、不可变借用，因此相应的 <code>Fn</code> 特征也有三种：</p><ol><li><code>Fn</code> 按引用捕获</li><li><code>FnMut</code> 按可变引用捕获</li><li><code>FnOnce</code> 按值捕获</li></ol><p>一个闭包并不仅仅实现某一种 <code>Fn</code> 特征，规则如下：</p><ul><li>所有的闭包都自动实现了 <code>FnOnce</code> 特征，因此任何一个闭包都至少可以被调用一次</li><li>没有移出所捕获变量的所有权的闭包自动实现了 <code>FnMut</code> 特征</li><li>不需要对捕获变量进行改变的闭包自动实现了 <code>Fn</code> 特征</li></ul><h2 id="move-关键字"><a href="#move-关键字" class="headerlink" title="move 关键字"></a>move 关键字</h2><p>在参数列表前使用move关键字，可以强制闭包取得它所使用的环境值的所有权当将闭包传递给新线程以移动数据使其归新线程所有时，此技术最为有用。</p><p><strong>一个闭包实现了哪种 Fn 特征取决于该闭包如何使用被捕获的变量，而不是取决于闭包如何捕获它们</strong>。</p><p><code>move</code> 本身强调的就是后者，闭包如何捕获变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">equal_to_x</span> = <span class="hljs-keyword">move</span> |z| z == x;<br><span class="hljs-comment">// let equal_to_x = |z| z == x;</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can&#x27;t use x here: &#123;:?&#125;&quot;</span>, x);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-built_in">assert!</span>(<span class="hljs-title function_ invoke__">equal_to_x</span>(y))<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 进阶 - Day 24 智能指针 Part 2</title>
    <link href="/2024/12/04/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2024%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20Part%202/"/>
    <url>/2024/12/04/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2024%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20Part%202/</url>
    
    <content type="html"><![CDATA[<h2 id="Rc"><a href="#Rc" class="headerlink" title="Rc&lt;T&gt;"></a>Rc&lt;T&gt;</h2><p>引用计数(reference counting)，顾名思义，通过记录一个数据被引用的次数来确定该数据是否正在被使用。当引用次数归零时，就代表该数据不再被使用，因此可以被清理释放。</p><p>而 <code>Rc</code> 正是引用计数的英文缩写。当我们<strong>希望在堆上分配一个对象供程序的多个部分使用且无法确定哪个部分最后一个结束时，就可以使用 <code>Rc</code> 成为数据值的所有者</strong>，例如之前提到的多线程场景就非常适合。</p><p>一个综合例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Owner</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    <span class="hljs-comment">// ...其它字段</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Gadget</span> &#123;<br>    id: <span class="hljs-type">i32</span>,<br>    owner: Rc&lt;Owner&gt;,<br>    <span class="hljs-comment">// ...其它字段</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个基于引用计数的 `Owner`.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gadget_owner</span>: Rc&lt;Owner&gt; = Rc::<span class="hljs-title function_ invoke__">new</span>(Owner &#123;<br>        name: <span class="hljs-string">&quot;Gadget Man&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>    &#125;);<br><br>    <span class="hljs-comment">// 创建两个不同的工具，它们属于同一个主人</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gadget1</span> = Gadget &#123;<br>        id: <span class="hljs-number">1</span>,<br>        owner: Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;gadget_owner),<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gadget2</span> = Gadget &#123;<br>        id: <span class="hljs-number">2</span>,<br>        owner: Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;gadget_owner),<br>    &#125;;<br><br>    <span class="hljs-comment">// 释放掉第一个 `Rc&lt;Owner&gt;`</span><br>    <span class="hljs-title function_ invoke__">drop</span>(gadget_owner);<br><br>    <span class="hljs-comment">// 尽管在上面我们释放了 gadget_owner，但是依然可以在这里使用 owner 的信息</span><br>    <span class="hljs-comment">// 原因是在 drop 之前，存在三个指向 Gadget Man 的智能指针引用，上面仅仅</span><br>    <span class="hljs-comment">// drop 掉其中一个智能指针引用，而不是 drop 掉 owner 数据，外面还有两个</span><br>    <span class="hljs-comment">// 引用指向底层的 owner 数据，引用计数尚未清零</span><br>    <span class="hljs-comment">// 因此 owner 数据依然可以被使用</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Gadget &#123;&#125; owned by &#123;&#125;&quot;</span>, gadget1.id, gadget1.owner.name);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Gadget &#123;&#125; owned by &#123;&#125;&quot;</span>, gadget2.id, gadget2.owner.name);<br><br>    <span class="hljs-comment">// 在函数最后，`gadget1` 和 `gadget2` 也被释放，最终引用计数归零，随后底层</span><br>    <span class="hljs-comment">// 数据也被清理释放</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Rc简单总结"><a href="#Rc简单总结" class="headerlink" title="Rc简单总结"></a>Rc简单总结</h3><ul><li><code>Rc/Arc</code> 是不可变引用，你无法修改它指向的值，只能进行读取，如果要修改，需要配合后面章节的内部可变性 <code>RefCell</code> 或互斥锁 <code>Mutex</code></li><li>一旦最后一个拥有者消失，则资源会自动被回收，这个生命周期是在编译期就确定下来的</li><li><code>Rc</code> 只能用于同一线程内部，想要用于线程之间的对象共享，你需要使用 <code>Arc</code></li><li><code>Rc&lt;T&gt;</code> 是一个智能指针，实现了 <code>Deref</code> 特征，因此你无需先解开 <code>Rc</code> 指针，再使用里面的 <code>T</code>，而是可以直接使用 <code>T</code>，例如上例中的 <code>gadget1.owner.name</code></li></ul><h2 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h2><p><code>Arc</code> 是 <code>Atomic Rc</code> 的缩写，顾名思义：原子化的 <code>Rc&lt;T&gt;</code> 智能指针。</p><ul><li>和 <code>Rc</code> 拥有完全一样的 API。</li><li>性能损耗高。</li><li>引入方式不一样，<code>Arc</code> 通过 <code>use std::sync::Arc</code> 来引入，<code>Rc</code> 通过 <code>use std::rc::Rc</code>。</li></ul><h2 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell&lt;T&gt;"></a>RefCell&lt;T&gt;</h2><p><code>Refcell&lt;T&gt;</code> 是 Rust 标准库中的一个智能指针类型，它提供了内部可变性，即允许在不可变引用的情况下修改数据。这种特性使得你可以在编译时保证安全的情况下动态地借用和修改数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello, world&quot;</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = s.<span class="hljs-title function_ invoke__">borrow</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s.<span class="hljs-title function_ invoke__">borrow_mut</span>();<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>, s1, s2);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h3><ul><li>内部可变性:<ul><li><code>Refcell&lt;T&gt;</code> 允许你在其拥有的 T 内部进行修改，即使 Refcell 本身是不可变的。这是通过在运行时进行借用检查实现的。</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Messenger</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>);<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    msg_cache: RefCell&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Messenger</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MsgQueue</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">send</span>(&amp;<span class="hljs-keyword">self</span>, msg: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.msg_cache.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(msg)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">mq</span> = MsgQueue &#123;<br>        msg_cache: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()),<br>    &#125;;<br>    mq.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-string">&quot;hello, world&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>通过包裹一层 <code>RefCell</code>，成功的让 <code>&amp;self</code> 中的 <code>msg_cache</code> 成为一个可变值，然后实现对其的修改。</p><ul><li><p>运行时借用检查:</p><ul><li>Refcell 使用动态借用检查，确保在运行时遵循 Rust 的借用规则。即，在任何时刻， Refcell 只能有一个可变借用或多个不可变借用，但不能同时存在。</li></ul></li><li><p>Refcell 提供了两个方法来获取对内部数据的借用:</p><ul><li><code>borrow()</code>: 获取不可变借用( <code>Ref&lt;T&gt;</code>)，可以同时有多个。</li><li><code>borrow_mut()</code>: 获取可变借用( <code>RefMut&lt;T&gt;</code>)，在同一时间只能有一个。</li></ul></li></ul><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><ul><li>与 <code>Cell</code> 用于可 <code>Copy</code> 的值不同，<code>RefCell</code> 用于引用</li><li><code>RefCell</code> 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则</li><li><code>RefCell</code> 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时</li><li>使用 <code>RefCell</code> 时，违背借用规则会导致运行期的 <code>panic</code></li></ul><h3 id="Rc-RefCell-组合使用"><a href="#Rc-RefCell-组合使用" class="headerlink" title="Rc + RefCell 组合使用"></a>Rc + RefCell 组合使用</h3><p>在 Rust 中，一个常见的组合就是 <code>Rc</code> 和 <code>RefCell</code> 在一起使用，前者可以实现一个数据拥有多个所有者，后者可以实现数据的可变性：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">use</span> std::rc::Rc;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;我很善变，还拥有多个主人&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()));<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = s.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s.<span class="hljs-title function_ invoke__">clone</span>();<br>    <span class="hljs-comment">// let mut s2 = s.borrow_mut();</span><br>    s2.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, oh yeah!&quot;</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;\n&#123;:?&#125;\n&#123;:?&#125;&quot;</span>, s, s1, s2);<br>    <span class="hljs-comment">// 输出如下：</span><br>    <span class="hljs-comment">// RefCell &#123; value: &quot;我很善变，还拥有多个主人, oh yeah!&quot; &#125;</span><br><span class="hljs-comment">// RefCell &#123; value: &quot;我很善变，还拥有多个主人, oh yeah!&quot; &#125;</span><br><span class="hljs-comment">// RefCell &#123; value: &quot;我很善变，还拥有多个主人, oh yeah!&quot; &#125;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，我们使用 <code>RefCell&lt;String&gt;</code> 包裹一个字符串，同时通过 <code>Rc</code> 创建了它的三个所有者：<code>s</code>、<code>s1</code>和<code>s2</code>，并且通过其中一个所有者 <code>s2</code> 对字符串内容进行了修改。</p><p>由于 <code>Rc</code> 的所有者们共享同一个底层的数据，因此当一个所有者修改了数据时，会导致全部所有者持有的数据都发生了变化。</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>一个循环引用的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> crate::List::&#123;Cons, Nil&#125;;<br><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),<br>    Nil,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">tail</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;<br>            <span class="hljs-title function_ invoke__">Cons</span>(_, item) =&gt; <span class="hljs-title function_ invoke__">Some</span>(item),<br>            Nil =&gt; <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">5</span>, RefCell::<span class="hljs-title function_ invoke__">new</span>(Rc::<span class="hljs-title function_ invoke__">new</span>(Nil))));<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a的初始化rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a指向的节点 = &#123;:?&#125;&quot;</span>, a.<span class="hljs-title function_ invoke__">tail</span>());<br><br>    <span class="hljs-comment">// 创建`b`到`a`的引用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">10</span>, RefCell::<span class="hljs-title function_ invoke__">new</span>(Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a))));<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;在b创建后，a的rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b的初始化rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;b));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;b指向的节点 = &#123;:?&#125;&quot;</span>, b.<span class="hljs-title function_ invoke__">tail</span>());<br><br>    <span class="hljs-comment">// 利用RefCell的可变性，创建了`a`到`b`的引用</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(link) = a.<span class="hljs-title function_ invoke__">tail</span>() &#123;<br>        *link.<span class="hljs-title function_ invoke__">borrow_mut</span>() = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;b);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;在更改a后，b的rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;b));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;在更改a后，a的rc计数 = &#123;&#125;&quot;</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br><br>    <span class="hljs-comment">// 下面一行println!将导致循环引用</span><br>    <span class="hljs-comment">// 我们可怜的8MB大小的main线程栈空间将被它冲垮，最终造成栈溢出</span><br>    <span class="hljs-comment">// println!(&quot;a next item = &#123;:?&#125;&quot;, a.tail());</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个类型定义看着复杂，使用起来更复杂！不过排除这些因素，我们可以清晰看出：</p><ol><li>在创建了 <code>a</code> 后，紧接着就使用 <code>a</code> 创建了 <code>b</code>，因此 <code>b</code> 引用了 <code>a</code></li><li>然后我们又利用 <code>Rc</code> 克隆了 <code>b</code>，然后通过 <code>RefCell</code> 的可变性，让 <code>a</code> 引用了 <code>b</code></li></ol><p>至此我们成功创建了循环引用<code>a</code>-&gt; <code>b</code> -&gt; <code>a</code> -&gt; <code>b</code> ····</p><p>先来观察下引用计数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">a的初始化rc计数 = 1<br>a指向的节点 = Some(RefCell &#123; value: Nil &#125;)<br>在b创建后，a的rc计数 = 2<br>b的初始化rc计数 = 1<br>b指向的节点 = Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)<br>在更改a后，b的rc计数 = 2<br>在更改a后，a的rc计数 = 2<br></code></pre></td></tr></table></figure><p>在 <code>main</code> 函数结束前，<code>a</code> 和 <code>b</code> 的引用计数均是 <code>2</code>，随后 <code>b</code> 触发 <code>Drop</code>，此时引用计数会变为 <code>1</code>，并不会归 <code>0</code>，因此 <code>b</code> 所指向内存不会被释放，同理可得 <code>a</code> 指向的内存也不会被释放，最终发生了内存泄漏。</p><p>下面一张图很好的展示了这种引用循环关系：</p><p><img src="/img/rust_loop.png"></p><p>反注释最后一行代码，运行之后发生了栈溢出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123; value: Cons(5, RefCell &#123; value: Cons(10, RefCell &#123;<br>...无穷无尽<br>thread <span class="hljs-string">&#x27;main&#x27;</span> has overflowed its stack<br>fatal runtime error: stack overflow<br></code></pre></td></tr></table></figure><p>如果我们确实需要实现上面的功能，该怎么办？答案是使用 <code>Weak</code></p><h2 id="Weak"><a href="#Weak" class="headerlink" title="Weak"></a>Weak</h2><p><code>Weak</code> 通过 <code>use std::rc::Weak</code> 来引入，它具有以下特点:</p><ul><li>可访问，但没有所有权，不增加引用计数，因此不会影响被引用值的释放回收</li><li>可由 <code>Rc&lt;T&gt;</code> 调用 <code>downgrade</code> 方法转换成 <code>Weak&lt;T&gt;</code></li><li><code>Weak&lt;T&gt;</code> 可使用 <code>upgrade</code> 方法转换成 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，如果资源已经被释放，则 <code>Option</code> 的值是 <code>None</code></li><li>常用于解决循环引用的问题</li></ul><p>一个简单的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建Rc，持有一个值5</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">five</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 通过Rc，创建一个Weak指针</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">weak_five</span> = Rc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;five);<br><br>    <span class="hljs-comment">// Weak引用的资源依然存在，取到值5</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">strong_five</span>: <span class="hljs-type">Option</span>&lt;Rc&lt;_&gt;&gt; = weak_five.<span class="hljs-title function_ invoke__">upgrade</span>();<br>    <span class="hljs-built_in">assert_eq!</span>(*strong_five.<span class="hljs-title function_ invoke__">unwrap</span>(), <span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 手动释放资源`five`</span><br>    <span class="hljs-title function_ invoke__">drop</span>(five);<br><br>    <span class="hljs-comment">// Weak引用的资源已不存在，因此返回None</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">strong_five</span>: <span class="hljs-type">Option</span>&lt;Rc&lt;_&gt;&gt; = weak_five.<span class="hljs-title function_ invoke__">upgrade</span>();<br>    <span class="hljs-built_in">assert_eq!</span>(strong_five, <span class="hljs-literal">None</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Weak-与-Rc-对比"><a href="#Weak-与-Rc-对比" class="headerlink" title="Weak 与 Rc 对比"></a>Weak 与 Rc 对比</h3><p>我们来将 <code>Weak</code> 与 <code>Rc</code> 进行以下简单对比：</p><table><thead><tr><th><code>Weak</code></th><th><code>Rc</code></th></tr></thead><tbody><tr><td>不计数</td><td>引用计数</td></tr><tr><td>不拥有所有权</td><td>拥有值的所有权</td></tr><tr><td>不阻止值被释放(drop)</td><td>所有权计数归零，才能 drop</td></tr><tr><td>引用的值存在返回 <code>Some</code>，不存在返回 <code>None</code></td><td>引用的值必定存在</td></tr><tr><td>通过 <code>upgrade</code> 取到 <code>Option&lt;Rc&lt;T&gt;&gt;</code>，然后再取值</td><td>通过 <code>Deref</code> 自动解引用，取值无需任何操作</td></tr></tbody></table><p>通过这个对比，可以非常清晰的看出 <code>Weak</code> 为何这么弱，而这种弱恰恰非常适合我们实现以下的场景：</p><ul><li>持有一个 <code>Rc</code> 对象的临时引用，并且不在乎引用的值是否依然存在</li><li>阻止 <code>Rc</code> 导致的循环引用，因为 <code>Rc</code> 的所有权机制，会导致多个 <code>Rc</code> 都无法计数归零</li></ul><p>使用方式简单总结下：<strong>对于父子引用关系，可以让父节点通过 <code>Rc</code> 来引用子节点，然后让子节点通过 <code>Weak</code> 来引用父节点</strong>。</p><h3 id="使用-Weak-解决循环引用"><a href="#使用-Weak-解决循环引用" class="headerlink" title="使用 Weak 解决循环引用"></a>使用 Weak 解决循环引用</h3><h4 id="案例一：工具间的故事"><a href="#案例一：工具间的故事" class="headerlink" title="案例一：工具间的故事"></a>案例一：工具间的故事</h4><p>工具间里，每个工具都有其主人，且多个工具可以拥有一个主人；同时一个主人也可以拥有多个工具，在这种场景下，就很容易形成循环引用，好在我们有 <code>Weak</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><span class="hljs-keyword">use</span> std::rc::Weak;<br><span class="hljs-keyword">use</span> std::cell::RefCell;<br><br><span class="hljs-comment">// 主人</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Owner</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    gadgets: RefCell&lt;<span class="hljs-type">Vec</span>&lt;Weak&lt;Gadget&gt;&gt;&gt;,<br>&#125;<br><br><span class="hljs-comment">// 工具</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Gadget</span> &#123;<br>    id: <span class="hljs-type">i32</span>,<br>    owner: Rc&lt;Owner&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 创建一个 Owner</span><br>    <span class="hljs-comment">// 需要注意，该 Owner 也拥有多个 `gadgets`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gadget_owner</span> : Rc&lt;Owner&gt; = Rc::<span class="hljs-title function_ invoke__">new</span>(<br>        Owner &#123;<br>            name: <span class="hljs-string">&quot;Gadget Man&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),<br>            gadgets: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>()),<br>        &#125;<br>    );<br><br>    <span class="hljs-comment">// 创建工具，同时与主人进行关联：创建两个 gadget，他们分别持有 gadget_owner 的一个引用。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gadget1</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(Gadget&#123;id: <span class="hljs-number">1</span>, owner: gadget_owner.<span class="hljs-title function_ invoke__">clone</span>()&#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">gadget2</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(Gadget&#123;id: <span class="hljs-number">2</span>, owner: gadget_owner.<span class="hljs-title function_ invoke__">clone</span>()&#125;);<br><br>    <span class="hljs-comment">// 为主人更新它所拥有的工具</span><br>    <span class="hljs-comment">// 因为之前使用了 `Rc`，现在必须要使用 `Weak`，否则就会循环引用</span><br>    gadget_owner.gadgets.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(Rc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;gadget1));<br>    gadget_owner.gadgets.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push</span>(Rc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;gadget2));<br><br>    <span class="hljs-comment">// 遍历 gadget_owner 的 gadgets 字段</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">gadget_opt</span> <span class="hljs-keyword">in</span> gadget_owner.gadgets.<span class="hljs-title function_ invoke__">borrow</span>().<span class="hljs-title function_ invoke__">iter</span>() &#123;<br><br>        <span class="hljs-comment">// gadget_opt 是一个 Weak&lt;Gadget&gt; 。 因为 weak 指针不能保证他所引用的对象</span><br>        <span class="hljs-comment">// 仍然存在。所以我们需要显式的调用 upgrade() 来通过其返回值(Option&lt;_&gt;)来判</span><br>        <span class="hljs-comment">// 断其所指向的对象是否存在。</span><br>        <span class="hljs-comment">// 当然，Option 为 None 的时候这个引用原对象就不存在了。</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">gadget</span> = gadget_opt.<span class="hljs-title function_ invoke__">upgrade</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Gadget &#123;&#125; owned by &#123;&#125;&quot;</span>, gadget.id, gadget.owner.name);<br>    &#125;<br><br>    <span class="hljs-comment">// 在 main 函数的最后，gadget_owner，gadget1 和 gadget2 都被销毁。</span><br>    <span class="hljs-comment">// 具体是，因为这几个结构体之间没有了强引用（`Rc&lt;T&gt;`），所以，当他们销毁的时候。</span><br>    <span class="hljs-comment">// 首先 gadget2 和 gadget1 被销毁。</span><br>    <span class="hljs-comment">// 然后因为 gadget_owner 的引用数量为 0，所以这个对象可以被销毁了。</span><br>    <span class="hljs-comment">// 循环引用问题也就避免了</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例二：tree-数据结构"><a href="#案例二：tree-数据结构" class="headerlink" title="案例二：tree 数据结构"></a>案例二：tree 数据结构</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><span class="hljs-keyword">use</span> std::rc::&#123;Rc, Weak&#125;;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,<br>    children: RefCell&lt;<span class="hljs-type">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">leaf</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>        value: <span class="hljs-number">3</span>,<br>        parent: RefCell::<span class="hljs-title function_ invoke__">new</span>(Weak::<span class="hljs-title function_ invoke__">new</span>()),<br>        children: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[]),<br>    &#125;);<br><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,<br>        Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;leaf),<br>        Rc::<span class="hljs-title function_ invoke__">weak_count</span>(&amp;leaf),<br>    );<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">branch</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>            value: <span class="hljs-number">5</span>,<br>            parent: RefCell::<span class="hljs-title function_ invoke__">new</span>(Weak::<span class="hljs-title function_ invoke__">new</span>()),<br>            children: RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;leaf)]),<br>        &#125;);<br><br>        *leaf.parent.<span class="hljs-title function_ invoke__">borrow_mut</span>() = Rc::<span class="hljs-title function_ invoke__">downgrade</span>(&amp;branch);<br><br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;branch strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,<br>            Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;branch),<br>            Rc::<span class="hljs-title function_ invoke__">weak_count</span>(&amp;branch),<br>        );<br><br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,<br>            Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;leaf),<br>            Rc::<span class="hljs-title function_ invoke__">weak_count</span>(&amp;leaf),<br>        );<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;leaf parent = &#123;:?&#125;&quot;</span>, leaf.parent.<span class="hljs-title function_ invoke__">borrow</span>().<span class="hljs-title function_ invoke__">upgrade</span>());<br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;leaf strong = &#123;&#125;, weak = &#123;&#125;&quot;</span>,<br>        Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;leaf),<br>        Rc::<span class="hljs-title function_ invoke__">weak_count</span>(&amp;leaf),<br>    );<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 进阶 - Day 23 智能指针 Part 1</title>
    <link href="/2024/12/03/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2023%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20Part%201/"/>
    <url>/2024/12/03/Rust%20%E8%BF%9B%E9%98%B6%20-%20Day%2023%20%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%20Part%201/</url>
    
    <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="什么是智能指针"><a href="#什么是智能指针" class="headerlink" title="什么是智能指针"></a>什么是智能指针</h3><p>智能指针(Smart Pointers)是一类数据结构，它不仅包含一个指针，还附带一些额外的元数据和功能。与普通指针不同，智能指针在 Rust 中实现了 Deref 和 Drop 两个trait，这使得它们可以像指针一样解引用并在离开作用域时自动清理资源。</p><h3 id="智能指针作用"><a href="#智能指针作用" class="headerlink" title="智能指针作用"></a>智能指针作用</h3><ul><li>资源管理<ul><li>自动管理资源的分配和释放，避免内存泄漏。</li></ul></li><li>所有权与借用<ul><li>Rust 的所有权系统通过智能指针来确保内存安全，避免数据竞争和悬垂指针。</li></ul></li><li>复杂数据结构<ul><li>通过智能指针可以构建复杂的数据结构，如递归结构共享数据等。</li></ul></li></ul><h3 id="智能指针特性"><a href="#智能指针特性" class="headerlink" title="智能指针特性"></a>智能指针特性</h3><ul><li><p><code>Deref</code> Trait</p><ul><li>实现了 Deref trait 的类型可以像常规引用一样使用*运算符解引用。</li><li>例如: <code>Box&lt;T&gt;</code>实现了 Deref，所以可以通过<code>*</code>解引用获取其内部数据。</li></ul></li><li><p><code>Drop</code> Trait</p><ul><li>实现了 Drop trait 的类型在离开作用域时会自动调用其drop 方法，用于释放资源。</li><li>例如: <code>Box&lt;T&gt;</code>在超出作用域时会自动释放堆内存。</li></ul></li></ul><h2 id="Box"><a href="#Box" class="headerlink" title="Box&lt;T&gt;"></a>Box&lt;T&gt;</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><code>Box&lt;T&gt;</code> 将类型 <code>T</code> 的值分配在堆上，而不是栈上。</li><li>当 Box 被销毁时，堆上的数据也会被销毁。</li></ul><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><ul><li>Box的底层原理<ul><li><code>Box&lt;T&gt;</code>实际上是一个智能指针，内部包含一个指向堆上分配内存的裸指针。</li><li>当 <code>Box&lt;T&gt;</code> 被销毁时，其 Drop trait 会被调用，释放堆上的内存。</li></ul></li><li>内存分配<ul><li>Rust 使用系统的全局分配器(如 malloc 和 free)来管理堆内存。</li><li><code>Box::new</code> 分配内存，Drop 释放内存。</li></ul></li><li>安全性<ul><li>Rust 的所有权系统确保 <code>Box&lt;T&gt;</code>的内存安全。所有权转移时，堆内存的生命周期也会随之变化。</li></ul></li></ul><h3 id="Box-的使用场景"><a href="#Box-的使用场景" class="headerlink" title="Box 的使用场景"></a>Box 的使用场景</h3><h4 id="将数据分配在堆上"><a href="#将数据分配在堆上" class="headerlink" title="将数据分配在堆上"></a>将数据分配在堆上</h4><p>如果一个变量拥有一个数值 <code>let a = 3</code>，那变量 <code>a</code> 必然是存储在栈上的，那如果我们想要 <code>a</code> 的值存储在堆上就需要使用 <code>Box&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;&quot;</span>, a); <span class="hljs-comment">// a = 3</span><br><br>    <span class="hljs-comment">// 下面一行代码将报错</span><br>    <span class="hljs-comment">// let b = a + 1; // cannot add `&#123;integer&#125;` to `Box&lt;&#123;integer&#125;&gt;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以创建一个智能指针指向了存储在堆上的 <code>3</code>，并且 <code>a</code> 持有了该指针。</p><h4 id="避免栈上数据的拷贝"><a href="#避免栈上数据的拷贝" class="headerlink" title="避免栈上数据的拷贝"></a>避免栈上数据的拷贝</h4><p>当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。</p><p>而堆上则不然，底层数据并不会被拷贝，转移所有权仅仅是复制一份栈中的指针，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效，最终完成了所有权的转移：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 在栈上创建一个长度为1000的数组</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">0</span>;<span class="hljs-number">1000</span>];<br>    <span class="hljs-comment">// 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr1</span> = arr;<br><br>    <span class="hljs-comment">// arr 和 arr1 都拥有各自的栈上数组，因此不会报错</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr.<span class="hljs-title function_ invoke__">len</span>());<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr1.<span class="hljs-title function_ invoke__">len</span>());<br><br>    <span class="hljs-comment">// 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>([<span class="hljs-number">0</span>;<span class="hljs-number">1000</span>]);<br>    <span class="hljs-comment">// 将堆上数组的所有权转移给 arr1，由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝</span><br>    <span class="hljs-comment">// 所有权顺利转移给 arr1，arr 不再拥有所有权</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr1</span> = arr;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr1.<span class="hljs-title function_ invoke__">len</span>());<br>    <span class="hljs-comment">// 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错</span><br>    <span class="hljs-comment">// println!(&quot;&#123;:?&#125;&quot;, arr.len());</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="动态大小类型（DST）"><a href="#动态大小类型（DST）" class="headerlink" title="动态大小类型（DST）"></a>动态大小类型（DST）</h4><p>类型的大小在编译期无法确定，但是我们又需要固定大小的类型时，Box 允许处理动态大小类型，如 <code>str</code> 和 <code>[T]</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">str</span>&gt; =<span class="hljs-string">&quot;Hello, world!&quot;</span>.<span class="hljs-title function_ invoke__">into</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s =&#123;&#125;&quot;</span>, s);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: <span class="hljs-type">Box</span>&lt;[<span class="hljs-type">i32</span>]&gt;= <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>, <span class="hljs-number">5</span>].<span class="hljs-title function_ invoke__">into_boxed_slice</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;arr =&#123;:?&#125;&quot;</span>, arr);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="递归数据结构"><a href="#递归数据结构" class="headerlink" title="递归数据结构"></a>递归数据结构</h5><p>其中一种无法在编译时知道大小的类型是<strong>递归类型</strong>：在类型定义中又使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值，这种值的嵌套理论上可以无限进行下去，所以 Rust 不知道递归类型需要多少空间：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, List),<br>    Nil,<br>&#125;<br><span class="hljs-comment">// error[E0072]: recursive type `List` has infinite size //递归类型 `List` 拥有无限长的大小</span><br></code></pre></td></tr></table></figure><p>此时若想解决这个问题，就可以使用 <code>Box&lt;T&gt;</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">List</span> &#123;<br><span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">Box</span>&lt;List&gt;),<br>Nil,<br>&#125;<br><br><span class="hljs-keyword">use</span> List::&#123;Cons, Nil&#125;; <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">list</span> = <span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">1</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">2</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">Cons</span>(<span class="hljs-number">3</span>, <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Nil))))));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h4><p>在 Rust 中，想实现不同类型组成的数组只有两个办法：枚举和特征对象，前者限制较多，因此后者往往是最常用的解决办法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Draw</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Button</span> &#123;<br>    id: <span class="hljs-type">u32</span>,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Draw</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;这是屏幕上第&#123;&#125;号按钮&quot;</span>, <span class="hljs-keyword">self</span>.id)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Select</span> &#123;<br>    id: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Draw</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Select</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;这个选择框贼难用&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.id)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">elems</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Draw&gt;&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Button &#123; id: <span class="hljs-number">1</span> &#125;), <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Select &#123; id: <span class="hljs-number">2</span> &#125;)];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">e</span> <span class="hljs-keyword">in</span> elems &#123;<br>        e.<span class="hljs-title function_ invoke__">draw</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码将不同类型的 <code>Button</code> 和 <code>Select</code> 包装成 <code>Draw</code> 特征的特征对象，放入一个数组中，<code>Box&lt;dyn Draw&gt;</code> 就是特征对象。</p><p>其实，特征也是 DST 类型，而特征对象在做的就是将 DST 类型转换为固定大小类型。</p><h3 id="Box-的优缺点"><a href="#Box-的优缺点" class="headerlink" title="Box 的优缺点"></a>Box 的优缺点</h3><ul><li><p>优点</p><ul><li>提供堆内存分配，支持复杂数据结构。</li><li>与 Rust 的所有权系统完美集成，确保内存安全。</li><li>动态分配对象，实现类型擦除。</li></ul></li><li><p>缺点</p><ul><li>需要堆内存分配和释放，可能带来性能开销。</li><li>不适合需要频繁分配和释放的场景。</li></ul></li></ul><h2 id="Deref-解引用特征"><a href="#Deref-解引用特征" class="headerlink" title="Deref 解引用特征"></a>Deref 解引用特征</h2><p><code>Deref</code> 可以说是 Rust 中最常见的隐式类型转换，而且它可以连续的实现如 <code>Box&lt;String&gt; -&gt; String -&gt; &amp;str</code> 的隐式转换，只要链条上的类型实现了 <code>Deref</code> 特征。</p><h3 id="通过-获取引用背后的值"><a href="#通过-获取引用背后的值" class="headerlink" title="通过 * 获取引用背后的值"></a>通过 * 获取引用背后的值</h3><p>常规引用是一个指针类型，包含了目标数据存储的内存地址。对常规引用使用 <code>*</code> 操作符，就可以通过解引用的方式获取到内存地址对应的数据值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;x;<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>y</code> 就是一个常规引用，包含了值 <code>5</code> 所在的内存地址，然后通过解引用 <code>*y</code>，我们获取到了值 <code>5</code>。</p><h3 id="智能指针解引用"><a href="#智能指针解引用" class="headerlink" title="智能指针解引用"></a>智能指针解引用</h3><p>实现 <code>Deref</code> 后的智能指针结构体，就可以像普通引用一样，通过 <code>*</code> 进行解引用，例如 <code>Box&lt;T&gt;</code> 智能指针：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = *x + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>智能指针 <code>x</code> 被 <code>*</code> 解引用为 <code>i32</code> 类型的值 <code>1</code>，然后再进行求和。</p><h4 id="定义自己的智能指针"><a href="#定义自己的智能指针" class="headerlink" title="定义自己的智能指针"></a>定义自己的智能指针</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt;(T);  <br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br><span class="hljs-title function_ invoke__">MyBox</span>(x)<br>&#125;<br>&#125; <br><br><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target &#123;<br>&amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当解引用 <code>MyBox</code> 智能指针时，返回元组结构体中的元素 <code>&amp;self.0</code>，有几点要注意的：</p><ul><li>在 <code>Deref</code> 特征中声明了关联类型 <code>Target</code>，在之前章节中介绍过，关联类型主要是为了提升代码可读性</li><li><code>deref</code> 返回的是一个常规引用，可以被 <code>*</code> 进行解引用</li></ul><h3 id="Deref-规则总结"><a href="#Deref-规则总结" class="headerlink" title="Deref 规则总结"></a><code>Deref</code> 规则总结</h3><h4 id="引用归一化"><a href="#引用归一化" class="headerlink" title="引用归一化"></a>引用归一化</h4><p>Rust 编译器实际上只能对 <code>&amp;v</code> 形式的引用进行解引用操作，那么问题来了，如果是一个智能指针或者 <code>&amp;&amp;&amp;&amp;v</code> 类型的呢？ 该如何对这两个进行解引用？</p><p>答案是：Rust 会在解引用时自动把智能指针和 <code>&amp;&amp;&amp;&amp;v</code> 做引用归一化操作，转换成 <code>&amp;v</code> 形式，最终再对 <code>&amp;v</code> 进行解引用：</p><ul><li>把智能指针（比如在库中定义的，Box、Rc、Arc、Cow 等）从结构体脱壳为内部的引用类型，也就是转成结构体内部的 <code>&amp;v</code></li><li>把多重<code>&amp;</code>，例如 <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;v</code>，归一成 <code>&amp;v</code></li></ul><p>关于第二种情况，这么干巴巴的说，也许大家会迷迷糊糊的，我们来看一段标准库源码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: ?<span class="hljs-built_in">Sized</span>&gt; Deref <span class="hljs-keyword">for</span> &amp;T &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        *<span class="hljs-keyword">self</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段源码中，<code>&amp;T</code> 被自动解引用为 <code>T</code>，也就是 <code>&amp;T: Deref&lt;Target=T&gt;</code> 。 按照这个代码，<code>&amp;&amp;&amp;&amp;T</code> 会被自动解引用为 <code>&amp;&amp;&amp;T</code>，然后再自动解引用为 <code>&amp;&amp;T</code>，以此类推， 直到最终变成 <code>&amp;T</code>。</p><h4 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(s: &amp;<span class="hljs-type">str</span>) &#123;&#125;<br><br><span class="hljs-comment">// 由于 String 实现了 Deref&lt;Target=str&gt;</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">owned</span> = <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><br><span class="hljs-comment">// 因此下面的函数可以正常运行：</span><br><span class="hljs-title function_ invoke__">foo</span>(&amp;owned);<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(s: &amp;<span class="hljs-type">str</span>) &#123;&#125;<br><br><span class="hljs-comment">// String 实现了 Deref&lt;Target=str&gt;</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">owned</span> = <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br><span class="hljs-comment">// 且 Rc 智能指针可以被自动脱壳为内部的 `owned` 引用： &amp;String ，然后 &amp;String 再自动解引用为 &amp;str</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">counted</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(owned);<br><br><span class="hljs-comment">// 因此下面的函数可以正常运行:</span><br><span class="hljs-title function_ invoke__">foo</span>(&amp;counted);<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(&amp;<span class="hljs-keyword">self</span>) &#123; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Foo&quot;</span>); &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = &amp;&amp;Foo;<br><br>f.<span class="hljs-title function_ invoke__">foo</span>();<br>(&amp;f).<span class="hljs-title function_ invoke__">foo</span>();<br>(&amp;&amp;f).<span class="hljs-title function_ invoke__">foo</span>();<br>(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).<span class="hljs-title function_ invoke__">foo</span>();<br></code></pre></td></tr></table></figure><h3 id="三种-Deref-转换"><a href="#三种-Deref-转换" class="headerlink" title="三种 Deref 转换"></a>三种 <code>Deref</code> 转换</h3><p>在之前，我们讲的都是不可变的 <code>Deref</code> 转换，实际上 Rust 还支持将一个可变的引用转换成另一个可变的引用以及将一个可变引用转换成不可变的引用，规则如下：</p><ul><li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;T</code> 转换成 <code>&amp;U</code>，也就是我们之前看到的例子</li><li>当 <code>T: DerefMut&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;mut U</code></li><li>当 <code>T: Deref&lt;Target=U&gt;</code>，可以将 <code>&amp;mut T</code> 转换成 <code>&amp;U</code></li></ul><p>来看一个关于 <code>DerefMut</code> 的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    v: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>        MyBox &#123; v: x &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target &#123;<br>        &amp;<span class="hljs-keyword">self</span>.v<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> std::ops::DerefMut;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; DerefMut <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">Self</span>::Target &#123;<br>        &amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.v<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello, &quot;</span>));<br>    <span class="hljs-title function_ invoke__">display</span>(&amp;<span class="hljs-keyword">mut</span> s)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(s: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;world&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码有几点值得注意:</p><ul><li>要实现 <code>DerefMut</code> 必须要先实现 <code>Deref</code> 特征：<code>pub trait DerefMut: Deref</code></li><li><code>T: DerefMut&lt;Target=U&gt;</code> 解读：将 <code>&amp;mut T</code> 类型通过 <code>DerefMut</code> 特征的方法转换为 <code>&amp;mut U</code> 类型，对应上例中，就是将 <code>&amp;mut MyBox&lt;String&gt;</code> 转换为 <code>&amp;mut String</code></li></ul><p>对于上述三条规则中的第三条，它比另外两条稍微复杂了点：Rust 可以把可变引用隐式的转换成不可变引用，但反之则不行。</p><h2 id="Drop-释放资源特征"><a href="#Drop-释放资源特征" class="headerlink" title="Drop 释放资源特征"></a>Drop 释放资源特征</h2><p><code>Drop</code> 可以用于许多方面，来使得资源清理及收尾工作变得方便和安全，甚至可以用其创建我们自己的内存分配器！通过 <code>Drop</code> 特征和 Rust 所有权系统，你无需担心之后的代码清理，Rust 会自动考虑这些问题。</p><p>我们也无需担心意外的清理掉仍在使用的值，这会造成编译器错误：所有权系统确保引用总是有效的，也会确保 <code>drop</code> 只会在值不再被使用时被调用一次。</p><h3 id="一个不简单的-Drop-例子"><a href="#一个不简单的-Drop-例子" class="headerlink" title="一个不简单的 Drop 例子"></a>一个不简单的 Drop 例子</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasDrop1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasDrop2</span>;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">HasDrop1</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping HasDrop1!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">HasDrop2</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping HasDrop2!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HasTwoDrops</span> &#123;<br>    one: HasDrop1,<br>    two: HasDrop2,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">HasTwoDrops</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping HasTwoDrops!&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Foo</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Dropping Foo!&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_x</span> = HasTwoDrops &#123;<br>        two: HasDrop2,<br>        one: HasDrop1,<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_foo</span> = Foo;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Running!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码虽然长，但是目的其实很单纯，就是为了观察不同情况下变量级别的、结构体内部字段的 <code>Drop</code>，有几点值得注意：</p><ul><li><code>Drop</code> 特征中的 <code>drop</code> 方法借用了目标的可变引用，而不是拿走了所有权，这里先设置一个悬念，后边会讲</li><li>结构体中每个字段都有自己的 <code>Drop</code></li></ul><p>来看看输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">Running!<br>Dropping Foo!<br>Dropping HasTwoDrops!<br>Dropping HasDrop1!<br>Dropping HasDrop2!<br></code></pre></td></tr></table></figure><h4 id="Drop-的顺序"><a href="#Drop-的顺序" class="headerlink" title="Drop 的顺序"></a>Drop 的顺序</h4><p>观察以上输出，我们可以得出以下关于 <code>Drop</code> 顺序的结论</p><ul><li><strong>变量级别，按照逆序的方式</strong>，<code>_x</code> 在 <code>_foo</code> 之前创建，因此 <code>_x</code> 在 <code>_foo</code> 之后被 <code>drop</code></li><li><strong>结构体内部，按照顺序的方式</strong>，结构体 <code>_x</code> 中的字段按照定义中的顺序依次 <code>drop</code></li></ul><h3 id="Drop-使用场景"><a href="#Drop-使用场景" class="headerlink" title="Drop 使用场景"></a>Drop 使用场景</h3><ul><li>回收内存资源<blockquote><p>在绝大多数情况下，我们都无需手动去 <code>drop</code> 以回收内存资源，因为 Rust 会自动帮我们完成这些工作，它甚至会对复杂类型的每个字段都单独的调用 <code>drop</code> 进行回收！但是确实有极少数情况，需要你自己来回收资源的，例如文件描述符、网络 socket 等，当这些值超出作用域不再使用时，就需要进行关闭以释放相关的资源，在这些情况下，就需要使用者自己来解决 <code>Drop</code> 的问题。</p></blockquote></li><li>执行一些收尾工作</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 22 生命周期</title>
    <link href="/2024/11/22/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2022%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2024/11/22/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2022%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="悬垂指针和生命周期"><a href="#悬垂指针和生命周期" class="headerlink" title="悬垂指针和生命周期"></a>悬垂指针和生命周期</h2><p>生命周期（lifetime）是一个关键的概念，用于管理内存安全，特别是对于借用（borrowing）的值。生命周期确保了借用的值在被使用期间是有效的，防止出现悬挂指针（dangling pointer）和其他内存安全问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span>;<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>        r = &amp;x;<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码有几点值得注意:</p><ul><li><code>let r;</code> 的声明方式貌似存在使用 <code>null</code> 的风险，实际上，当我们不初始化它就使用时，编译器会给予报错</li><li><code>r</code> 引用了内部花括号中的 <code>x</code> 变量，但是 <code>x</code> 会在内部花括号 <code>&#125;</code> 处被释放，因此回到外部花括号后，<code>r</code> 会引用一个无效的 <code>x</code></li></ul><p>此处 <code>r</code> 就是一个悬垂指针，它引用了提前被释放的变量 <code>x</code>，可以预料到，这段代码会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0597]: `x` does not live long enough // `x` 活得不够久<br>  --&gt; src/main.rs:7:17<br>   |<br>7  |             r = &amp;x;<br>   |                 ^^ borrowed value does not live long enough // 被借用的 `x` 活得不够久<br>8  |         &#125;<br>   |         - `x` dropped here <span class="hljs-keyword">while</span> still borrowed // `x` 在这里被丢弃，但是它依然还在被借用<br>9  |<br>10 |         println!(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r);<br>   |                           - borrow later used here // 对 `x` 的借用在此处被使用<br></code></pre></td></tr></table></figure><h2 id="借用检查"><a href="#借用检查" class="headerlink" title="借用检查"></a>借用检查</h2><p>为了保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span>;                <span class="hljs-comment">// ---------+-- &#x27;a</span><br>                          <span class="hljs-comment">//          |</span><br>    &#123;                     <span class="hljs-comment">//          |</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;        <span class="hljs-comment">// -+-- &#x27;b  |</span><br>        r = &amp;x;           <span class="hljs-comment">//  |       |</span><br>    &#125;                     <span class="hljs-comment">// -+       |</span><br>                          <span class="hljs-comment">//          |</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="hljs-comment">//          |</span><br>&#125;                         <span class="hljs-comment">// ---------+</span><br></code></pre></td></tr></table></figure><p>这段代码和之前的一模一样，唯一的区别在于增加了对变量生命周期的注释。这里，<code>r</code> 变量被赋予了生命周期 <code>&#39;a</code>，<code>x</code> 被赋予了生命周期 <code>&#39;b</code>，从图示上可以明显看出生命周期 <code>&#39;b</code> 比 <code>&#39;a</code> 小很多。</p><p>在编译期，Rust 会比较两个变量的生命周期，结果发现 <code>r</code> 明明拥有生命周期 <code>&#39;a</code>，但是却引用了一个小得多的生命周期 <code>&#39;b</code>，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。</p><p>如果想要编译通过，也很简单，只要 <code>&#39;b</code> 比 <code>&#39;a</code> 大就好。总之，<code>x</code> 变量只要比 <code>r</code> 活得久，那么 <code>r</code> 就能随意引用 <code>x</code> 且不会存在危险：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;            <span class="hljs-comment">// ----------+-- &#x27;b</span><br>                          <span class="hljs-comment">//           |</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = &amp;x;           <span class="hljs-comment">// --+-- &#x27;a  |</span><br>                          <span class="hljs-comment">//   |       |</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="hljs-comment">//   |       |</span><br>                          <span class="hljs-comment">// --+       |</span><br>&#125;                         <span class="hljs-comment">// ----------+</span><br></code></pre></td></tr></table></figure><p>根据之前的结论，我们重新实现了代码，现在 <code>x</code> 的生命周期 <code>&#39;b</code> 大于 <code>r</code> 的生命周期 <code>&#39;a</code>，因此 <code>r</code> 对 <code>x</code> 的引用是安全的。</p><h2 id="生命周期标注语法"><a href="#生命周期标注语法" class="headerlink" title="生命周期标注语法"></a>生命周期标注语法</h2><p>生命周期的语法也颇为与众不同，以 <code>&#39;</code> 开头，名称往往是一个单独的小写字母，大多数人都用 <code>&#39;a</code> 来作为生命周期的名称。 如果是引用类型的参数，那么生命周期会位于引用符号 <code>&amp;</code> 之后，并用一个空格来将生命周期和引用参数分隔开:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust">&amp;<span class="hljs-type">i32</span>        <span class="hljs-comment">// 一个引用</span><br>&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>     <span class="hljs-comment">// 具有显式生命周期的引用</span><br>&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span> <span class="hljs-comment">// 具有显式生命周期的可变引用</span><br></code></pre></td></tr></table></figure><h2 id="生命周期类别"><a href="#生命周期类别" class="headerlink" title="生命周期类别"></a>生命周期类别</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点如下：</p><ul><li>和泛型一样，使用生命周期参数，需要先声明 <code>&lt;&#39;a&gt;</code></li><li><code>x</code>、<code>y</code> 和返回值至少活得和 <code>&#39;a</code> 一样久（因为返回值要么是 <code>x</code>，要么是 <code>y</code>）</li></ul><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>只要为结构体中的<strong>每一个引用标注上生命周期</strong>即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcerpt</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">novel</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Call me Ishmael. Some years ago...&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first_sentence</span> = novel.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = ImportantExcerpt &#123;<br>        part: first_sentence,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">StringOption</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br><span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>),<br><span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h2><blockquote><p><strong>rust编译器为了简化用户的使用，运用了生命周期消除大法，自动推理，无需手动重复添加</strong>。</p></blockquote><p>三条消除规则：</p><ol><li><p><strong>每一个引用参数都会获得独自的生命周期</strong></p><p> 例如一个引用参数的函数就有一个生命周期标注: <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code>，两个引用参数的有两个生命周期标注:<code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code>, 依此类推。</p></li><li><p><strong>若只有一个输入生命周期（函数参数中只有一个引用类型），那么该生命周期会被赋给所有的输出生命周期</strong>，也就是所有返回值的生命周期都等于该输入生命周期</p><p> 例如函数 <code>fn foo(x: &amp;i32) -&gt; &amp;i32</code>，<code>x</code> 参数的生命周期会被自动赋给返回值 <code>&amp;i32</code>，因此该函数等同于 <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code></p></li><li><p><strong>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期</strong></p><p> 拥有 <code>&amp;self</code> 形式的参数，说明该函数是一个 <code>方法</code>，该规则让方法的使用便利度大幅提升。</p></li></ol><h2 id="方法中的生命周期"><a href="#方法中的生命周期" class="headerlink" title="方法中的生命周期"></a>方法中的生命周期</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcerpt</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">level</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中有几点需要注意的：</p><ul><li><code>impl</code> 中必须使用结构体的完整名称，包括 <code>&lt;&#39;a&gt;</code>，因为_生命周期标注也是结构体类型的一部分_！</li><li>方法签名中，往往不需要标注生命周期，得益于生命周期消除的第一和第三规则</li></ul><p>下面的例子展示了第三规则应用的场景（<strong>生命周期约束</strong>）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">announce_and_return_part</span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, announcement: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span><br>    <span class="hljs-keyword">where</span><br>        <span class="hljs-symbol">&#x27;a</span>: <span class="hljs-symbol">&#x27;b</span>,<br>    &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);<br>        <span class="hljs-keyword">self</span>.part<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关键点稍微解释下：</p><ul><li><code>&#39;a: &#39;b</code>，是生命周期约束语法，跟泛型约束非常相似，用于说明 <code>&#39;a</code> 必须比 <code>&#39;b</code> 活得久</li><li>可以把 <code>&#39;a</code> 和 <code>&#39;b</code> 都在同一个地方声明（如上），或者分开声明但通过 <code>where &#39;a: &#39;b</code> 约束生命周期关系</li></ul><h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p>在 Rust 中有一个非常特殊的生命周期，那就是 <code>&#39;static</code>，拥有该生命周期的引用可以和整个程序活得一样久。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;我没啥优点，就是活得久，嘿嘿&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>生命周期 <code>&#39;static</code> 意味着能和程序活得一样久，例如字符串字面量和特征对象</li><li>实在遇到解决不了的生命周期标注问题，可以尝试 <code>T: &#39;static</code>，有时候它会给你奇迹</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 21 特征(Trait)</title>
    <link href="/2024/11/20/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2021%20%E7%89%B9%E5%BE%81(Trait)/"/>
    <url>/2024/11/20/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2021%20%E7%89%B9%E5%BE%81(Trait)/</url>
    
    <content type="html"><![CDATA[<h2 id="特征-Trait"><a href="#特征-Trait" class="headerlink" title="特征 Trait"></a>特征 Trait</h2><p>特征定义了<strong>一组可以被共享的行为，只要实现了特征，你就能使用这组行为</strong>。</p><h3 id="定义特征"><a href="#定义特征" class="headerlink" title="定义特征"></a>定义特征</h3><ul><li>使用 <code>trait</code> 关键字来声明一个特征</li><li><code>Summary</code> 是特征名</li><li>在大括号中定义了该特征的所有方法</li><li>只定义特征方法的签名，而不进行实现，此时方法签名结尾是 <code>;</code>，而不是一个 <code>&#123;&#125;</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="为类型实现特征"><a href="#为类型实现特征" class="headerlink" title="为类型实现特征"></a>为类型实现特征</h3><p>因为特征只定义行为看起来是什么样的，因此我们需要为类型实现具体的特征，定义行为具体是怎么样的。</p><p>首先来为 <code>Post</code> 和 <code>Weibo</code> 实现 <code>Summary</code> 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-keyword">pub</span> title: <span class="hljs-type">String</span>, <span class="hljs-comment">// 标题</span><br>    <span class="hljs-keyword">pub</span> author: <span class="hljs-type">String</span>, <span class="hljs-comment">// 作者</span><br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span>, <span class="hljs-comment">// 内容</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Post</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;文章&#123;&#125;, 作者是&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.title, <span class="hljs-keyword">self</span>.author)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Weibo</span> &#123;<br>    <span class="hljs-keyword">pub</span> username: <span class="hljs-type">String</span>,<br>    <span class="hljs-keyword">pub</span> content: <span class="hljs-type">String</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Weibo</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.username, <span class="hljs-keyword">self</span>.content)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现特征的语法与为结构体、枚举实现方法很像：<code>impl Summary for Post</code>，读作“为 <code>Post</code> 类型实现 <code>Summary</code> 特征”，然后在 <code>impl</code> 的花括号中实现该特征的具体方法。</p><p>接下来就可以在这个类型上调用特征的方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">post</span> = Post&#123;title: <span class="hljs-string">&quot;Rust语言简介&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),author: <span class="hljs-string">&quot;Sunface&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), content: <span class="hljs-string">&quot;Rust棒极了!&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">weibo</span> = Weibo&#123;username: <span class="hljs-string">&quot;sunface&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(),content: <span class="hljs-string">&quot;好像微博没Tweet好用&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()&#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,post.<span class="hljs-title function_ invoke__">summarize</span>());<br>    <span class="hljs-comment">// 输出结果：文章 Rust 语言简介, 作者是Sunface</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,weibo.<span class="hljs-title function_ invoke__">summarize</span>());<br>    <span class="hljs-comment">// 输出结果：sunface发表了微博好像微博没Tweet好用</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特征定义与实现的位置（孤儿规则）"><a href="#特征定义与实现的位置（孤儿规则）" class="headerlink" title="特征定义与实现的位置（孤儿规则）"></a>特征定义与实现的位置（孤儿规则）</h4><p>关于特征实现与定义的位置，有一条非常重要的原则：<strong>如果你想要为类型</strong> <code>A</code> <strong>实现特征</strong> <code>T</code><strong>，那么</strong> <code>A</code> <strong>或者</strong> <code>T</code> <strong>至少有一个是在当前作用域中定义的！</strong></p><p>例如我们可以为上面的 <code>Post</code> 类型实现标准库中的 <code>Display</code> 特征，这是因为 <code>Post</code> 类型定义在当前的作用域中。同时，我们也可以在当前包中为 <code>String</code> 类型实现 <code>Summary</code> 特征，因为 <code>Summary</code> 定义在当前作用域中。</p><p>但是你无法在当前作用域中，为 <code>String</code> 类型实现 <code>Display</code> 特征，因为它们俩都定义在标准库中，其定义所在的位置都不在当前作用域，跟你半毛钱关系都没有，看看就行了。</p><p>该规则被称为<strong>孤儿规则</strong>，可以确保其它人编写的代码不会破坏你的代码，也确保了你不会莫名其妙就破坏了风马牛不相及的代码。</p><h4 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h4><p>你可以在特征中定义具有<strong>默认实现</strong>的方法，这样其它类型无需再实现该方法，或者也可以选择重载该方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;(Read more...)&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面为 <code>Summary</code> 定义了一个默认实现，下面我们编写段代码来测试下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Post</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Weibo</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;发表了微博&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.username, <span class="hljs-keyword">self</span>.content)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Post</code> 选择了默认实现，而 <code>Weibo</code> 重载了该方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">/*--- snip ---*/</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,post.<span class="hljs-title function_ invoke__">summarize</span>());<br>    <span class="hljs-comment">// 输出结果：(Read more...)</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,weibo.<span class="hljs-title function_ invoke__">summarize</span>());<br>    <span class="hljs-comment">// 输出结果：sunface发表了微博好像微博没Tweet好用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>默认实现允许调用相同特征中的其他方法，哪怕这些方法没有默认实现。如此，特征可以提供很多有用的功能而只需要实现指定的一小部分内容。例如，我们可以定义 <code>Summary</code> 特征，使其具有一个需要实现的 <code>summarize_author</code> 方法，然后定义一个 <code>summarize</code> 方法，此方法的默认实现调用 <code>summarize_author</code> 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize_author</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;(Read more from &#123;&#125;...)&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">summarize_author</span>())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了使用 <code>Summary</code>，只需要实现 <code>summarize_author</code> 方法即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Weibo</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize_author</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;@&#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.username)<br>    &#125;<br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;1 new weibo: &#123;&#125;&quot;</span>, weibo.<span class="hljs-title function_ invoke__">summarize</span>());<br></code></pre></td></tr></table></figure><p><code>weibo.summarize()</code> 会先调用 <code>Summary</code> 特征默认实现的 <code>summarize</code> 方法，通过该方法进而调用 <code>Weibo</code> 为 <code>Summary</code> 实现的 <code>summarize_author</code> 方法，最终输出：<code>1 new weibo: (Read more from @horse_ebooks...)</code>。</p><h3 id="使用特征作为函数参数"><a href="#使用特征作为函数参数" class="headerlink" title="使用特征作为函数参数"></a>使用特征作为函数参数</h3><p>之前提到过，特征如果仅仅是用来实现方法，那真的有些大材小用，现在我们来讲下，真正可以让特征大放光彩的地方。</p><p>现在，先定义一个函数，使用特征作为函数参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: &amp;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>impl Summary</code>，只能说想出这个类型的人真的是起名鬼才，简直太贴切了，顾名思义，它的意思是 <strong>实现了<code>Summary</code>特征</strong> 的 <code>item</code> 参数。</p><p>你可以使用任何实现了 <code>Summary</code> 特征的类型作为该函数的参数，同时在函数体内，还可以调用该特征的方法，例如 <code>summarize</code> 方法。具体的说，可以传递 <code>Post</code> 或 <code>Weibo</code> 的实例来作为参数，而其它类如 <code>String</code> 或者 <code>i32</code> 的类型则不能用做该函数的参数，因为它们没有实现 <code>Summary</code> 特征。</p><h3 id="特征约束-trait-bound"><a href="#特征约束-trait-bound" class="headerlink" title="特征约束(trait bound)"></a>特征约束(trait bound)</h3><p>虽然 <code>impl Trait</code> 这种语法非常好理解，但是实际上它只是一个语法糖：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="hljs-title function_ invoke__">summarize</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>真正的完整书写形式如上所述，形如 <code>T: Summary</code> 被称为<strong>特征约束</strong>。</p><p>在简单的场景下 <code>impl Trait</code> 这种语法糖就足够使用，但是对于复杂的场景，特征约束可以让我们拥有更大的灵活性和语法表现能力，例如一个函数接受两个 <code>impl Summary</code> 的参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item1: &amp;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span>, item2: &amp;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>如果函数两个参数是不同的类型，那么上面的方法很好，只要这两个类型都实现了 <code>Summary</code> 特征即可。但是如果我们想要强制函数的两个参数是同一类型呢？上面的语法就无法做到这种限制，此时我们只能使特征约束来实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) &#123;&#125;<br></code></pre></td></tr></table></figure><p>泛型类型 <code>T</code> 说明了 <code>item1</code> 和 <code>item2</code> 必须拥有同样的类型，同时 <code>T: Summary</code> 说明了 <code>T</code> 必须实现 <code>Summary</code> 特征。</p><h4 id="多重约束"><a href="#多重约束" class="headerlink" title="多重约束"></a>多重约束</h4><p>除了单个约束条件，我们还可以指定多个约束条件，例如除了让参数实现 <code>Summary</code> 特征外，还可以让参数实现 <code>Display</code> 特征以控制它的格式化输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: &amp;(<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> + Display)) &#123;&#125;<br></code></pre></td></tr></table></figure><p>除了上述的语法糖形式，还能使用特征约束的形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="where-约束"><a href="#where-约束" class="headerlink" title="where 约束"></a>where 约束</h4><p>当特征约束变得很多时，函数的签名将变得很复杂：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T: Display + <span class="hljs-built_in">Clone</span>, U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>严格来说，上面的例子还是不够复杂，但是我们还是能对其做一些形式上的改进，通过 <code>where</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br>    <span class="hljs-keyword">where</span> T: Display + <span class="hljs-built_in">Clone</span>,<br>          U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="使用特征约束有条件地实现方法或特征"><a href="#使用特征约束有条件地实现方法或特征" class="headerlink" title="使用特征约束有条件地实现方法或特征"></a>使用特征约束有条件地实现方法或特征</h4><p>特征约束，可以让我们在指定类型 + 指定特征的条件下去实现方法，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T, y: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            x,<br>            y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T: Display + <span class="hljs-built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">cmp_display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.x &gt;= <span class="hljs-keyword">self</span>.y &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.y);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>cmp_display</code> 方法，并不是所有的 <code>Pair&lt;T&gt;</code> 结构体对象都可以拥有，只有 <code>T</code> 同时实现了 <code>Display + PartialOrd</code> 的 <code>Pair&lt;T&gt;</code> 才可以拥有此方法。 该函数可读性会更好，因为泛型参数、参数、返回值都在一起，可以快速的阅读，同时每个泛型参数的特征也在新的代码行中通过<strong>特征约束</strong>进行了约束。</p><p><strong>也可以有条件地实现特征</strong>，例如，标准库为任何实现了 <code>Display</code> 特征的类型实现了 <code>ToString</code> 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: Display&gt; <span class="hljs-built_in">ToString</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以对任何实现了 <code>Display</code> 特征的类型调用由 <code>ToString</code> 定义的 <code>to_string</code> 方法。例如，可以将整型转换为对应的 <code>String</code> 值，因为整型实现了 <code>Display</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-number">3</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br></code></pre></td></tr></table></figure><h3 id="通过-derive-派生特征"><a href="#通过-derive-派生特征" class="headerlink" title="通过 derive 派生特征"></a>通过 derive 派生特征</h3><p>在本书中，形如 <code>#[derive(Debug)]</code> 的代码已经出现了很多次，这种是一种特征派生语法，被 <code>derive</code> 标记的对象会自动实现对应的默认特征代码，继承相应的功能。</p><p>例如 <code>Debug</code> 特征，它有一套自动实现的默认代码，当你给一个结构体标记后，就可以使用 <code>println!(&quot;&#123;:?&#125;&quot;, s)</code> 的形式打印该结构体的对象。</p><p>再如 <code>Copy</code> 特征，它也有一套自动实现的默认代码，当标记到一个类型上时，可以让这个类型自动实现 <code>Copy</code> 特征，进而可以调用 <code>copy</code> 方法，进行自我复制。</p><p>总之，<code>derive</code> 派生出来的是 Rust 默认给我们提供的特征，在开发过程中极大的简化了自己手动实现相应特征的需求，当然，如果你有特殊的需求，还可以自己手动重载该实现。</p><p>详细的 <code>derive</code> 列表参见<a href="https://course.rs/appendix/derive.html">附录-派生特征</a>。</p><h2 id="todo：特征对象"><a href="#todo：特征对象" class="headerlink" title="todo：特征对象"></a>todo：特征对象</h2><h2 id="深入了解特征"><a href="#深入了解特征" class="headerlink" title="深入了解特征"></a>深入了解特征</h2><h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p><strong>关联类型(<em>associated types</em>)</strong> 是泛型的特殊形式，用 <code>type</code> 关键字在特征定义中声明一个类型占位符，这样就可以在特征的方法签名中使用该类型，特征实现时会为类型占位符指定相应的具体类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是标准库中的迭代器特征 <code>Iterator</code>，它有一个 <code>Item</code> 关联类型，用于替代遍历的值的类型。<code>next</code> 方法也返回了一个 <code>Item</code> 类型，不过使用 <code>Option</code> 枚举进行了包裹，假如迭代器中的值是 <code>i32</code> 类型，那么调用 <code>next</code> 方法就将获取一个 <code>Option&lt;i32&gt;</code> 的值。</p><p> <strong><code>Self</code> 用来指代当前调用者的具体类型，那么 <code>Self::Item</code> 就用来指代该类型实现中定义的 <code>Item</code> 类型</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>        <span class="hljs-comment">// --snip--</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Counter&#123;..&#125;<br>    c.<span class="hljs-title function_ invoke__">next</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>我们为 <code>Counter</code> 类型实现了 <code>Iterator</code> 特征，变量 <code>c</code> 是特征 <code>Iterator</code> 的实例，也是 <code>next</code> 方法的调用者。 结合之前的黑体内容可以得出：对于 <code>next</code> 方法而言，<code>Self</code> 是调用者 <code>c</code> 的具体类型： <code>Counter</code>，而 <code>Self::Item</code> 是 <code>Counter</code> 中定义的 <code>Item</code> 类型: <code>u32</code>。</p><p>如果采用泛型实现，则必须在每一个实现中标注类型，因为也可以实现 <code>Iterator&lt;String&gt; for Counter</code>，这样就可能有多个对 <code>Counter</code> 的 <code>Iterator</code> 实现。换句话说，当特征有泛型参数时，可以多次实现这个特征，每次需改变泛型参数的具体类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-type">u32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt; &#123;<br>        <span class="hljs-comment">// --snip--</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-type">String</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">String</span>&gt; &#123;<br>        <span class="hljs-comment">// --snip--</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不仅如此，特征定义中使用泛型，需要在所有地方都写 <code>Iterator&lt;&gt;</code>，影响可读性：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Container</span>&lt;A,B&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>,a: A,b: B) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">difference</span>&lt;A,B,C&gt;(container: &amp;C) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br>  <span class="hljs-keyword">where</span><br>    C : Container&lt;A,B&gt; <br>&#123;<br>        <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用关联类型，将得到可读性好得多的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Container</span>&#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">A</span>;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">B</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">contains</span>(&amp;<span class="hljs-keyword">self</span>, a: &amp;<span class="hljs-keyword">Self</span>::A, b: &amp;<span class="hljs-keyword">Self</span>::B) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">difference</span>&lt;C: Container&gt;(container: &amp;C) &#123;<br>        <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="默认泛型类型参数"><a href="#默认泛型类型参数" class="headerlink" title="默认泛型类型参数"></a>默认泛型类型参数</h3><p><strong>默认类型参数(<em>default type parameters</em>)</strong> 可以为泛型类型指定一个默认的具体类型，如果默认类型就足够的话，这消除了为具体类型实现特征的需要，为泛型类型指定默认类型的语法是在声明泛型类型时使用 <code>&lt;PlaceholderType=ConcreteType&gt;</code>。</p><p>例如标准库中的 <code>std::ops::Add</code> 特征：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Add</span>&lt;RHS=<span class="hljs-keyword">Self</span>&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span>;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, rhs: RHS) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>::Output;<br>&#125;<br></code></pre></td></tr></table></figure><p>它有一个泛型参数 <code>RHS</code>，但是与我们以往的用法不同，这里它给 <code>RHS</code> 一个默认值，也就是当用户不指定 <code>RHS</code> 时，默认使用两个同样类型的值进行相加，然后返回一个关联类型 <code>Output</code>。</p><p>可能上面那段不太好理解，下面我们用代码来举例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-meta">#[derive(Debug, PartialEq)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Point;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Point) <span class="hljs-punctuation">-&gt;</span> Point &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x + other.x,<br>            y: <span class="hljs-keyword">self</span>.y + other.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(Point &#123; x: <span class="hljs-number">1</span>, y: <span class="hljs-number">0</span> &#125; + Point &#123; x: <span class="hljs-number">2</span>, y: <span class="hljs-number">3</span> &#125;,<br>               Point &#123; x: <span class="hljs-number">3</span>, y: <span class="hljs-number">3</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码主要干了一件事，就是为 <code>Point</code> 结构体提供 <code>+</code> 的能力，这就是<strong>运算符重载</strong>，不过 Rust 并不支持创建自定义运算符，你也无法为所有运算符进行重载，目前来说，只有定义在 <code>std::ops</code> 中的运算符才能进行重载。</p><p>跟 <code>+</code> 对应的特征是 <code>std::ops::Add</code>，我们在之前也看过它的定义 <code>trait Add&lt;RHS=Self&gt;</code>，但是上面的例子中并没有为 <code>Point</code> 实现 <code>Add&lt;RHS&gt;</code> 特征，而是实现了 <code>Add</code> 特征（没有默认泛型类型参数），这意味着我们使用了 <code>RHS</code> 的默认类型，也就是 <code>Self</code>。换句话说，我们这里定义的是两个相同的 <code>Point</code> 类型相加，因此无需指定 <code>RHS</code>。</p><p>与上面的例子相反，下面的例子，我们来创建两个不同类型的相加：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Add;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Millimeters</span>(<span class="hljs-type">u32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Meters</span>(<span class="hljs-type">u32</span>);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Add</span>&lt;Meters&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Millimeters</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Output</span> = Millimeters;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(<span class="hljs-keyword">self</span>, other: Meters) <span class="hljs-punctuation">-&gt;</span> Millimeters &#123;<br>        <span class="hljs-title function_ invoke__">Millimeters</span>(<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span> + (other.<span class="hljs-number">0</span> * <span class="hljs-number">1000</span>))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，是进行 <code>Millimeters + Meters</code> 两种数据类型的 <code>+</code> 操作，因此此时不能再使用默认的 <code>RHS</code>，否则就会变成 <code>Millimeters + Millimeters</code> 的形式。使用 <code>Add&lt;Meters&gt;</code> 可以将 <code>RHS</code> 指定为 <code>Meters</code>，那么 <code>fn add(self, rhs: RHS)</code> 自然而言的变成了 <code>Millimeters</code> 和 <code>Meters</code> 的相加。</p><p>默认类型参数主要用于两个方面：</p><ol><li>减少实现的样板代码</li><li>扩展类型但是无需大幅修改现有的代码</li></ol><p>之前的例子就是第一点，虽然效果也就那样。在 <code>+</code> 左右两边都是同样类型时，只需要 <code>impl Add</code> 即可，否则你需要 <code>impl Add&lt;SOME_TYPE&gt;</code>，嗯，会多写几个字:)</p><p>对于第二点，也很好理解，如果你在一个复杂类型的基础上，新引入一个泛型参数，可能需要修改很多地方，但是如果新引入的泛型参数有了默认类型，情况就会好很多，添加泛型参数后，使用这个类型的代码需要逐个在类型提示部分添加泛型参数，就很麻烦；但是有了默认参数（且默认参数取之前的实现里假设的值的情况下）之后，原有的使用这个类型的代码就不需要做改动了。</p><h3 id="完全限定语法"><a href="#完全限定语法" class="headerlink" title="完全限定语法"></a>完全限定语法</h3><p>Rust 既不能避免一个 trait 与另一个 trait 拥有相同名称的方法，也不能阻止为同一类型同时实现这两个 trait，甚至直接在类型上实现开始已经有的同名方法也是可能的。</p><p>完全限定语法为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">&lt;Type <span class="hljs-keyword">as</span> Trait&gt;::<span class="hljs-title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);<br></code></pre></td></tr></table></figure><p>上面定义中，第一个参数是方法接收器 <code>receiver</code> （三种 <code>self</code>），只有方法才拥有，例如关联函数就没有 <code>receiver</code>。</p><p>完全限定语法可以用于任何函数或方法调用，Rust 编译器能根据上下文自动推导出调用的路径，因此大多数时候，我们都无需使用完全限定语法。</p><h3 id="特征定义中的特征约束"><a href="#特征定义中的特征约束" class="headerlink" title="特征定义中的特征约束"></a>特征定义中的特征约束</h3><p>有时，我们会需要让某个特征 A 能使用另一个特征 B 的功能(另一种形式的特征约束)，这种情况下，不仅仅要为类型实现特征 A，还要为类型实现特征 B 才行，这就是基特征( super trait )。</p><p>例如有一个特征 <code>OutlinePrint</code>，它有一个方法，能够对当前的实现类型进行格式化输出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">OutlinePrint</span>: Display &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">outline_print</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">output</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = output.<span class="hljs-title function_ invoke__">len</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">4</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*&#123;&#125;*&quot;</span>, <span class="hljs-string">&quot; &quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;* &#123;&#125; *&quot;</span>, output);<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;*&#123;&#125;*&quot;</span>, <span class="hljs-string">&quot; &quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>.<span class="hljs-title function_ invoke__">repeat</span>(len + <span class="hljs-number">4</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>OutlinePrint: Display</code> 语法表示：如果你想要实现 <code>OutlinePrint</code> 特征，首先你需要实现 <code>Display</code> 特征。假如没有这个特征约束，那么编译器会报错，<code>self.to_string</code> 方法无法调用。</p><h3 id="在外部类型上实现外部特征-newtype"><a href="#在外部类型上实现外部特征-newtype" class="headerlink" title="在外部类型上实现外部特征(newtype)"></a>在外部类型上实现外部特征(newtype)</h3><p><strong>newtype 模式</strong> 可以用来绕过孤儿规则：就是为一个元组结构体创建新类型。该元组结构体封装有一个字段，该字段就是希望实现特征的具体类型。</p><p>该封装类型是本地的，因此我们可以为此类型实现外部的特征。</p><p><code>newtype</code> 不仅仅能实现以上的功能，而且它在运行时没有任何性能损耗，因为在编译期，该类型会被自动忽略。</p><p>下面来看一个例子，我们有一个动态数组类型： <code>Vec&lt;T&gt;</code>，它定义在标准库中，还有一个特征 <code>Display</code>，它也定义在标准库中，如果没有 <code>newtype</code>，我们是无法为 <code>Vec&lt;T&gt;</code> 实现 <code>Display</code> 的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>(<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;[&#123;&#125;]&quot;</span>, <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">join</span>(<span class="hljs-string">&quot;, &quot;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">w</span> = <span class="hljs-title function_ invoke__">Wrapper</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>), <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;world&quot;</span>)]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;w = &#123;&#125;&quot;</span>, w);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>struct Wrapper(Vec&lt;String&gt;)</code> 就是一个元组结构体，它定义了一个新类型 <code>Wrapper</code>，代码很简单，相信大家也很容易看懂。</p><p>既然 <code>new type</code> 有这么多好处，它有没有不好的地方呢？答案是肯定的。注意到我们怎么访问里面的数组吗？<code>self.0.join(&quot;, &quot;)</code>，是的，很啰嗦，因为需要先从 <code>Wrapper</code> 中取出数组: <code>self.0</code>，然后才能执行 <code>join</code> 方法。</p><p>类似的，任何数组上的方法，你都无法直接调用，需要先用 <code>self.0</code> 取出数组，然后再进行调用。</p><p>Rust 提供了一个特征叫 <a href="https://course.rs/advance/smart-pointer/deref.html"><code>Deref</code></a>，实现该特征后，可以自动做一层类似类型转换的操作，可以将 <code>Wrapper</code> 变成 <code>Vec&lt;String&gt;</code> 来使用。这样就会像直接使用数组那样去使用 <code>Wrapper</code>，而无需为每一个操作都添加上 <code>self.0</code>。</p><p>同时，如果不想 <code>Wrapper</code> 暴露底层数组的所有方法，我们还可以为 <code>Wrapper</code> 去重载这些方法，实现隐藏的目的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 20 泛型(Generics)</title>
    <link href="/2024/11/19/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2020%20%E6%B3%9B%E5%9E%8B(Generics)/"/>
    <url>/2024/11/19/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2020%20%E6%B3%9B%E5%9E%8B(Generics)/</url>
    
    <content type="html"><![CDATA[<p>泛型其实是一种多态。泛型主要目的是为程序员提供编程的便利，减少代码的臃肿，同时可以极大地丰富语言本身的表达能力。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_i8</span>(a:<span class="hljs-type">i8</span>, b:<span class="hljs-type">i8</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i8</span> &#123;<br>    a + b<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_i32</span>(a:<span class="hljs-type">i32</span>, b:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    a + b<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_f64</span>(a:<span class="hljs-type">f64</span>, b:<span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add_i8</span>(<span class="hljs-number">2i8</span>, <span class="hljs-number">3i8</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add_i32</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add_f64</span>(<span class="hljs-number">1.23</span>, <span class="hljs-number">1.23</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型参数改造以上代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>&lt;T&gt;(a:T, b:T) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    a + b<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add i8: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">2i8</span>, <span class="hljs-number">3i8</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add i32: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;add f64: &#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1.23</span>, <span class="hljs-number">1.23</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型详解"><a href="#泛型详解" class="headerlink" title="泛型详解"></a>泛型详解</h2><p>上面代码的 <code>T</code> 就是<strong>泛型参数</strong>，实际上在 Rust 中，泛型参数的名称你可以任意起，但是出于惯例，我们都用 <code>T</code> （<code>T</code> 是 <code>type</code> 的首字母）来作为首选，这个名称越短越好，除非需要表达含义，否则一个字母是最完美的。</p><p>使用泛型参数，有一个先决条件，必需在使用前对其进行声明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>&lt;T&gt;(a:T, b:T) <span class="hljs-punctuation">-&gt;</span> T &#123;&#125;<br></code></pre></td></tr></table></figure><p>运行它，会得到以下的报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0369]: cannot add `T` to `T` // 无法将 `T` 类型跟 `T` 类型进行相加<br> --&gt; src/main.rs:2:7<br>  |<br>2 |     a + b<br>  |     - ^ - T<br>  |     |<br>  |     T<br>  |<br><span class="hljs-built_in">help</span>: consider restricting <span class="hljs-built_in">type</span> parameter `T`<br>  |<br>1 | fn add&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) -&gt; T &#123;<br>  |         +++++++++++++++++++++++++++<br></code></pre></td></tr></table></figure><p>不是所有 <code>T</code> 类型都能进行相加操作，编译器建议我们给 <code>T</code> 添加一个类型限制：使用 <code>std::ops::Add&lt;Output = T&gt;</code> 特征（Trait）对 <code>T</code> 进行限制，该特征的目的就是让<strong>类型实现可相加的功能</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>&lt;T: std::ops::Add&lt;Output = T&gt;&gt;(a:T, b:T) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    a + b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体中使用泛型"><a href="#结构体中使用泛型" class="headerlink" title="结构体中使用泛型"></a>结构体中使用泛型</h2><p>结构体中的字段类型也可以用泛型来定义，下面代码定义了一个坐标点 <code>Point</code>，它可以存放任何类型的坐标值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">integer</span> = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">float</span> = Point &#123; x: <span class="hljs-number">1.0</span>, y: <span class="hljs-number">4.0</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有两点需要特别的注意：</p><ul><li><strong>提前声明</strong>，跟泛型函数定义类似，首先我们在使用泛型参数之前必需要进行声明 <code>Point&lt;T&gt;</code>，接着就可以在结构体的字段类型中使用 <code>T</code> 来替代具体的类型</li><li><strong>x 和 y 是相同的类型</strong></li></ul><p>如果想让 <code>x</code> 和 <code>y</code> 既能类型相同，又能类型不同，就需要使用不同的泛型参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T,U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point&#123;x: <span class="hljs-number">1</span>, y :<span class="hljs-number">1.1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举中使用泛型"><a href="#枚举中使用泛型" class="headerlink" title="枚举中使用泛型"></a>枚举中使用泛型</h2><p>Rust 中使用最广泛的枚举<code>Option</code> 和 <code>Result</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Option&lt;T&gt;</code> 是一个拥有泛型 <code>T</code> 的枚举类型，它第一个成员是 <code>Some(T)</code>，存放了一个类型为 <code>T</code> 的值。得益于泛型的引入，我们可以在任何一个需要返回值的函数中，去使用 <code>Option&lt;T&gt;</code> 枚举类型来做为返回值，用于返回一个任意类型的值 <code>Some(T)</code>，或者没有值 <code>None</code>。</p><p><code>Result</code> 关注的主要是值的正确性。如果函数正常运行，则最后返回一个 <code>Ok(T)</code>，<code>T</code> 是函数具体的返回值类型，如果函数异常运行，则返回一个 <code>Err(E)</code>，<code>E</code> 是错误类型。</p><h2 id="方法中使用泛型"><a href="#方法中使用泛型" class="headerlink" title="方法中使用泛型"></a>方法中使用泛型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T&gt; &#123;<br>    x: T,<br>    y: T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">x</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="hljs-title function_ invoke__">x</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>使用泛型参数前，依然需要提前声明：<code>impl&lt;T&gt;</code>，只有提前声明了，我们才能在<code>Point&lt;T&gt;</code>中使用它，这样 Rust 就知道 <code>Point</code> 的尖括号中的类型是泛型而不是具体类型。需要注意的是，这里的 <code>Point&lt;T&gt;</code> 不再是泛型声明，而是一个完整的结构体类型，因为我们定义的结构体就是 <code>Point&lt;T&gt;</code> 而不再是 <code>Point</code>。</p><p>除了结构体中的泛型参数，我们还能在该结构体的方法中定义额外的泛型参数，就跟泛型函数一样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T, U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mixup</span>&lt;V, W&gt;(<span class="hljs-keyword">self</span>, other: Point&lt;V, W&gt;) <span class="hljs-punctuation">-&gt;</span> Point&lt;T, W&gt; &#123;<br>        Point &#123;<br>            x: <span class="hljs-keyword">self</span>.x,<br>            y: other.y,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = Point &#123; x: <span class="hljs-number">5</span>, y: <span class="hljs-number">10.4</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = Point &#123; x: <span class="hljs-string">&quot;Hello&quot;</span>, y: <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p3</span> = p1.<span class="hljs-title function_ invoke__">mixup</span>(p2);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;p3.x = &#123;&#125;, p3.y = &#123;&#125;&quot;</span>, p3.x, p3.y);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中，<code>T,U</code> 是定义在结构体 <code>Point</code> 上的泛型参数，<code>V,W</code> 是单独定义在方法 <code>mixup</code> 上的泛型参数，它们并不冲突，说白了，你可以理解为，一个是结构体泛型，一个是函数泛型。</p><h2 id="const-泛型（Rust-1-51-版本引入的重要特性）"><a href="#const-泛型（Rust-1-51-版本引入的重要特性）" class="headerlink" title="const 泛型（Rust 1.51 版本引入的重要特性）"></a>const 泛型（Rust 1.51 版本引入的重要特性）</h2><p> const 泛型，也就是针对值的泛型，正好可以用于处理数组长度的问题：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display_array</span>&lt;T: std::fmt::<span class="hljs-built_in">Debug</span>, <span class="hljs-keyword">const</span> N: <span class="hljs-type">usize</span>&gt;(arr: [T; N]) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, arr);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(arr);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    <span class="hljs-title function_ invoke__">display_array</span>(arr);<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，我们定义了一个类型为 <code>[T; N]</code> 的数组，其中 <code>T</code> 是一个基于类型的泛型参数，这个和之前讲的泛型没有区别，而重点在于 <code>N</code> 这个泛型参数，它是一个基于值的泛型参数！因为它用来替代的是数组的长度。</p><p><code>N</code> 就是 const 泛型，定义的语法是 <code>const N: usize</code>，表示 const 泛型 <code>N</code> ，它基于的值类型是 <code>usize</code>。</p><h2 id="泛型的性能"><a href="#泛型的性能" class="headerlink" title="泛型的性能"></a>泛型的性能</h2><p>在 Rust 中泛型是零成本的抽象，意味着你在使用泛型时，完全不用担心性能上的问题。</p><p>但是任何选择都是权衡得失的，既然我们获得了性能上的巨大优势，那么又失去了什么呢？Rust 是在编译期为泛型对应的多个类型，生成各自的代码，因此损失了编译速度和增大了最终生成文件的大小。</p><p>具体来说：</p><p>Rust 通过在编译时进行泛型代码的 <strong>单态化</strong>(<em>monomorphization</em>)来保证效率。单态化是一个通过填充编译时使用的具体类型，将通用代码转换为特定代码的过程。</p><p>编译器所做的工作正好与我们创建泛型函数的步骤相反，编译器寻找所有泛型代码被调用的位置并针对具体类型生成代码。</p><p>让我们看看一个使用标准库中 <code>Option</code> 枚举的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">integer</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">float</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5.0</span>);<br></code></pre></td></tr></table></figure><p>当 Rust 编译这些代码的时候，它会进行单态化。编译器会读取传递给 <code>Option&lt;T&gt;</code> 的值并发现有两种 <code>Option&lt;T&gt;</code>：一种对应 <code>i32</code> 另一种对应 <code>f64</code>。为此，它会将泛型定义 <code>Option&lt;T&gt;</code> 展开为 <code>Option_i32</code> 和 <code>Option_f64</code>，接着将泛型定义替换为这两个具体的定义。</p><p>编译器生成的单态化版本的代码看起来像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option_i32</span> &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">i32</span>),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option_f64</span> &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">f64</span>),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">integer</span> = Option_i32::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">float</span> = Option_f64::<span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以使用泛型来编写不重复的代码，而 Rust 将会为每一个实例编译其特定类型的代码。这意味着在使用泛型时没有运行时开销；当代码运行，它的执行效率就跟好像手写每个具体定义的重复代码一样。这个单态化过程正是 Rust 泛型在运行时极其高效的原因。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 19 包和模块</title>
    <link href="/2024/11/18/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2019%20%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/"/>
    <url>/2024/11/18/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2019%20%E5%8C%85%E5%92%8C%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>Rust 为我们提供了强大的包管理工具：</p><ul><li>项目(Package)：可以用来构建、测试和分享包</li><li>工作空间(WorkSpace)：对于大型项目，可以进一步将多个包联合在一起，组织成工作空间</li><li>包(Crate)：一个由多个模块组成的树形结构，可以作为三方库进行分发，也可以生成可执行文件进行运行</li><li>模块(Module)：可以一个文件多个模块，也可以一个文件一个模块，模块可以被认为是真实项目中的代码组织单元</li></ul><h2 id="包-Crate"><a href="#包-Crate" class="headerlink" title="包 Crate"></a>包 Crate</h2><p>包是一个独立的可编译单元，它编译后会生成一个可执行文件或者一个库。</p><p>一个包会将相关联的功能打包在一起，使得该功能可以很方便的在多个项目中分享。</p><h2 id="项目-Package"><a href="#项目-Package" class="headerlink" title="项目 Package"></a>项目 Package</h2><p><code>Package</code> 就是一个项目，因此它包含有独立的 <code>Cargo.toml</code> 文件，以及因为功能性被组织在一起的一个或多个包。一个 <code>Package</code> 只能包含<strong>一个</strong>库(library)类型的包，但是可以包含<strong>多个</strong>二进制可执行类型的包。</p><h3 id="二进制-Package"><a href="#二进制-Package" class="headerlink" title="二进制 Package"></a>二进制 Package</h3><p>创建一个二进制 <code>Package</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cargo new my-project<br></code></pre></td></tr></table></figure><p>文件目录结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">├── Cargo.lock<br>├── Cargo.toml<br>└── src<br> └── main.rs<br></code></pre></td></tr></table></figure><p> Cargo 有一个惯例：**<code>src/main.rs</code> 是二进制包的根文件，该二进制包的包名跟所属 <code>Package</code> 相同，在这里都是 <code>my-project</code>**，所有的代码执行都从该文件中的 <code>fn main()</code> 函数开始。 </p><h3 id="库-Package"><a href="#库-Package" class="headerlink" title="库 Package"></a>库 Package</h3><p>创建一个库类型的 <code>Package</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo new my-lib --lib<br></code></pre></td></tr></table></figure><p>文件目录结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">├── Cargo.lock<br>├── Cargo.toml<br>└── src<br>    └── lib.rs<br></code></pre></td></tr></table></figure><p>库类型的 <code>Package</code> 只能作为三方库被其它项目引用，而不能独立运行，该包的根文件是 <code>src/lib.rs</code>，只有之前的二进制 <code>Package</code> 才可以运行。</p><h3 id="典型的-Package-结构"><a href="#典型的-Package-结构" class="headerlink" title="典型的 Package 结构"></a>典型的 Package 结构</h3><p>一个真实项目中典型的 <code>Package</code>，会包含多个二进制包，这些包文件被放在 <code>src/bin</code> 目录下，每一个文件都是独立的二进制包，同时也会包含一个库包，该包只能存在一个 <code>src/lib.rs</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">.<br>├── Cargo.toml<br>├── Cargo.lock<br>├── src<br>│   ├── main.rs<br>│   ├── lib.rs<br>│   └── bin<br>│       └── main1.rs<br>│       └── main2.rs<br>├── tests<br>│   └── some_integration_tests.rs<br>├── benches<br>│   └── simple_bench.rs<br>└── examples<br>    └── simple_example.rs<br></code></pre></td></tr></table></figure><ul><li>唯一库包：<code>src/lib.rs</code></li><li>默认二进制包：<code>src/main.rs</code>，编译后生成的可执行文件与 <code>Package</code> 同名</li><li>其余二进制包：<code>src/bin/main1.rs</code> 和 <code>src/bin/main2.rs</code>，它们会分别生成一个文件同名的二进制可执行文件</li><li>集成测试文件：<code>tests</code> 目录下</li><li>基准性能测试 <code>benchmark</code> 文件：<code>benches</code> 目录下</li><li>项目示例：<code>examples</code> 目录下</li></ul><h2 id="模块-Module"><a href="#模块-Module" class="headerlink" title="模块 Module"></a>模块 Module</h2><p>Rust 的代码构成单元：模块。使用模块可以将包中的代码按照功能性进行重组，最终实现更好的可读性及易用性。同时，我们还能非常灵活地去控制代码的可见性，进一步强化 Rust 的安全性。</p><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><p>使用 <code>cargo new --lib restaurant</code> 创建一个小餐馆，注意，这里创建的是一个库类型的 <code>Package</code>，然后将以下代码放入 <code>src/lib.rs</code> 中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 餐厅前厅，用于吃饭</span><br><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br><br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">seat_at_table</span>() &#123;&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">mod</span> serving &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_order</span>() &#123;&#125;<br><br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">serve_order</span>() &#123;&#125;<br><br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_payment</span>() &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的代码创建了三个模块，有几点需要注意的：</p><ul><li>使用 <code>mod</code> 关键字来创建新模块，后面紧跟着模块名称</li><li>模块可以嵌套，这里嵌套的原因是招待客人和服务都发生在前厅，因此我们的代码模拟了真实场景</li><li>模块中可以定义各种 Rust 类型，例如函数、结构体、枚举、特征等</li><li>所有模块均定义在同一个文件中</li></ul><h3 id="用路径引用模块"><a href="#用路径引用模块" class="headerlink" title="用路径引用模块"></a>用路径引用模块</h3><p>想要调用一个函数，就需要知道它的路径，在 Rust 中，这种路径有两种形式：</p><ul><li><strong>绝对路径</strong>，从包根开始，路径名以包名或者 <code>crate</code> 作为开头</li><li><strong>相对路径</strong>，从当前模块开始，以 <code>self</code>，<code>super</code> 或当前模块的标识符作为开头</li></ul><p>让我们继续经营那个惨淡的小餐馆，这次为它实现一个小功能： 文件名：src&#x2F;lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    <span class="hljs-comment">// 绝对路径</span><br>    crate::front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br><br>    <span class="hljs-comment">// 相对路径</span><br>    front_of_house::hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="绝对还是相对？"><a href="#绝对还是相对？" class="headerlink" title="绝对还是相对？"></a>绝对还是相对？</h4><p>如果只是为了引用到指定模块中的对象，那么两种都可以，但是在实际使用时，需要遵循一个原则：<strong>当代码被挪动位置时，尽量减少引用路径的修改</strong>，相信大家都遇到过，修改了某处代码，导致所有路径都要挨个替换，这显然不是好的路径选择。</p><p>不过，如果不确定哪个好，你可以<strong>考虑优先使用绝对路径</strong>，因为调用的地方和定义的地方往往是分离的，而定义的地方较少会变动。</p><h3 id="代码可见性"><a href="#代码可见性" class="headerlink" title="代码可见性"></a>代码可见性</h3><p>在 Rust 中，<strong>父模块完全无法访问子模块中的私有项，但是子模块却可以访问父模块、父父..模块的私有项</strong>。</p><h4 id="pub-关键字"><a href="#pub-关键字" class="headerlink" title="pub 关键字"></a>pub 关键字</h4><p>类似其它语言的 <code>public</code> 或者 Go 语言中的首字母大写，Rust 提供了 <code>pub</code> 关键字，通过它你可以控制模块和模块中指定项的可见性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结构体和枚举的可见性"><a href="#结构体和枚举的可见性" class="headerlink" title="结构体和枚举的可见性"></a>结构体和枚举的可见性</h4><p>结构体和枚举的成员字段拥有完全不同的可见性：</p><ul><li>将结构体设置为 <code>pub</code>，但它的所有字段依然是私有的</li><li>将枚举设置为 <code>pub</code>，它的所有字段也将对外可见</li></ul><h2 id="使用-use"><a href="#使用-use" class="headerlink" title="使用 use"></a>使用 use</h2><h3 id="基本引入方式"><a href="#基本引入方式" class="headerlink" title="基本引入方式"></a>基本引入方式</h3><h4 id="绝对路径引入模块"><a href="#绝对路径引入模块" class="headerlink" title="绝对路径引入模块"></a>绝对路径引入模块</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> crate::front_of_house::hosting;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>    hosting::<span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="相对路径引入模块"><a href="#相对路径引入模块" class="headerlink" title="相对路径引入模块"></a>相对路径引入模块</h4><p>在下面代码中，我们不仅要使用相对路径进行引入，而且与上面引入 <code>hosting</code> 模块不同，直接引入该模块中的 <code>add_to_waitlist</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> front_of_house &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_to_waitlist</span>() &#123;&#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">use</span> front_of_house::hosting::add_to_waitlist;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">eat_at_restaurant</span>() &#123;<br>    <span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>    <span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>    <span class="hljs-title function_ invoke__">add_to_waitlist</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="引入模块还是函数"><a href="#引入模块还是函数" class="headerlink" title="引入模块还是函数"></a>引入模块还是函数</h4><p>从使用简洁性来说，引入函数自然是更甚一筹，但是在某些时候，引入模块会更好：</p><ul><li>需要引入同一个模块的多个函数</li><li>作用域中存在同名函数</li></ul><p>其实严格来说，对于引用方式并没有需要遵守的惯例，主要还是取决于你的喜好，不过我们建议：<strong>优先使用最细粒度（引入函数、结构体等）的引用方式，如果引起了某种麻烦（例如前面两种情况），再使用引入模块的方式</strong>。</p><h3 id="避免同名引用"><a href="#避免同名引用" class="headerlink" title="避免同名引用"></a>避免同名引用</h3><h4 id="模块-函数"><a href="#模块-函数" class="headerlink" title="模块::函数"></a>模块::函数</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt;<br><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function1</span>() <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function2</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用模块引入的方式，具体的 <code>Result</code> 通过 <code>模块::Result</code> 的方式进行调用。</p><p>可以看出，避免同名冲突的关键，就是使用<strong>父模块的方式来调用</strong>，除此之外，还可以给予引入的项起一个别名。</p><h4 id="as-别名引用"><a href="#as-别名引用" class="headerlink" title="as 别名引用"></a>as 别名引用</h4><p>对于同名冲突问题，还可以使用 <code>as</code> 关键字来解决，它可以赋予引入项一个全新的名称：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-type">Result</span>;<br><span class="hljs-keyword">use</span> std::io::<span class="hljs-type">Result</span> <span class="hljs-keyword">as</span> IoResult;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function1</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span> &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function2</span>() <span class="hljs-punctuation">-&gt;</span> IoResult&lt;()&gt; &#123;<br>    <span class="hljs-comment">// --snip--</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，首先通过 <code>use std::io::Result</code> 将 <code>Result</code> 引入到作用域，然后使用 <code>as</code> 给予它一个全新的名称 <code>IoResult</code>，这样就不会再产生冲突：</p><ul><li><code>Result</code> 代表 <code>std::fmt::Result</code></li><li><code>IoResult</code> 代表 <code>std:io::Result</code></li></ul><h3 id="使用-简化引入方式"><a href="#使用-简化引入方式" class="headerlink" title="使用 {} 简化引入方式"></a>使用 <code>&#123;&#125;</code> 简化引入方式</h3><p>对于以下一行一行的引入方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-keyword">use</span> std::collections::BTreeMap;<br><span class="hljs-keyword">use</span> std::collections::HashSet;<br><br><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">use</span> std::io;<br></code></pre></td></tr></table></figure><p>可以使用 <code>&#123;&#125;</code> 来一起引入进来，在大型项目中，使用这种方式来引入，可以减少大量 <code>use</code> 的使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::&#123;HashMap,BTreeMap,HashSet&#125;;<br><span class="hljs-keyword">use</span> std::&#123;cmp::Ordering, io&#125;;<br></code></pre></td></tr></table></figure><p>对于下面的同时引入模块和模块中的项：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Write;<br><span class="hljs-comment">// 简化成以下：</span><br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Write&#125;;<br></code></pre></td></tr></table></figure><h4 id="self"><a href="#self" class="headerlink" title="self"></a>self</h4><p> <code>self</code> 关键字，用来替代模块自身，结合上一节中的 <code>self</code>，可以得出它在模块中的两个用途：</p><ul><li><code>use self::xxx</code>，表示加载当前模块中的 <code>xxx</code>。此时 <code>self</code> 可省略</li><li><code>use xxx::&#123;self, yyy&#125;</code>，表示，加载当前路径下模块 <code>xxx</code> 本身，以及模块 <code>xxx</code> 下的 <code>yyy</code></li></ul><h3 id="受限的可见性"><a href="#受限的可见性" class="headerlink" title="受限的可见性"></a>受限的可见性</h3><p>如果我们想要让某一项可以在整个包中都可以被使用，那么有两种办法：</p><ul><li>在包根中定义一个非 <code>pub</code> 类型的 <code>X</code>(父模块的项对子模块都是可见的，因此包根中的项对模块树上的所有模块都可见)</li><li>在子模块中定义一个 <code>pub</code> 类型的 <code>Y</code>，同时通过 <code>use</code> 将其引入到包根</li></ul><h4 id="限制可见性语法"><a href="#限制可见性语法" class="headerlink" title="限制可见性语法"></a>限制可见性语法</h4><p><code>pub(crate)</code> 或 <code>pub(in crate::a)</code> 就是限制可见性语法，前者是限制在整个包内可见，后者是通过绝对路径，限制在包内的某个模块内可见，总结一下：</p><ul><li><code>pub</code> 意味着可见性无任何限制</li><li><code>pub(crate)</code> 表示在当前包可见</li><li><code>pub(self)</code> 在当前模块可见</li><li><code>pub(super)</code> 在父模块可见</li><li><code>pub(in &lt;path&gt;)</code> 表示在某个路径代表的模块中可见，其中 <code>path</code> 必须是父模块或者祖先模块</li></ul><p>一个综合例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 一个名为 `my_mod` 的模块</span><br><span class="hljs-keyword">mod</span> my_mod &#123;<br>    <span class="hljs-comment">// 模块中的项默认具有私有的可见性</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">private_function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my_mod::private_function()`&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 `pub` 修饰语来改变默认可见性。</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my_mod::function()`&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在同一模块中，项可以访问其它项，即使它是私有的。</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">indirect_access</span>() &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;</span>);<br>        <span class="hljs-title function_ invoke__">private_function</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 模块也可以嵌套</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> nested &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my_mod::nested::function()`&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">#[allow(dead_code)]</span><br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">private_function</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my_mod::nested::private_function()`&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 `pub(in path)` 语法定义的函数只在给定的路径中可见。</span><br>        <span class="hljs-comment">// `path` 必须是父模块（parent module）或祖先模块（ancestor module）</span><br>        <span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">in</span> crate::my_mod) <span class="hljs-keyword">fn</span> <span class="hljs-title function_">public_function_in_my_mod</span>() &#123;<br>            <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;</span>);<br>            <span class="hljs-title function_ invoke__">public_function_in_nested</span>()<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 `pub(self)` 语法定义的函数则只在当前模块中可见。</span><br>        <span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">self</span>) <span class="hljs-keyword">fn</span> <span class="hljs-title function_">public_function_in_nested</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my_mod::nested::public_function_in_nested&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 使用 `pub(super)` 语法定义的函数只在父模块中可见。</span><br>        <span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">super</span>) <span class="hljs-keyword">fn</span> <span class="hljs-title function_">public_function_in_super_mod</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called my_mod::nested::public_function_in_super_mod&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_public_function_in_my_mod</span>() &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;called `my_mod::call_public_funcion_in_my_mod()`, that\n&gt; &quot;</span>);<br>        nested::<span class="hljs-title function_ invoke__">public_function_in_my_mod</span>();<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>        nested::<span class="hljs-title function_ invoke__">public_function_in_super_mod</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// `pub(crate)` 使得函数只在当前包中可见</span><br>    <span class="hljs-title function_ invoke__">pub</span>(<span class="hljs-keyword">crate</span>) <span class="hljs-keyword">fn</span> <span class="hljs-title function_">public_function_in_crate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my_mod::public_function_in_crate()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 嵌套模块的可见性遵循相同的规则</span><br>    <span class="hljs-keyword">mod</span> private_nested &#123;<br>        <span class="hljs-meta">#[allow(dead_code)]</span><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `my_mod::private_nested::function()`&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;called `function()`&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 模块机制消除了相同名字的项之间的歧义。</span><br>    <span class="hljs-title function_ invoke__">function</span>();<br>    my_mod::<span class="hljs-title function_ invoke__">function</span>();<br><br>    <span class="hljs-comment">// 公有项，包括嵌套模块内的，都可以在父模块外部访问。</span><br>    my_mod::<span class="hljs-title function_ invoke__">indirect_access</span>();<br>    my_mod::nested::<span class="hljs-title function_ invoke__">function</span>();<br>    my_mod::<span class="hljs-title function_ invoke__">call_public_function_in_my_mod</span>();<br><br>    <span class="hljs-comment">// pub(crate) 项可以在同一个 crate 中的任何地方访问</span><br>    my_mod::<span class="hljs-title function_ invoke__">public_function_in_crate</span>();<br><br>    <span class="hljs-comment">// pub(in path) 项只能在指定的模块中访问</span><br>    <span class="hljs-comment">// 报错！函数 `public_function_in_my_mod` 是私有的</span><br>    <span class="hljs-comment">//my_mod::nested::public_function_in_my_mod();</span><br>    <span class="hljs-comment">// 试一试 ^ 取消该行的注释</span><br><br>    <span class="hljs-comment">// 模块的私有项不能直接访问，即便它是嵌套在公有模块内部的</span><br><br>    <span class="hljs-comment">// 报错！`private_function` 是私有的</span><br>    <span class="hljs-comment">//my_mod::private_function();</span><br>    <span class="hljs-comment">// 试一试 ^ 取消此行注释</span><br><br>    <span class="hljs-comment">// 报错！`private_function` 是私有的</span><br>    <span class="hljs-comment">//my_mod::nested::private_function();</span><br>    <span class="hljs-comment">// 试一试 ^ 取消此行的注释</span><br><br>    <span class="hljs-comment">// 报错！ `private_nested` 是私有的</span><br>    <span class="hljs-comment">//my_mod::private_nested::function();</span><br>    <span class="hljs-comment">// 试一试 ^ 取消此行的注释</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 18 返回值与错误处理</title>
    <link href="/2024/11/15/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2018%20%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <url>/2024/11/15/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2018%20%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Option-返回值"><a href="#Option-返回值" class="headerlink" title="Option 返回值"></a>Option 返回值</h2><h3 id="解构-Option"><a href="#解构-Option" class="headerlink" title="解构 Option"></a>解构 Option</h3><p><code>Option</code> 枚举，它用来解决 Rust 中变量是否有值的问题，定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-literal">None</span>,<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>&#125;<br></code></pre></td></tr></table></figure><p>简单解释就是：**一个变量要么有值：<code>Some(T)</code>, 要么为空：<code>None</code>**。</p><blockquote><p>因为 <code>Option</code>，<code>Some</code>，<code>None</code> 都包含在 <code>prelude</code> 中，因此你可以直接通过名称来使用它们，而无需以 <code>Option::Some</code> 这种形式去使用，总之，千万不要因为调用路径变短了，就忘记 <code>Some</code> 和 <code>None</code> 也是 <code>Option</code> 底下的枚举成员！</p></blockquote><h3 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option&lt;T&gt;"></a>匹配 Option&lt;T&gt;</h3><p>使用 <code>Option&lt;T&gt;</code>，是为了从 <code>Some</code> 中取出其内部的 <code>T</code> 值以及处理没有值的情况，为了演示这一点，下面一起来编写一个函数，它获取一个 <code>Option&lt;i32&gt;</code>，如果其中含有一个值，将其加一；如果其中没有值，则函数返回 <code>None</code> 值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_one</span>(x: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;<br>    <span class="hljs-keyword">match</span> x &#123;<br>        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        <span class="hljs-title function_ invoke__">Some</span>(i) =&gt; <span class="hljs-title function_ invoke__">Some</span>(i + <span class="hljs-number">1</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">five</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">six</span> = <span class="hljs-title function_ invoke__">plus_one</span>(five);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">none</span> = <span class="hljs-title function_ invoke__">plus_one</span>(<span class="hljs-literal">None</span>);<br></code></pre></td></tr></table></figure><p><code>plus_one</code> 接受一个 <code>Option&lt;i32&gt;</code> 类型的参数，同时返回一个 <code>Option&lt;i32&gt;</code> 类型的值（这种形式的函数在标准库内随处所见），在该函数的内部处理中，如果传入的是一个 <code>None</code> ，则返回一个 <code>None</code> 且不做任何处理；如果传入的是一个 <code>Some(i32)</code>，则通过模式绑定，把其中的值绑定到变量 <code>i</code> 上，然后返回 <code>i+1</code> 的值，同时用 <code>Some</code> 进行包裹。</p><h3 id="Option-的辅助函数"><a href="#Option-的辅助函数" class="headerlink" title="Option&lt;T&gt; 的辅助函数"></a>Option&lt;T&gt; 的辅助函数</h3><blockquote><p><a href="https://doc.rust-lang.org/std/option">参考文档</a></p></blockquote><ul><li><code>unwrap</code><br>如果我们确定 Option 中一定存在值，可以使用 unwrap 方法来获取该值。如果 Option 中不存在值，则会触发 panic。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;A&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">p1</span> = s.<span class="hljs-title function_ invoke__">pop</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>dbg!(p1); <span class="hljs-comment">// 输出结果：p1 = &#x27;A&#x27;</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">p2</span> = s.<span class="hljs-title function_ invoke__">pop</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>dbg!(p2); <span class="hljs-comment">// panic!</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>is_some</code> 和 <code>is_none</code><br>用来判断 <code>Option</code> 中是否存在值。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = [<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>];<br><span class="hljs-keyword">if</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">is_some</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, v[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 输出结果：40</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>unwrap_or</code><br>提供默认值。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>()&#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 调用 div 方法，由于 b 为 0，所以返回了 None</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">div</span>(a, b).<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class="hljs-number">0.0</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;result is : &#123;&#125;&quot;</span>, result); <span class="hljs-comment">// 输出结果：result is : 0</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">div</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">f64</span>&gt; &#123;<br><span class="hljs-keyword">if</span> b != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Some</span>(a <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> / b <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-literal">None</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Rust-的错误哲学"><a href="#Rust-的错误哲学" class="headerlink" title="Rust  的错误哲学"></a>Rust  的错误哲学</h2><p>Rust 中的错误主要分为两类：</p><ul><li><strong>可恢复错误</strong>，通常用于从系统全局角度来看可以接受的错误，例如处理用户的访问、操作等错误，这些错误只会影响某个用户自身的操作进程，而不会对系统的全局稳定性产生影响</li><li><strong>不可恢复错误</strong>，刚好相反，该错误通常是全局性或者系统性的错误，例如数组越界访问，系统启动时发生了影响启动流程的错误等等，这些错误的影响往往对于系统来说是致命的</li><li><code>Result&lt;T, E&gt;</code> 用于可恢复错误</li><li><code>panic!</code> 用于不可恢复错误</li></ul><h2 id="深入-panic"><a href="#深入-panic" class="headerlink" title="深入 panic!"></a>深入 panic!</h2><p>Rust 中最简单的错误处理方式就是使用 <code>panic</code>。它会打印出一条错误信息并打印出栈调用情况，最终结束当前线程:</p><ul><li>若 panic 发生在 <code>main</code> 线程，那程序会随之退出</li><li>如果是在生成的( spawn )子线程中发生 panic, 那么当前的线程会结束，但是程序依然会继续运行</li></ul><h3 id="被动触发"><a href="#被动触发" class="headerlink" title="被动触发"></a>被动触发</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>    v[<span class="hljs-number">99</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的错误是数组访问越界，运行后将看到如下报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ cargo run<br>   Compiling panic v0.1.0 (file:///projects/panic)<br>    Finished dev [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.27s<br>     Running `target/debug/panic`<br>thread <span class="hljs-string">&#x27;main&#x27;</span> panicked at <span class="hljs-string">&#x27;index out of bounds: the len is 3 but the index is 99&#x27;</span>, src/main.rs:4:5<br>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace<br></code></pre></td></tr></table></figure><h3 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h3><p>对此，Rust 为我们提供了 <code>panic!</code> 宏，当调用执行该宏时，<strong>程序会打印出一个错误信息，展开报错点往前的函数调用堆栈，最后退出程序</strong>。</p><blockquote><p>切记，一定是不可恢复的错误，才调用 <code>panic!</code> 处理，你总不想系统仅仅因为用户随便传入一个非法参数就崩溃吧？所以，<strong>只有当你不知道该如何处理时，再去调用 panic!</strong>.</p></blockquote><p>首先，来调用一下 <code>panic!</code>，这里使用了最简单的代码实现，实际上你在程序的任何地方都可以这样调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;crash and burn&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后输出:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">thread <span class="hljs-string">&#x27;main&#x27;</span> panicked at <span class="hljs-string">&#x27;crash and burn&#x27;</span>, src/main.rs:2:5<br>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace<br></code></pre></td></tr></table></figure><p>以上信息包含了两条重要信息：</p><ul><li><code>main</code> 函数所在的线程崩溃了，发生的代码位置是 <code>src/main.rs</code> 中的第 2 行第 5 个字符（包含该行前面的空字符）</li><li>在使用时加上一个环境变量可以获取更详细的栈展开信息：<ul><li>Linux&#x2F;macOS 等 UNIX 系统： <code>RUST_BACKTRACE=1 cargo run</code></li><li>Windows 系统（PowerShell）： <code>$env:RUST_BACKTRACE=1 ; cargo run</code></li></ul></li></ul><p>下面让我们针对第二点进行详细展开讲解。</p><h3 id="backtrace-栈展开"><a href="#backtrace-栈展开" class="headerlink" title="backtrace 栈展开"></a>backtrace 栈展开</h3><p>以被动触发的崩溃例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">RUST_BACKTRACE=1 cargo run<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh">thread <span class="hljs-string">&#x27;main&#x27;</span> panicked at <span class="hljs-string">&#x27;index out of bounds: the len is 3 but the index is 99&#x27;</span>, src/main.rs:4:5<br>stack backtrace:<br>   0: rust_begin_unwind<br>             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/std/src/panicking.rs:517:5<br>   1: core::panicking::panic_fmt<br>             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:101:14<br>   2: core::panicking::panic_bounds_check<br>             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/panicking.rs:77:5<br>   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index<br>             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:184:10<br>   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; <span class="hljs-keyword">for</span> [T]&gt;::index<br>             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/slice/index.rs:15:9<br>   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index<br>             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/alloc/src/vec/mod.rs:2465:9<br>   6: world_hello::main<br>             at ./src/main.rs:4:5<br>   7: core::ops::<span class="hljs-keyword">function</span>::FnOnce::call_once<br>             at /rustc/59eed8a2aac0230a8b53e89d4e99d55912ba6b35/library/core/src/ops/function.rs:227:5<br>note: Some details are omitted, run with `RUST_BACKTRACE=full` <span class="hljs-keyword">for</span> a verbose backtrace.<br></code></pre></td></tr></table></figure><p>上面的代码就是一次栈展开（也称栈回溯），它包含了函数调用的顺序，当然按照逆序排列：最近调用的函数排在列表的最上方。因为咱们的 <code>main</code> 函数基本是最先调用的函数了，所以排在了倒数第二位，还有一个关注点，排在最顶部最后一个调用的函数是 <code>rust_begin_unwind</code>，该函数的目的就是进行栈展开，呈现这些列表信息给我们。</p><p>要获取到栈回溯信息，你还需要开启 <code>debug</code> 标志，该标志在使用 <code>cargo run</code> 或者 <code>cargo build</code> 时自动开启（这两个操作默认是 <code>Debug</code> 运行方式）。同时，栈展开信息在不同操作系统或者 Rust 版本上也有所不同。</p><h3 id="panic-时的两种终止方式"><a href="#panic-时的两种终止方式" class="headerlink" title="panic 时的两种终止方式"></a>panic 时的两种终止方式</h3><ul><li><strong>栈展开</strong>（默认），Rust 会回溯栈上数据和函数调用，因此也意味着更多的善后工作，好处是可以给出充分的报错信息和栈调用信息，便于事后的问题复盘。</li><li><strong>直接终止</strong>，不清理数据就直接退出程序，善后工作交与操作系统来负责。</li></ul><p>对于绝大多数用户，使用默认选择是最好的，但是当你关心最终编译出的二进制可执行文件大小时，那么可以尝试去使用直接终止的方式，例如下面的配置修改 <code>Cargo.toml</code> 文件，实现在  <code>release</code> 模式下遇到 <code>panic</code> 直接终止：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&#x27;abort&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">RUST_BACKTRACE=1 cargo run --release<br></code></pre></td></tr></table></figure><h2 id="可恢复的错误-Result"><a href="#可恢复的错误-Result" class="headerlink" title="可恢复的错误 Result"></a>可恢复的错误 Result</h2><p><code>Result&lt;T, E&gt;</code> 是一个枚举类型用于描述返回的结果或错误，它包含两个成员(变体 variants) :</p><ul><li><code>Ok(T)</code>: 返回一个结果值 T</li><li><code>Err(E)</code>: 返回一个错误，<code>E</code> 是具体的错误值</li></ul><p>简而言之，如果期待一个正确的结果，就返回 <code>Ok</code>，反之则是 <code>Err</code>。</p><p>定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure><p>案例如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">div</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">i32</span>, <span class="hljs-type">String</span>&gt; &#123;<br><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// 此操作将会失败，把失败原因包装在 Err 中并返回</span><br><span class="hljs-title function_ invoke__">Err</span>(<span class="hljs-string">&quot;b is Zero&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 此操作是有效的，结果包装在 Ok 中返回</span><br><span class="hljs-title function_ invoke__">Ok</span>(a / b)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以把相似的错误类型变成枚举列出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">MathError</span> &#123;<br>DivisionByZero,<br>NegativeSquareRoot<br>&#125; <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">div</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">i32</span>, MathError&gt; &#123;<br><br><span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br><span class="hljs-title function_ invoke__">Err</span>(MathError::DivisionByZero)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_ invoke__">Ok</span>(a / b)<br>&#125;<br>&#125; <br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">square</span>(a: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">f64</span>, MathError&gt; &#123;<br><span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0.0</span> &#123;<br><span class="hljs-title function_ invoke__">Err</span>(MathError::NegativeSquareRoot)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-title function_ invoke__">Ok</span>(a.<span class="hljs-title function_ invoke__">sqrt</span>())<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对返回的错误进行处理"><a href="#对返回的错误进行处理" class="headerlink" title="对返回的错误进行处理"></a>对返回的错误进行处理</h3><p>直接 <code>panic</code> 还是过于粗暴，因为实际上 IO 的错误有很多种，我们需要对部分错误进行特殊处理，而不是所有错误都直接崩溃：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>() &#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(fc) =&gt; fc,<br>                <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),<br>            &#125;,<br>            other_error =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码在匹配出 <code>error</code> 后，又对 <code>error</code> 进行了详细的匹配解析，最终结果：</p><ul><li>如果是文件不存在错误 <code>ErrorKind::NotFound</code>，就创建文件，这里创建文件<code>File::create</code> 也是返回 <code>Result</code>，因此继续用 <code>match</code> 对其结果进行处理：创建成功，将新的文件句柄赋值给 <code>f</code>，如果失败，则 <code>panic</code></li><li>剩下的错误，一律 <code>panic</code></li></ul><h3 id="Result-的辅助函数"><a href="#Result-的辅助函数" class="headerlink" title="Result 的辅助函数"></a>Result 的辅助函数</h3><blockquote><p><a href="https://doc.rust-lang.org/std/result/index.html">参考文档</a></p></blockquote><ul><li><code>unwrap</code><br>如果返回成功，就将 <code>Ok(T)</code> 中的值取出来，如果失败，就直接 <code>panic</code>。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果调用这段代码时 <em>hello.txt</em> 文件不存在，那么 <code>unwrap</code> 就将直接 <code>panic</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">thread <span class="hljs-string">&#x27;main&#x27;</span> panicked at <span class="hljs-string">&#x27;called `Result::unwrap()` on an `Err` value: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;</span>, src/main.rs:4:37<br>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace<br></code></pre></td></tr></table></figure><ul><li><code>expect</code><br><code>expect</code> 跟 <code>unwrap</code> 很像，也是遇到错误直接 <code>panic</code>, 但是会带上自定义的错误提示信息，相当于重载了错误打印的函数：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to open hello.txt&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">thread <span class="hljs-string">&#x27;main&#x27;</span> panicked at <span class="hljs-string">&#x27;Failed to open hello.txt: Os &#123; code: 2, kind: NotFound, message: &quot;No such file or directory&quot; &#125;&#x27;</span>, src/main.rs:4:37<br>note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace<br></code></pre></td></tr></table></figure><ul><li><code>map</code></li></ul><p><code>Result&lt;T, E&gt;</code> -&gt; <code>Result&lt;U, E&gt;</code></p><p>可以用于 <code>Result&lt;T, E&gt;</code> (也可用于 <code>Option&lt;T&gt;</code>)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">line</span> = <span class="hljs-string">&quot;1\n2\n3\n4\n&quot;</span>;<br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">num</span> <span class="hljs-keyword">in</span> line.<span class="hljs-title function_ invoke__">lines</span>() &#123;<br>        <span class="hljs-keyword">match</span> num.parse::&lt;<span class="hljs-type">i32</span>&gt;().<span class="hljs-title function_ invoke__">map</span>(|i| i * <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(n) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;n&#125;&quot;</span>),<br>            <span class="hljs-title function_ invoke__">Err</span>(..) =&gt; &#123;&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>map_err</code></li></ul><p><code>Result&lt;T, E&gt;</code> -&gt; &#96;Result&lt;T, F&gt;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">transform_error</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">String</span>&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">map_err</span>(|e: std::io::Error| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;e&#125;&quot;</span>)&#125;);<br>    <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(()),<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-title function_ invoke__">Err</span>(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h3><p>实际应用中，大概率会把错误层层上传然后交给调用链的上游函数进行处理，错误传播将极为常见。</p><p>例如以下函数从文件中读取用户名，然后将结果进行返回：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, Read&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-comment">// 打开文件，f是`Result&lt;文件句柄,io::Error&gt;`</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-comment">// 打开文件成功，将file句柄赋值给f</span><br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-comment">// 打开文件失败，将错误返回(向上传播)</span><br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;;<br>    <span class="hljs-comment">// 创建动态字符串s</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-comment">// 从f文件句柄读取数据并写入s中</span><br>    <span class="hljs-keyword">match</span> f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s) &#123;<br>        <span class="hljs-comment">// 读取成功，返回Ok封装的字符串</span><br>        <span class="hljs-title function_ invoke__">Ok</span>(_) =&gt; <span class="hljs-title function_ invoke__">Ok</span>(s),<br>        <span class="hljs-comment">// 将错误向上传播</span><br>        <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-title function_ invoke__">Err</span>(e),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有几点值得注意：</p><ul><li>该函数返回一个 <code>Result&lt;String, io::Error&gt;</code> 类型，当读取用户名成功时，返回 <code>Ok(String)</code>，失败时，返回 <code>Err(io:Error)</code></li><li><code>File::open</code> 和 <code>f.read_to_string</code> 返回的 <code>Result&lt;T, E&gt;</code> 中的 <code>E</code> 就是 <code>io::Error</code></li></ul><p>由此可见，该函数将 <code>io::Error</code> 的错误往上进行传播，该函数的调用者最终会对 <code>Result&lt;String,io::Error&gt;</code> 进行再处理，至于怎么处理就是调用者的事，如果是错误，它可以选择继续向上传播错误，也可以直接 <code>panic</code>，亦或将具体的错误原因包装后写入 socket 中呈现给终端用户。</p><h2 id="传播错误的简写：-运算符"><a href="#传播错误的简写：-运算符" class="headerlink" title="传播错误的简写：? 运算符"></a>传播错误的简写：<code>?</code> 运算符</h2><p>重写上面例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    f.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 <code>?</code> 就是一个宏，它的作用跟上面的 <code>match</code> 几乎一模一样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>    <span class="hljs-comment">// 打开文件成功，将file句柄赋值给f</span><br>    <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>    <span class="hljs-comment">// 打开文件失败，将错误返回(向上传播)</span><br>    <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Err</span>(e),<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果结果是 <code>Ok(T)</code>，则把 <code>T</code> 赋值给 <code>f</code>，如果结果是 <code>Err(E)</code>，则返回该错误，所以 <code>?</code> 特别适合用来传播错误。</p><p><code>?</code> 还能实现<strong>链式调用</strong>，<code>File::open</code> 遇到错误就返回，没有错误就将 <code>Ok</code> 中的值取出来用于下一个方法调用。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?.<span class="hljs-title function_ invoke__">read_to_string</span>(&amp;<span class="hljs-keyword">mut</span> s)?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(s)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="用于-Option-的返回"><a href="#用于-Option-的返回" class="headerlink" title="? 用于 Option 的返回"></a>? 用于 Option 的返回</h3><p><code>?</code> 不仅仅可以用于 <code>Result</code> 的传播，还能用于 <code>Option</code> 的传播。</p><p><code>Option</code> 通过 <code>?</code> 返回 <code>None</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first</span>(arr: &amp;[<span class="hljs-type">i32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">i32</span>&gt; &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = arr.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>)?;<br>   <span class="hljs-title function_ invoke__">Some</span>(v)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的函数中，<code>arr.get</code> 返回一个 <code>Option&lt;&amp;i32&gt;</code> 类型，因为 <code>?</code> 的使用，如果 <code>get</code> 的结果是 <code>None</code>，则直接返回 <code>None</code>，如果是 <code>Some(&amp;i32)</code>，则把里面的值赋给 <code>v</code>。</p><p>其实这个函数有些画蛇添足，我们完全可以写出更简单的版本：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first</span>(arr: &amp;[<span class="hljs-type">i32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">i32</span>&gt; &#123;<br>   arr.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>链式调用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">last_char_of_first_line</span>(text: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">char</span>&gt; &#123;<br>    text.<span class="hljs-title function_ invoke__">lines</span>().<span class="hljs-title function_ invoke__">next</span>()?.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">last</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码展示了在链式调用中使用 <code>?</code> 提前返回 <code>None</code> 的用法， <code>.next</code> 方法返回的是 <code>Option</code> 类型：如果返回 <code>Some(&amp;str)</code>，那么继续调用 <code>chars</code> 方法，如果返回 <code>None</code>，则直接从整个函数中返回 <code>None</code>，不再继续进行链式调用。</p><h3 id="新手用-常会犯的错误"><a href="#新手用-常会犯的错误" class="headerlink" title="新手用 ? 常会犯的错误"></a>新手用 ? 常会犯的错误</h3><p>例如写出这样的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first</span>(arr: &amp;[<span class="hljs-type">i32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">i32</span>&gt; &#123;<br>   arr.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>)?<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码无法通过编译，切记：<code>?</code> 操作符需要一个变量来承载正确的值，这个函数只会返回 <code>Some(&amp;i32)</code> 或者 <code>None</code>，只有错误值能直接返回，正确的值不行，所以如果数组中存在 0 号元素，那么函数第二行使用 <code>?</code> 后的返回类型为 <code>&amp;i32</code> 而不是 <code>Some(&amp;i32)</code>。因此 <code>?</code> 只能用于以下形式：</p><ul><li><code>let v = xxx()?;</code></li><li><code>xxx()?.yyy()?;</code></li></ul><h2 id="Option-与-Result-的相互转换"><a href="#Option-与-Result-的相互转换" class="headerlink" title="Option 与 Result 的相互转换"></a>Option 与 Result 的相互转换</h2><h3 id="Option-ok-or"><a href="#Option-ok-or" class="headerlink" title="Option: ok_or"></a>Option: <code>ok_or</code></h3><ul><li><code>Some(v)</code> -&gt; <code>Ok(v)</code></li><li><code>None</code> -&gt; <code>Err(e)</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">option_to_result</span>(arr: &amp;[<span class="hljs-type">i32</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;&amp;<span class="hljs-type">i32</span>, &amp;<span class="hljs-type">str</span>&gt; &#123;<br>arr.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">ok_or</span>(<span class="hljs-string">&quot;out of index&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Result-err"><a href="#Result-err" class="headerlink" title="Result: err"></a>Result: <code>err</code></h3><ul><li><code>Err(e)</code> -&gt; <code>Some(e)</code></li><li><code>Ok(v)</code> -&gt; <code>None</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">err</span>();<br><span class="hljs-keyword">if</span> f.<span class="hljs-title function_ invoke__">is_some</span>() &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;no file&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Result-ok"><a href="#Result-ok" class="headerlink" title="Result: ok"></a>Result: <code>ok</code></h3><ul><li><code>Ok(v)</code> -&gt; <code>Some(v)</code></li><li><code>Err(e)</code> -&gt; <code>None</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">ok</span>();<br><span class="hljs-keyword">if</span> f.<span class="hljs-title function_ invoke__">is_none</span>() &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;no file&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MathError</span> &#123;<br>    DivisionByZero,<br>    NegativeSquareRoot,<br>&#125;<br><br><span class="hljs-comment">// fn divide(a: i32, b: i32) -&gt; Option&lt;f64&gt; &#123;</span><br><span class="hljs-comment">//     if b != 0 &#123;</span><br><span class="hljs-comment">//         Some(a as f64 / b as f64)</span><br><span class="hljs-comment">//     &#125; else &#123;</span><br><span class="hljs-comment">//         Some(1.0)</span><br><span class="hljs-comment">//     &#125;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">// 此方法的返回类型要改为 Result，后面 call 里调用才可以用？</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">divide</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">f64</span>, MathError&gt; &#123;<br>    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(MathError::DivisionByZero)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(a <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span> / b <span class="hljs-keyword">as</span> <span class="hljs-type">f64</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">sqrt</span>(x: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">f64</span>, MathError&gt; &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0.0</span> &#123;<br>        <span class="hljs-title function_ invoke__">Err</span>(MathError::NegativeSquareRoot)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(x.<span class="hljs-title function_ invoke__">sqrt</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">f64</span>, MathError&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">division_result</span> = <span class="hljs-title function_ invoke__">divide</span>(a, b)?;<br>    <span class="hljs-title function_ invoke__">sqrt</span>(division_result)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">25</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">match</span> <span class="hljs-title function_ invoke__">call</span>(a, b) &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(result) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Result: &#123;&#125;&quot;</span>, result), <span class="hljs-comment">// Result: 2.23606797749979</span><br>        <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; &#123;&#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 17 集合类型-KV 存储 HashMap</title>
    <link href="/2024/11/14/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2017%20%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-KV%20%E5%AD%98%E5%82%A8%20HashMap/"/>
    <url>/2024/11/14/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2017%20%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-KV%20%E5%AD%98%E5%82%A8%20HashMap/</url>
    
    <content type="html"><![CDATA[<p><code>HashMap</code> 中存储的是一一映射的 <code>KV</code> 键值对，并提供了平均复杂度为 <code>O(1)</code> 的查询方法。</p><h2 id="创建-HashMap"><a href="#创建-HashMap" class="headerlink" title="创建 HashMap"></a>创建 HashMap</h2><h3 id="使用-new-方法创建"><a href="#使用-new-方法创建" class="headerlink" title="使用 new 方法创建"></a>使用 new 方法创建</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 使用 `HashMap` 需要手动通过 `use ...` 从标准库中引入到我们当前的作用域中来</span><br><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-comment">// 创建一个HashMap，用于存储宝石种类和对应的数量</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">my_gems</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-comment">// 将宝石类型和对应的数量写入表中</span><br>my_gems.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;红宝石&quot;</span>, <span class="hljs-number">1</span>);<br>my_gems.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;蓝宝石&quot;</span>, <span class="hljs-number">2</span>);<br>my_gems.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;河边捡的误以为是宝石的破石头&quot;</span>, <span class="hljs-number">18</span>);<br></code></pre></td></tr></table></figure><blockquote><p>跟 <code>Vec</code> 一样，如果预先知道要存储的 <code>KV</code> 对个数，可以使用 <code>HashMap::with_capacity(capacity)</code> 创建指定大小的 <code>HashMap</code>，避免频繁的内存分配和拷贝，提升性能。</p></blockquote><h3 id="使用迭代器和-collect-方法创建"><a href="#使用迭代器和-collect-方法创建" class="headerlink" title="使用迭代器和 collect 方法创建"></a>使用迭代器和 collect 方法创建</h3><p>先将 <code>Vec</code> 转为迭代器，接着通过 <code>collect</code> 方法，将迭代器中的元素收集后，转成 <code>HashMap</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">use</span> std::collections::HashMap;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">teams_list</span> = <span class="hljs-built_in">vec!</span>[<br>        (<span class="hljs-string">&quot;中国队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">100</span>),<br>        (<span class="hljs-string">&quot;美国队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">10</span>),<br>        (<span class="hljs-string">&quot;日本队&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-number">50</span>),<br>    ];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">teams_map</span>: HashMap&lt;_,_&gt; = teams_list.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,teams_map)<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，<code>into_iter</code> 方法将列表转为迭代器，接着通过 <code>collect</code> 进行收集，不过需要注意的是，<code>collect</code> 方法在内部实际上支持生成多种类型的目标集合，因此我们需要通过类型标注 <code>HashMap&lt;_,_&gt;</code> 来告诉编译器：请帮我们收集为 <code>HashMap</code> 集合类型</p><h3 id="HashMap-key-的限制"><a href="#HashMap-key-的限制" class="headerlink" title="HashMap key 的限制"></a>HashMap key 的限制</h3><p>任何实现了 <code>Eq</code> 和 <code>Hash</code> 特征的类型都可以用于 <code>HashMap</code> 的 key，包括:</p><ul><li><code>bool</code> (虽然很少用到，因为它只能表达两种 key)</li><li><code>int</code>, <code>uint</code> 以及它们的变体，例如 <code>u8</code>、<code>i32</code> 等</li><li><code>String</code> 和 <code>&amp;str</code> (提示: <code>HashMap</code> 的 key 是 <code>String</code> 类型时，你其实可以使用 <code>&amp;str</code> 配合 <code>get</code> 方法进行查询</li></ul><blockquote><p>需要注意的是，<code>f32</code> 和 <code>f64</code> 并没有实现 <code>Hash</code>，原因是 <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems">浮点数精度</a> 的问题会导致它们无法进行相等比较。</p></blockquote><p>如果一个集合类型的所有字段都实现了 <code>Eq</code> 和 <code>Hash</code>,那该集合类型会自动实现 <code>Eq</code> 和 <code>Hash</code>。例如 <code>Vect&lt;T&gt;</code> 要实现 <code>Hash</code>，那么首先需要 <code>T</code> 实现 <code>Hash</code>。</p><h2 id="所有权转移"><a href="#所有权转移" class="headerlink" title="所有权转移"></a>所有权转移</h2><p><code>HashMap</code> 的所有权规则与其它 Rust 类型没有区别：</p><ul><li>若类型实现 <code>Copy</code> 特征，该类型会被复制进 <code>HashMap</code>，因此无所谓所有权</li><li>若没实现 <code>Copy</code> 特征，所有权将被转移给 <code>HashMap</code> 中</li></ul><h2 id="查询-HashMap"><a href="#查询-HashMap" class="headerlink" title="查询 HashMap"></a>查询 HashMap</h2><h3 id="通过-get-方法可以获取元素"><a href="#通过-get-方法可以获取元素" class="headerlink" title="通过 get 方法可以获取元素"></a>通过 <code>get</code> 方法可以获取元素</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>), <span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">team_name</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">score</span>: <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">i32</span>&gt; = scores.<span class="hljs-title function_ invoke__">get</span>(&amp;team_name);<br></code></pre></td></tr></table></figure><p>上面有几点需要注意：</p><ul><li><code>get</code> 方法返回一个 <code>Option&lt;&amp;i32&gt;</code> 类型：当查询不到时，会返回一个 <code>None</code>，查询到时返回 <code>Some(&amp;i32)</code></li><li><code>&amp;i32</code> 是对 <code>HashMap</code> 中值的借用，如果不使用借用，可能会发生所有权的转移</li></ul><h3 id="通过循环的方式依次遍历-KV-对"><a href="#通过循环的方式依次遍历-KV-对" class="headerlink" title="通过循环的方式依次遍历 KV 对"></a>通过循环的方式依次遍历 <code>KV</code> 对</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Blue&quot;</span>), <span class="hljs-number">10</span>);<br>scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Yellow&quot;</span>), <span class="hljs-number">50</span>);<br><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-comment">// Yellow: 50</span><br><span class="hljs-comment">// Blue: 10</span><br><br></code></pre></td></tr></table></figure><h2 id="更新-HashMap-中的值"><a href="#更新-HashMap-中的值" class="headerlink" title="更新 HashMap 中的值"></a>更新 HashMap 中的值</h2><p>更新值的时候，涉及多种情况，咱们在代码中一一进行说明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">use</span> std::collections::HashMap;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">scores</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><br>    scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">10</span>);<br><br>    <span class="hljs-comment">// 覆盖已有的值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">old</span> = scores.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-string">&quot;Blue&quot;</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(old, <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">10</span>));<br><br>    <span class="hljs-comment">// 查询新插入的值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">new</span> = scores.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;Blue&quot;</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(new, <span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-number">20</span>));<br><br>    <span class="hljs-comment">// 查询Yellow对应的值，若不存在则插入新值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-string">&quot;Yellow&quot;</span>).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(*v, <span class="hljs-number">5</span>); <span class="hljs-comment">// 不存在，插入5</span><br><br>    <span class="hljs-comment">// 查询Yellow对应的值，若不存在则插入新值</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = scores.<span class="hljs-title function_ invoke__">entry</span>(<span class="hljs-string">&quot;Yellow&quot;</span>).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">50</span>);<br>    <span class="hljs-built_in">assert_eq!</span>(*v, <span class="hljs-number">5</span>); <span class="hljs-comment">// 已经存在，因此50没有插入</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="在已有值的基础上更新"><a href="#在已有值的基础上更新" class="headerlink" title="在已有值的基础上更新"></a>在已有值的基础上更新</h3><p>另一个常用场景如下：查询某个 <code>key</code> 对应的值，若不存在则插入新值，若存在则对已有的值进行更新，例如在文本中统计词语出现的次数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = <span class="hljs-string">&quot;hello world wonderful world&quot;</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-comment">// 根据空格来切分字符串(英文单词都是通过空格切分)</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">split_whitespace</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = map.<span class="hljs-title function_ invoke__">entry</span>(word).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br>    *count += <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, map);<br><span class="hljs-comment">// 输出结果： &#123;&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，新建一个 <code>map</code> 用于保存词语出现的次数，插入一个词语时会进行判断：若之前没有插入过，则使用该词语作 <code>Key</code>，插入次数 0 作为 <code>Value</code>，若之前插入过则取出之前统计的该词语出现的次数，对其加一。</p><p>有两点值得注意：</p><ul><li><code>or_insert</code> 返回了 <code>&amp;mut v</code> 引用，因此可以通过该可变引用直接修改 <code>map</code> 中对应的值</li><li>使用 <code>count</code> 引用时，需要先进行解引用 <code>*count</code>，否则会出现类型不匹配</li></ul><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ol><li>使用 HashMap 实现一个字频统计器编写一个程序，统计一个字符串中每个单词出现的频率。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = <span class="hljs-string">&quot;hello world hello rust world&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-comment">// 根据空格来切分字符串</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">word</span> <span class="hljs-keyword">in</span> text.<span class="hljs-title function_ invoke__">split_whitespace</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">count</span> = map.<span class="hljs-title function_ invoke__">entry</span>(word).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br>*count += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, map);<br><span class="hljs-comment">// &#123;&quot;hello&quot;: 2, &quot;world&quot;: 2, &quot;rust&quot;: 1&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>练习3：使用 Vec 和*HashMap 实现一个简单的书籍库存管理系统，可以添加书籍、查询库存、更新库存以及删除书籍。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BookInventory</span> &#123;<br>    books: HashMap&lt;<span class="hljs-type">String</span>, Book&gt;,<br>&#125;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">BookStatus</span> &#123;<br>    Available,<br>    Borrowed,<br>&#125;<br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Book</span> &#123;<br>    title: <span class="hljs-type">String</span>,<br>    author: <span class="hljs-type">String</span>,<br>    status: BookStatus,<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(title: <span class="hljs-type">String</span>, author: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> Book &#123;<br>        Book &#123;<br>            title,<br>            author,<br>            status: BookStatus::Available,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">borrow</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.status = BookStatus::Borrowed;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_book</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.status = BookStatus::Available;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_status</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span>.status &#123;<br>            BookStatus::Available =&gt; <span class="hljs-string">&quot;Available&quot;</span>,<br>            BookStatus::Borrowed =&gt; <span class="hljs-string">&quot;Borrowed&quot;</span>,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Title: &#123;&#125;, Author: &#123;&#125;, Status: &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.title, <span class="hljs-keyword">self</span>.author, <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_status</span>());<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">update_status</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, status: BookStatus) &#123;<br>        <span class="hljs-keyword">self</span>.status = status;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">BookInventory</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> BookInventory &#123;<br>        BookInventory &#123;<br>            books: HashMap::<span class="hljs-title function_ invoke__">new</span>(),<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_book</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, title: <span class="hljs-type">String</span>, author: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">book</span> = Book::<span class="hljs-title function_ invoke__">new</span>(title, author);<br>        <span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">insert</span>(book.title.<span class="hljs-title function_ invoke__">clone</span>(), book);<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">search_book</span>(&amp;<span class="hljs-keyword">self</span>, title: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;Book&gt; &#123;<br>        <span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">get</span>(title)<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">update_book_status</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, title: &amp;<span class="hljs-type">str</span>, status: BookStatus) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(book) = <span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">get_mut</span>(title) &#123;<br>            book.<span class="hljs-title function_ invoke__">update_status</span>(status);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">delete_book</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, title: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">remove</span>(title);<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">borrow_book</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, title: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(book) = <span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">get_mut</span>(title) &#123;<br>            book.<span class="hljs-title function_ invoke__">borrow</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_book</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, title: &amp;<span class="hljs-type">str</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(book) = <span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">get_mut</span>(title) &#123;<br>            book.<span class="hljs-title function_ invoke__">return_book</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_book_status</span>(&amp;<span class="hljs-keyword">self</span>, title: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(book) = <span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">get</span>(title) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(book.<span class="hljs-title function_ invoke__">get_status</span>())<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_all_books</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;Book&gt; &#123;<br>        <span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">values</span>().<span class="hljs-title function_ invoke__">collect</span>()<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">book</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">get_all_books</span>() &#123;<br>            book.<span class="hljs-title function_ invoke__">display</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">len</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br><span class="hljs-keyword">self</span>.books.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">inventory</span> = BookInventory::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-comment">// 添加书籍</span><br>    inventory.<span class="hljs-title function_ invoke__">add_book</span>(<span class="hljs-string">&quot;Rust Programming&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-string">&quot;John Doe&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>    inventory.<span class="hljs-title function_ invoke__">add_book</span>(<span class="hljs-string">&quot;C Programming&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-string">&quot;Jane Smith&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>    inventory.<span class="hljs-title function_ invoke__">add_book</span>(<span class="hljs-string">&quot;Python Programming&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>(), <span class="hljs-string">&quot;Mike Brown&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>());<br>    <br>    inventory.<span class="hljs-title function_ invoke__">display</span>();<br>    <span class="hljs-comment">// Title: C Programming, Author: Jane Smith, Status: Available</span><br><span class="hljs-comment">// Title: Python Programming, Author: Mike Brown, Status: Available</span><br><span class="hljs-comment">// Title: Rust Programming, Author: John Doe, Status: Available</span><br><span class="hljs-comment">// 统计库存</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;库存书籍&#123;:?&#125;本&quot;</span>, inventory.<span class="hljs-title function_ invoke__">len</span>());<br><span class="hljs-comment">// 库存书籍3本</span><br><br>    <span class="hljs-comment">// 查找书籍</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;查找&#x27;Rust Programming&#x27;: &#123;:?&#125;&quot;</span>, inventory.<span class="hljs-title function_ invoke__">search_book</span>(<span class="hljs-string">&quot;Rust Programming&quot;</span>));<br>    <span class="hljs-comment">// 查找&#x27;Rust Programming&#x27;: Some(Book &#123; title: &quot;Rust Programming&quot;, author: &quot;John Doe&quot;, status: Available &#125;)</span><br>    <br><span class="hljs-comment">// 更新书籍状态</span><br>    inventory.<span class="hljs-title function_ invoke__">update_book_status</span>(<span class="hljs-string">&quot;Rust Programming&quot;</span>, BookStatus::Borrowed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;查找&#x27;Rust Programming&#x27;的借阅状态: &#123;:?&#125;&quot;</span>, inventory.<span class="hljs-title function_ invoke__">get_book_status</span>(<span class="hljs-string">&quot;Rust Programming&quot;</span>));<br>    <span class="hljs-comment">// 查找&#x27;Rust Programming&#x27;的借阅状态: Some(&quot;Borrowed&quot;)</span><br>    <br>inventory.<span class="hljs-title function_ invoke__">borrow_book</span>(<span class="hljs-string">&quot;Python Programming&quot;</span>);<br>    inventory.<span class="hljs-title function_ invoke__">return_book</span>(<span class="hljs-string">&quot;Rust Programming&quot;</span>);<br>    inventory.<span class="hljs-title function_ invoke__">display</span>();<br><br><br>    <span class="hljs-comment">// 删除书籍</span><br>    inventory.<span class="hljs-title function_ invoke__">delete_book</span>(<span class="hljs-string">&quot;C Programming&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;删除一本书之后，还有&#123;:?&#125;本&quot;</span>, inventory.<span class="hljs-title function_ invoke__">len</span>());<br>    <span class="hljs-comment">// 删除一本书之后，还有2本</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 16 集合类型-动态数组(Vector)</title>
    <link href="/2024/11/14/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2016%20%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84(Vector)/"/>
    <url>/2024/11/14/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2016%20%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84(Vector)/</url>
    
    <content type="html"><![CDATA[<p>动态数组类型用 <code>Vec&lt;T&gt;</code> 表示，Vec 是一个动态数组，可以根据需要动态增长和缩小。适用于需要按顺序存储数据的场景。</p><h2 id="创建-Vector"><a href="#创建-Vector" class="headerlink" title="创建 Vector"></a>创建 Vector</h2><h3 id="Vec-new"><a href="#Vec-new" class="headerlink" title="Vec::new"></a>Vec::new</h3><p>使用 <code>Vec::new</code> 创建动态数组是最 rusty 的方式，它调用了 <code>Vec</code> 中的 <code>new</code> 关联函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这里，`v` 被显式地声明了类型 `Vec&lt;i32&gt;`，这是因为 Rust 编译器无法从 `Vec::new()` 中得到任何关于类型的暗示信息，因此也无法推导出 `v` 的具体类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-comment">// 此时，`v` 就无需手动声明类型，因为编译器通过 `v.push(1)`，推测出 `v` 中的元素类型是 `i32`，因此推导出 `v` 的类型是 `Vec&lt;i32&gt;`。</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v2</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v2.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><blockquote><p>如果预先知道要存储的元素个数，可以使用 <code>Vec::with_capacity(capacity)</code> 创建动态数组，这样可以避免因为插入大量新数据导致频繁的内存分配和拷贝，提升性能</p></blockquote><h3 id="vec"><a href="#vec" class="headerlink" title="vec!"></a>vec!</h3><p>还可以使用宏 <code>vec!</code> 来创建数组，与 <code>Vec::new</code> 有所不同，前者能在创建同时给予初始化值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 此处的 `v` 也无需标注类型，编译器只需检查它内部的元素即可自动推导出 `v` 的类型是 `Vec&lt;i32&gt;`</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><h2 id="更新-Vector"><a href="#更新-Vector" class="headerlink" title="更新 Vector"></a>更新 Vector</h2><p>向数组尾部添加元素，可以使用 <code>push</code> 方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>与其它类型一样，必须将 <code>v</code> 声明为 <code>mut</code> 后，才能进行修改。</p><h2 id="访问-Vector"><a href="#访问-Vector" class="headerlink" title="访问 Vector"></a>访问 Vector</h2><p>读取指定位置的元素有两种方式可选：</p><ul><li>通过下标索引访问。</li><li>使用 <code>get</code> 方法。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">third</span>: &amp;<span class="hljs-type">i32</span> = &amp;v[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第三个元素是 &#123;&#125;&quot;</span>, third);<br><br><span class="hljs-keyword">match</span> v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(third) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第三个元素是 &#123;third&#125;&quot;</span>),<br>    <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;去你的第三个元素，根本没有！&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>和其它语言一样，集合类型的索引下标都是从 <code>0</code> 开始，<code>&amp;v[2]</code> 表示借用 <code>v</code> 中的第三个元素，最终会获得该元素的引用。而 <code>v.get(2)</code> 也是访问第三个元素，但是有所不同的是，它返回了 <code>Option&lt;&amp;T&gt;</code>，因此还需要额外的 <code>match</code> 来匹配解构出具体的值。</p><h3 id="下标索引与-get-的区别"><a href="#下标索引与-get-的区别" class="headerlink" title="下标索引与 .get 的区别"></a>下标索引与 .get 的区别</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">does_not_exist</span> = &amp;v[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">does_not_exist</span> = v.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>运行以上代码，<code>&amp;v[100]</code> 的访问方式会导致程序无情报错退出，因为发生了数组越界访问。 但是 <code>v.get</code> 就不会，它在内部做了处理，有值的时候返回 <code>Some(T)</code>，无值的时候返回 <code>None</code>，因此 <code>v.get</code> 的使用方式非常安全。</p><h2 id="迭代遍历-Vector"><a href="#迭代遍历-Vector" class="headerlink" title="迭代遍历 Vector"></a>迭代遍历 Vector</h2><p>如果想要依次访问数组中的元素，可以使用迭代的方式去遍历数组，这种方式比用下标的方式去遍历数组更安全也更高效（每次下标访问都会触发数组边界检查）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;i&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在迭代过程中，修改 <code>Vector</code> 中的元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v &#123;<br>    *i += <span class="hljs-number">10</span><br>&#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;new v: &#123;:?&#125;&quot;</span>, v);<br><span class="hljs-comment">// new v: [11, 12, 13]</span><br></code></pre></td></tr></table></figure><h2 id="存储不同类型的元素"><a href="#存储不同类型的元素" class="headerlink" title="存储不同类型的元素"></a>存储不同类型的元素</h2><p><strong>数组的元素必须类型相同</strong>，但是也提到了解决方案：那就是通过使用<strong>枚举类型</strong>和<strong>特征对象</strong>来实现不同类型元素的存储。先来看看通过枚举如何实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddr</span> &#123;<br>    <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>        IpAddr::<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>()),<br>        IpAddr::<span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-string">&quot;::1&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())<br>    ];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">ip</span> <span class="hljs-keyword">in</span> v &#123;<br>        <span class="hljs-title function_ invoke__">show_addr</span>(ip)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">show_addr</span>(ip: IpAddr) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,ip);<br>&#125;<br></code></pre></td></tr></table></figure><p>数组 <code>v</code> 中存储了两种不同的 <code>ip</code> 地址，但是这两种都属于 <code>IpAddr</code> 枚举类型的成员，因此可以存储在数组中。</p><p>再来看看特征对象的实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">IpAddr</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">V4</span>(<span class="hljs-type">String</span>);<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IpAddr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">V4</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ipv4: &#123;:?&#125;&quot;</span>,<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">V6</span>(<span class="hljs-type">String</span>);<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IpAddr</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">V6</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;ipv6: &#123;:?&#125;&quot;</span>,<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> IpAddr&gt;&gt; = <span class="hljs-built_in">vec!</span>[<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>        <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-string">&quot;::1&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())),<br>    ];<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">ip</span> <span class="hljs-keyword">in</span> v &#123;<br>        ip.<span class="hljs-title function_ invoke__">display</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比枚举实现要稍微复杂一些，我们为 <code>V4</code> 和 <code>V6</code> 都实现了特征 <code>IpAddr</code>，然后将它俩的实例用 <code>Box::new</code> 包裹后，存在了数组 <code>v</code> 中，需要注意的是，这里必须手动地指定类型：<code>Vec&lt;Box&lt;dyn IpAddr&gt;&gt;</code>，表示数组 <code>v</code> 存储的是特征 <code>IpAddr</code> 的对象，这样就实现了在数组中存储不同的类型。</p><p>在实际使用场景中，<strong>特征对象数组要比枚举数组常见很多</strong>，主要原因在于<a href="https://course.rs/basic/trait/trait-object.html">特征对象</a>非常灵活，而编译器对枚举的限制较多，且无法动态增加类型。</p><h2 id="Vector-常用方法"><a href="#Vector-常用方法" class="headerlink" title="Vector 常用方法"></a>Vector 常用方法</h2><p>初始化 vec 的更多方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];   <span class="hljs-comment">// 默认值为 0，初始长度为 3</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v_from</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">from</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">assert_eq!</span>(v, v_from);<br>&#125;<br></code></pre></td></tr></table></figure><p>动态数组意味着我们增加元素时，如果<strong>容量不足就会导致 vector 扩容</strong>（目前的策略是重新申请一块 2 倍大小的内存，再将所有元素拷贝到新的内存位置，同时更新指针数据），显然，当频繁扩容或者当元素数量较多且需要扩容时，大量的内存拷贝会降低程序的性能。</p><p>可以考虑在初始化时就指定一个实际的预估容量，尽量减少可能的内存拷贝：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-title function_ invoke__">extend</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);    <span class="hljs-comment">// 附加数据到 v</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector 长度是: &#123;&#125;, 容量是: &#123;&#125;&quot;</span>, v.<span class="hljs-title function_ invoke__">len</span>(), v.<span class="hljs-title function_ invoke__">capacity</span>());<br><br>    v.<span class="hljs-title function_ invoke__">reserve</span>(<span class="hljs-number">100</span>);        <span class="hljs-comment">// 调整 v 的容量，至少要有 100 的容量</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector（reserve） 长度是: &#123;&#125;, 容量是: &#123;&#125;&quot;</span>, v.<span class="hljs-title function_ invoke__">len</span>(), v.<span class="hljs-title function_ invoke__">capacity</span>());<br><br>    v.<span class="hljs-title function_ invoke__">shrink_to_fit</span>();     <span class="hljs-comment">// 释放剩余的容量，一般情况下，不会主动去释放容量</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Vector（shrink_to_fit） 长度是: &#123;&#125;, 容量是: &#123;&#125;&quot;</span>, v.<span class="hljs-title function_ invoke__">len</span>(), v.<span class="hljs-title function_ invoke__">capacity</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>Vector 常见的一些方法示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> =  <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-built_in">assert!</span>(!v.<span class="hljs-title function_ invoke__">is_empty</span>());         <span class="hljs-comment">// 检查 v 是否为空</span><br><br>v.<span class="hljs-title function_ invoke__">insert</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);                 <span class="hljs-comment">// 在指定索引插入数据，索引值不能大于 v 的长度， v: [1, 2, 3] </span><br><span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">remove</span>(<span class="hljs-number">1</span>), <span class="hljs-number">2</span>);     <span class="hljs-comment">// 移除指定位置的元素并返回, v: [1, 3]</span><br><span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>));   <span class="hljs-comment">// 删除并返回 v 尾部的元素，v: [1]</span><br><span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>));   <span class="hljs-comment">// v: []</span><br><span class="hljs-built_in">assert_eq!</span>(v.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-literal">None</span>);      <span class="hljs-comment">// 记得 pop 方法返回的是 Option 枚举值</span><br>v.<span class="hljs-title function_ invoke__">clear</span>();                      <span class="hljs-comment">// 清空 v, v: []</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v1</span> = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>].<span class="hljs-title function_ invoke__">to_vec</span>(); <span class="hljs-comment">// append 操作会导致 v1 清空数据，增加可变声明</span><br>v.<span class="hljs-title function_ invoke__">append</span>(&amp;<span class="hljs-keyword">mut</span> v1);              <span class="hljs-comment">// 将 v1 中的所有元素附加到 v 中, v1: []</span><br>v.<span class="hljs-title function_ invoke__">truncate</span>(<span class="hljs-number">1</span>);                  <span class="hljs-comment">// 截断到指定长度，多余的元素被删除, v: [11]</span><br>v.<span class="hljs-title function_ invoke__">retain</span>(|x| *x &gt; <span class="hljs-number">10</span>);          <span class="hljs-comment">// 保留满足条件的元素，即删除不满足条件的元素</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>];<br><span class="hljs-comment">// 删除指定范围的元素，同时获取被删除元素的迭代器, v: [11, 55], m: [22, 33, 44]</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">drain</span>(<span class="hljs-number">1</span>..=<span class="hljs-number">3</span>).<span class="hljs-title function_ invoke__">collect</span>();    <br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span> = m.<span class="hljs-title function_ invoke__">split_off</span>(<span class="hljs-number">1</span>);        <span class="hljs-comment">// 指定索引处切分成两个 vec, m: [22], v2: [33, 44]</span><br></code></pre></td></tr></table></figure><p>当然也可以像数组切片的方式获取 vec 的部分元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;v[<span class="hljs-number">1</span>..=<span class="hljs-number">3</span>];<br>    <span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ol><li>使用 Vec 实现一个简单的栈，实现一个简单的栈（后进先出，LIFO）数据结构，支持push、pop 和 peek 操作。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStack</span>&lt;T&gt; &#123;<br>    data: <span class="hljs-type">Vec</span>&lt;T&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyStack&lt;T&gt; &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: <span class="hljs-type">Vec</span>&lt;T&gt;) <span class="hljs-punctuation">-&gt;</span> MyStack&lt;T&gt; &#123;<br>MyStack &#123; data &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, item: T) &#123;<br><span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">push</span>(item);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt; &#123;<br><span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">pop</span>()<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">peek</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;T&gt; &#123;<br><span class="hljs-keyword">self</span>.data.<span class="hljs-title function_ invoke__">last</span>()<br>&#125;<br>&#125;<br> <br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stack</span> = MyStack::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;myStack is: &#123;:?&#125;&quot;</span>, stack);<br>    <span class="hljs-comment">// myStack is: MyStack &#123; data: [1, 2, 3] &#125;</span><br>    stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Push 4 in myStack: &#123;:?&#125;&quot;</span>, stack);<br>    <span class="hljs-comment">// Push 4 in myStack: MyStack &#123; data: [1, 2, 3, 4] &#125;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = stack.<span class="hljs-title function_ invoke__">pop</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Pop item from myStack: &#123;:?&#125;&quot;</span>, item);<br>    <span class="hljs-comment">// Pop item from myStack: Some(4)</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = stack.<span class="hljs-title function_ invoke__">peek</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Peek item from myStack: &#123;:?&#125;&quot;</span>, item);<br>    <span class="hljs-comment">// Peek item from myStack: Some(3)</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 15 模式匹配</title>
    <link href="/2024/11/13/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2015%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2024/11/13/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2015%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>在 Rust 中，模式匹配最常用的就是 <code>match</code> 和 <code>if let</code>。</p><h2 id="match-匹配"><a href="#match-匹配" class="headerlink" title="match 匹配"></a>match 匹配</h2><p>有以下几点值得注意：</p><ul><li><code>match</code> 的匹配必须要穷举出所有可能</li><li> <code>_</code> 通配符来代表未列出的所有可能性</li><li><code>match</code> 的每一个分支都必须是一个表达式，且所有分支的表达式最终返回值的类型必须相同</li><li><strong>X | Y</strong>，类似逻辑运算符 <code>或</code>，代表该分支可以匹配 <code>X</code> 也可以匹配 <code>Y</code>，只要满足一个即可</li></ul><p>其实 <code>match</code> 跟其他语言中的 <code>switch</code> 非常像，<code>_</code> 类似于 <code>switch</code> 中的 <code>default</code>。</p><p>首先来看看 <code>match</code> 的通用形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> target &#123;<br>    模式<span class="hljs-number">1</span> =&gt; 表达式<span class="hljs-number">1</span>,<br>    模式<span class="hljs-number">2</span> =&gt; &#123;<br>        语句<span class="hljs-number">1</span>;<br>        语句<span class="hljs-number">2</span>;<br>        表达式<span class="hljs-number">2</span><br>    &#125;,<br>    _ =&gt; 表达式<span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><p>简单例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Direction</span> &#123;<br>    East,<br>    West,<br>    North,<br>    South,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dire</span> = Direction::South;<br>    <span class="hljs-keyword">match</span> dire &#123;<br>        Direction::East =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;East&quot;</span>),<br>        Direction::North | Direction::South =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;South or North&quot;</span>);<br>        &#125;,<br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;West&quot;</span>),<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="if-let-匹配"><a href="#if-let-匹配" class="headerlink" title="if let 匹配"></a>if let 匹配</h2><p>适用于只有一个模式的值需要被处理，其它值直接忽略的场景。</p><p>可以用 <code>if let</code> 的方式来实现：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3u8</span>);<br>    <span class="hljs-comment">// 用 match 来处理就要写成下面这样</span><br>    <span class="hljs-keyword">match</span> v &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>        _ =&gt; (),<br>    &#125;<br><br><span class="hljs-comment">// 用 if let 的方式来实现</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-number">3</span>) = v &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>**当你只要匹配一个条件，且忽略其他条件时就用 <code>if let</code> ，否则都用 <code>match</code>**。</p><h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>模式是 Rust 中的特殊语法，它用来匹配类型中的结构和数据，它往往和 <code>match</code> 表达式联用，以实现强大的模式匹配能力。模式一般由以下内容组合而成：</p><ul><li>字面值</li><li>解构的数组、枚举、结构体或者元组</li><li>变量</li><li>通配符</li><li>占位符</li></ul><h3 id="所有可能用到模式的地方"><a href="#所有可能用到模式的地方" class="headerlink" title="所有可能用到模式的地方"></a>所有可能用到模式的地方</h3><h4 id="match-分支"><a href="#match-分支" class="headerlink" title="match 分支"></a>match 分支</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> VALUE &#123;<br>    PATTERN =&gt; EXPRESSION,<br>    PATTERN =&gt; EXPRESSION,<br>    PATTERN =&gt; EXPRESSION,<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，<code>match</code> 的每个分支就是一个<strong>模式</strong>，因为 <code>match</code> 匹配是穷尽式的，因此我们往往需要一个特殊的模式 <code>_</code>，来匹配剩余的所有情况：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> VALUE &#123;<br>    PATTERN =&gt; EXPRESSION,<br>    PATTERN =&gt; EXPRESSION,<br>    _ =&gt; EXPRESSION,<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="if-let-分支"><a href="#if-let-分支" class="headerlink" title="if let 分支"></a>if let 分支</h4><p><code>if let</code> 往往用于匹配一个模式，而忽略剩下的所有模式的场景：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">PATTERN</span> = SOME_VALUE &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="while-let-条件循环"><a href="#while-let-条件循环" class="headerlink" title="while let 条件循环"></a>while let 条件循环</h4><p>一个与 <code>if let</code> 类似的结构是 <code>while let</code> 条件循环，它允许只要模式匹配就一直进行 <code>while</code> 循环。下面展示了一个使用 <code>while let</code> 的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Vec是动态数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stack</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br><span class="hljs-comment">// 向数组尾部插入元素</span><br>stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br>stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);<br>stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// stack.pop从数组尾部弹出元素</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(top) = stack.<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, top);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子会打印出 <code>3</code>、<code>2</code> 接着是 <code>1</code>。<code>pop</code> 方法取出动态数组的最后一个元素并返回 <code>Some(value)</code>，如果动态数组是空的，将返回 <code>None</code>，对于 <code>while</code> 来说，只要 <code>pop</code> 返回 <code>Some</code> 就会一直不停的循环。一旦其返回 <code>None</code>，<code>while</code> 循环停止。我们可以使用 <code>while let</code> 来弹出栈中的每一个元素。</p><h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br><span class="hljs-keyword">for</span> (index, value) <span class="hljs-keyword">in</span> v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; is at index &#123;&#125;&quot;</span>, value, index);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用 <code>enumerate</code> 方法产生一个迭代器，该迭代器每次迭代会返回一个 <code>(索引，值)</code> 形式的元组，然后用 <code>(index,value)</code> 来匹配。</p><h4 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a>let 语句</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">PATTERN</span> = EXPRESSION;<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>这其中，<code>x</code> 也是一种模式绑定，代表将<strong>匹配的值绑定到变量 x 上</strong>。因此，在 Rust 中，<strong>变量名也是一种模式</strong>，只不过它比较朴素很不起眼罢了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (x, y, z) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>上面将一个元组与模式进行匹配（<strong>模式和值的类型必需相同！</strong>），然后把 <code>1, 2, 3</code> 分别绑定到 <code>x, y, z</code> 上。</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数参数也是模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(x: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-comment">// 代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>x</code> 就是一个模式，你还可以在参数中匹配元组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_coordinates</span>(&amp;(x, y): &amp;(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>)) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Current location: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-title function_ invoke__">print_coordinates</span>(&amp;point);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>&amp;(3, 5)</code> 会匹配模式 <code>&amp;(x, y)</code>，因此 <code>x</code> 得到了 <code>3</code>，<code>y</code> 得到了 <code>5</code>。</p><h4 id="let-和-if-let"><a href="#let-和-if-let" class="headerlink" title="let 和 if let"></a>let 和 if let</h4><p>对于以下代码，编译器会报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = some_option_value;<br></code></pre></td></tr></table></figure><p>因为右边的值可能不为 <code>Some</code>，而是 <code>None</code>，这种时候就不能进行匹配，也就是上面的代码遗漏了 <code>None</code> 的匹配。</p><p>类似 <code>let</code> , <code>for</code>和<code>match</code> 都必须要求完全覆盖匹配，才能通过编译( 不可驳模式匹配 )。</p><p>但是对于 <code>if let</code>，就可以这样使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = some_option_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 <code>if let</code> 允许匹配一种模式，而忽略其余的模式( 可驳模式匹配 )。</p><h4 id="let-else-Rust-1-65-新增"><a href="#let-else-Rust-1-65-新增" class="headerlink" title="let-else(Rust 1.65 新增)"></a>let-else(Rust 1.65 新增)</h4><p>使用 <code>let-else</code> 匹配，即可使 <code>let</code> 变为可驳模式。它可以使用 <code>else</code> 分支来处理模式不匹配的情况，但是 <code>else</code> 分支中必须用发散的代码块处理（例如：<code>break</code>、<code>return</code>、<code>panic</code>）。请看下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::<span class="hljs-type">str</span>::FromStr;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_count_item</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u64</span>, &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">it</span> = s.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">let</span> (<span class="hljs-title function_ invoke__">Some</span>(count_str), <span class="hljs-title function_ invoke__">Some</span>(item)) = (it.<span class="hljs-title function_ invoke__">next</span>(), it.<span class="hljs-title function_ invoke__">next</span>()) <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Can&#x27;t segment count item pair: &#x27;&#123;s&#125;&#x27;&quot;</span>);<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Ok</span>(count) = <span class="hljs-type">u64</span>::<span class="hljs-title function_ invoke__">from_str</span>(count_str) <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Can&#x27;t parse integer: &#x27;&#123;count_str&#125;&#x27;&quot;</span>);<br>    &#125;;<br>    <span class="hljs-comment">// error: `else` clause of `let...else` does not diverge</span><br>    <span class="hljs-comment">// let Ok(count) = u64::from_str(count_str) else &#123; 0 &#125;;</span><br>    (count, item)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">get_count_item</span>(<span class="hljs-string">&quot;3 chairs&quot;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&quot;chairs&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>与 <code>match</code> 和 <code>if let</code> 相比，<code>let-else</code> 的一个显著特点在于其解包成功时所创建的变量具有更广的作用域。在 <code>let-else</code> 语句中，成功匹配后的变量不再仅限于特定分支内使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// if let</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = some_option_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br>&#125;<br><br><span class="hljs-comment">// let-else</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = some_option_value <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x);<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>if let</code> 写法里的 <code>x</code> 只能在 <code>if</code> 分支内使用，而 <code>let-else</code> 写法里的 <code>x</code> 则可以在 <code>let</code> 之外使用。</p><h2 id="全模式列表"><a href="#全模式列表" class="headerlink" title="全模式列表"></a>全模式列表</h2><h3 id="匹配字面值"><a href="#匹配字面值" class="headerlink" title="匹配字面值"></a>匹配字面值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one&quot;</span>), <span class="hljs-comment">// 这段代码会打印 `one` 因为 `x` 的值是 1</span><br>    <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;two&quot;</span>),<br>    <span class="hljs-number">3</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;anything&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">match</span> x &#123;<br>        <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">50</span>) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got 50&quot;</span>),<br>        <span class="hljs-title function_ invoke__">Some</span>(y) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Matched, y = &#123;:?&#125;&quot;</span>, y), <span class="hljs-comment">// 输出结果： Matched，y = 5</span><br>        _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Default case, x = &#123;:?&#125;&quot;</span>, x),<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;at the end: x = &#123;:?&#125;, y = &#123;:?&#125;&quot;</span>, x, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦 <code>match</code> 表达式执行完毕，其作用域也就结束了，同理内部 <code>y</code> 的作用域也结束了。最后的 <code>println!</code> 会打印 <code>at the end: x = Some(5), y = 10</code>。</p><h3 id="单分支多模式"><a href="#单分支多模式" class="headerlink" title="单分支多模式"></a>单分支多模式</h3><p>在 <code>match</code> 表达式中，可以使用 <code>|</code> 语法匹配多个模式，它代表 <strong>或</strong>的意思。例如，如下代码将 <code>x</code> 的值与匹配分支相比较，第一个分支有 <strong>或</strong> 选项，意味着如果 <code>x</code> 的值匹配此分支的任何一个模式，它就会运行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-number">1</span> | <span class="hljs-number">2</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one or two&quot;</span>), <span class="hljs-comment">// 输出结果：one or two</span><br>    <span class="hljs-number">3</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;anything&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过序列-匹配值的范围"><a href="#通过序列-匹配值的范围" class="headerlink" title="通过序列 ..&#x3D; 匹配值的范围"></a>通过序列 ..&#x3D; 匹配值的范围</h3><p>在数值类型中我们有讲到一个序列语法，该语法不仅可以用于循环中，还能用于匹配模式。</p><p><code>..=</code> 语法允许你匹配一个闭区间序列内的值。在如下代码中，当模式匹配任何在此序列内的值时，该分支会执行：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;one through five&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;something else&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>x</code> 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 <code>|</code> 运算符表达相同的意思更为方便；相比 <code>1..=5</code>，使用 <code>|</code> 则不得不指定 <code>1 | 2 | 3 | 4 | 5</code> 这五个值，而使用 <code>..=</code> 指定序列就简短的多，比如希望匹配比如从 1 到 1000 的数字的时候！</p><p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。</p><p>如下是一个使用字符类型序列的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-string">&#x27;c&#x27;</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>..=<span class="hljs-string">&#x27;j&#x27;</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;early ASCII letter&quot;</span>), <span class="hljs-comment">// 输出结果： early ASCII letter</span><br>    <span class="hljs-string">&#x27;k&#x27;</span>..=<span class="hljs-string">&#x27;z&#x27;</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;late ASCII letter&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;something else&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解构并分解值"><a href="#解构并分解值" class="headerlink" title="解构并分解值"></a>解构并分解值</h3><p>也可以使用模式来解构结构体、枚举、元组、数组和引用。</p><h4 id="解构结构体"><a href="#解构结构体" class="headerlink" title="解构结构体"></a>解构结构体</h4><p>下面代码展示了如何用 <code>let</code> 解构一个带有两个字段 <code>x</code> 和 <code>y</code> 的结构体 <code>Point</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">7</span> &#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">Point</span> &#123; x, y &#125; = p;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">0</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">7</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码创建了变量 <code>x</code> 和 <code>y</code>，与结构体 <code>p</code> 中的 <code>x</code> 和 <code>y</code> 字段相匹配。其结果是变量 <code>x</code> 和 <code>y</code> 包含结构体 <code>p</code> 中的值。</p><p>下文展示了固定某个字段的匹配方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">7</span> &#125;;<br><br>    <span class="hljs-keyword">match</span> p &#123;<br>        Point &#123; x, y: <span class="hljs-number">0</span> &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;On the x axis at &#123;&#125;&quot;</span>, x),<br>        Point &#123; x: <span class="hljs-number">0</span>, y &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;On the y axis at &#123;&#125;&quot;</span>, y),<br>        Point &#123; x, y &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;On neither axis: (&#123;&#125;, &#123;&#125;)&quot;</span>, x, y),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解构枚举"><a href="#解构枚举" class="headerlink" title="解构枚举"></a>解构枚举</h4><p>下面代码以 <code>Message</code> 枚举为例，编写一个 <code>match</code> 使用模式解构每一个内部值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>);<br><br>    <span class="hljs-keyword">match</span> msg &#123;<br>        Message::Quit =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The Quit variant has no data to destructure.&quot;</span>)<br>        &#125;<br>        Message::Move &#123; x, y &#125; =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Move in the x direction &#123;&#125; and in the y direction &#123;&#125;&quot;</span>,<br>                x,<br>                y<br>            );<br>        &#125;<br>        Message::<span class="hljs-title function_ invoke__">Write</span>(text) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Text message: &#123;&#125;&quot;</span>, text),<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(r, g, b) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,<br>                r,<br>                g,<br>                b<br>            )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解构嵌套的结构体和枚举"><a href="#解构嵌套的结构体和枚举" class="headerlink" title="解构嵌套的结构体和枚举"></a>解构嵌套的结构体和枚举</h4><p>例如使用下面的代码来同时支持 RGB 和 HSV 色彩模式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>   <span class="hljs-title function_ invoke__">Rgb</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>   <span class="hljs-title function_ invoke__">Hsv</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(Color),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(Color::<span class="hljs-title function_ invoke__">Hsv</span>(<span class="hljs-number">0</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>));<br><br>    <span class="hljs-keyword">match</span> msg &#123;<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(Color::<span class="hljs-title function_ invoke__">Rgb</span>(r, g, b)) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Change the color to red &#123;&#125;, green &#123;&#125;, and blue &#123;&#125;&quot;</span>,<br>                r,<br>                g,<br>                b<br>            )<br>        &#125;<br>        Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(Color::<span class="hljs-title function_ invoke__">Hsv</span>(h, s, v)) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<br>                <span class="hljs-string">&quot;Change the color to hue &#123;&#125;, saturation &#123;&#125;, and value &#123;&#125;&quot;</span>,<br>                h,<br>                s,<br>                v<br>            )<br>        &#125;<br>        _ =&gt; ()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解构结构体和元组"><a href="#解构结构体和元组" class="headerlink" title="解构结构体和元组"></a>解构结构体和元组</h4><p>如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>     x: <span class="hljs-type">i32</span>,<br>     y: <span class="hljs-type">i32</span>,<br> &#125;<br><br><span class="hljs-keyword">let</span> ((feet, inches), Point &#123;x, y&#125;) = ((<span class="hljs-number">3</span>, <span class="hljs-number">10</span>), Point &#123; x: <span class="hljs-number">3</span>, y: -<span class="hljs-number">10</span> &#125;);<br></code></pre></td></tr></table></figure><h4 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a>解构数组</h4><p>对于数组，我们可以用类似元组的方式解构，分为两种情况：</p><p>定长数组</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: [<span class="hljs-type">u16</span>; <span class="hljs-number">2</span>] = [<span class="hljs-number">114</span>, <span class="hljs-number">514</span>];<br><span class="hljs-keyword">let</span> [x, y] = arr;<br><br><span class="hljs-built_in">assert_eq!</span>(x, <span class="hljs-number">114</span>);<br><span class="hljs-built_in">assert_eq!</span>(y, <span class="hljs-number">514</span>);<br><br></code></pre></td></tr></table></figure><p>不定长数组</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: &amp;[<span class="hljs-type">u16</span>] = &amp;[<span class="hljs-number">114</span>, <span class="hljs-number">514</span>];<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> [x, ..] = arr &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(x, &amp;<span class="hljs-number">114</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> &amp;[.., y] = arr &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(y, <span class="hljs-number">514</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span>: &amp;[<span class="hljs-type">u16</span>] = &amp;[];<br><br><span class="hljs-built_in">assert!</span>(matches!(arr, [..]));<br><span class="hljs-built_in">assert!</span>(!matches!(arr, [x, ..]));<br></code></pre></td></tr></table></figure><h3 id="忽略模式中的值"><a href="#忽略模式中的值" class="headerlink" title="忽略模式中的值"></a>忽略模式中的值</h3><p>有时忽略模式中的一些值是很有用的，比如在 <code>match</code> 中的最后一个分支使用 <code>_</code> 模式匹配所有剩余的值。 你也可以在另一个模式中使用 <code>_</code> 模式，使用一个以下划线开始的名称，或者使用 <code>..</code> 忽略所剩部分的值。</p><h4 id="使用-忽略整个值"><a href="#使用-忽略整个值" class="headerlink" title="使用 _ 忽略整个值"></a>使用 _ 忽略整个值</h4><p>虽然 <code>_</code> 模式作为 <code>match</code> 表达式最后的分支特别有用，但是它的作用还不限于此。例如可以将其用于函数参数中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 这段代码会完全忽略作为第一个参数传递的值 `3`，并会打印出 `This code only uses the y parameter: 4`。</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(_: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;This code only uses the y parameter: &#123;&#125;&quot;</span>, y);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">foo</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用嵌套的-忽略部分值"><a href="#使用嵌套的-忽略部分值" class="headerlink" title="使用嵌套的 _ 忽略部分值"></a>使用嵌套的 _ 忽略部分值</h4><p>可以在一个模式内部使用 <code>_</code> 忽略部分值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">setting_value</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">new_setting_value</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">match</span> (setting_value, new_setting_value) &#123;<br><span class="hljs-comment">// 第一个匹配分支，我们不关心里面的值，只关心元组中两个元素的类型，因此对于 `Some` 中的值，直接进行忽略</span><br>    (<span class="hljs-title function_ invoke__">Some</span>(_), <span class="hljs-title function_ invoke__">Some</span>(_)) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can&#x27;t overwrite an existing customized value&quot;</span>);<br>    &#125;<br>    _ =&gt; &#123;<br>        setting_value = new_setting_value;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;setting is &#123;:?&#125;&quot;</span>, setting_value);<br><br><span class="hljs-comment">// 这段代码会打印出 `Can&#x27;t overwrite an existing customized value` 接着是 `setting is Some(5)`。</span><br></code></pre></td></tr></table></figure><p>还可以在一个模式中的多处使用下划线来忽略特定值，如下所示，这里忽略了一个五元元组中的第二和第四个值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">numbers</span> = (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>);<br><br><span class="hljs-keyword">match</span> numbers &#123;<br>    (first, _, third, _, fifth) =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Some numbers: &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, first, third, fifth)<br>    &#125;,<br>&#125;<br><br><span class="hljs-comment">// 这会打印出 `Some numbers: 2, 8, 32`, 值 4 和 16 会被忽略。</span><br></code></pre></td></tr></table></figure><h4 id="使用下划线开头忽略未使用的变量"><a href="#使用下划线开头忽略未使用的变量" class="headerlink" title="使用下划线开头忽略未使用的变量"></a>使用下划线开头忽略未使用的变量</h4><p>如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-comment">// 这里得到了警告说未使用变量 `y`，至于 `x` 则没有警告。</span><br></code></pre></td></tr></table></figure><p>注意, 只使用 <code>_</code> 和使用以下划线开头的名称有些微妙的不同：比如 <strong><code>_x</code> 仍会将值绑定到变量，而 <code>_</code> 则完全不会绑定</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello!&quot;</span>));<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(_s) = s &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found a string&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, s);<br></code></pre></td></tr></table></figure><p><code>s</code> 是一个拥有所有权的动态字符串，在上面代码中，我们会得到一个错误，因为 <code>s</code> 的值会被转移给 <code>_s</code>，在 <code>println!</code> 中再次使用 <code>s</code> 会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0382]: borrow of partially moved value: `s`<br> --&gt; src/main.rs:8:22<br>  |<br>4 |     <span class="hljs-keyword">if</span> <span class="hljs-built_in">let</span> Some(_s) = s &#123;<br>  |                 -- value partially moved here<br>...<br>8 |     println!(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, s);<br>  |                      ^ value borrowed here after partial move<br></code></pre></td></tr></table></figure><p>只使用下划线本身，则并不会绑定值，因为 <code>s</code> 没有被移动进 <code>_</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello!&quot;</span>));<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(_) = s &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;found a string&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, s);<br></code></pre></td></tr></table></figure><h4 id="用-忽略剩余值"><a href="#用-忽略剩余值" class="headerlink" title="用 .. 忽略剩余值"></a>用 .. 忽略剩余值</h4><p>对于有多个部分的值，可以使用 <code>..</code> 语法来只使用部分值而忽略其它值，这样也不用再为每一个被忽略的值都单独列出下划线。<code>..</code> 模式会忽略模式中剩余的任何没有显式匹配的值部分。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>    z: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = Point &#123; x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-keyword">match</span> origin &#123;<br>    Point &#123; x, .. &#125; =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is &#123;&#125;&quot;</span>, x),<br>&#125;<br></code></pre></td></tr></table></figure><p>这里列出了 <code>x</code> 值，接着使用了 <code>..</code> 模式来忽略其它字段，这样的写法要比一一列出其它字段，然后用 <code>_</code> 忽略简洁的多。</p><p>还可以用 <code>..</code> 来忽略元组中间的某些值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">numbers</span> = (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>);<br><br>    <span class="hljs-keyword">match</span> numbers &#123;<br>        (first, .., last) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Some numbers: &#123;&#125;, &#123;&#125;&quot;</span>, first, last);<br>        &#125;,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用 <code>first</code> 和 <code>last</code> 来匹配第一个和最后一个值。<code>..</code> 将匹配并忽略中间的所有值。</p><h3 id="匹配守卫提供的额外条件"><a href="#匹配守卫提供的额外条件" class="headerlink" title="匹配守卫提供的额外条件"></a>匹配守卫提供的额外条件</h3><p><strong>匹配守卫</strong>（_match guard_）是一个位于 <code>match</code> 分支模式之后的额外 <code>if</code> 条件，它能为分支模式提供更进一步的匹配条件。</p><p>这个条件可以使用模式中创建的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">4</span>);<br><br><span class="hljs-keyword">match</span> num &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(x) <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">5</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;less than five: &#123;&#125;&quot;</span>, x),<br>    <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, x),<br>    <span class="hljs-literal">None</span> =&gt; (),<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子会打印出 <code>less than five: 4</code>。当 <code>num</code> 与模式中第一个分支匹配时，<code>Some(4)</code> 可以与 <code>Some(x)</code> 匹配，接着匹配守卫检查 <code>x</code> 值是否小于 5，因为 4 小于 5，所以第一个分支被选择。</p><p>也可以在匹配守卫中使用 <strong>或</strong> 运算符 <code>|</code> 来指定多个模式，<strong>同时匹配守卫的条件会作用于所有的模式</strong>。下面代码展示了匹配守卫与 <code>|</code> 的优先级。这个例子中看起来好像 <code>if y</code> 只作用于 <code>6</code>，但实际上匹配守卫 <code>if y</code> 作用于 <code>4</code>、<code>5</code> <strong>和</strong> <code>6</code> ，在满足 <code>x</code> 属于 <code>4 | 5 | 6</code> 后才会判断 <code>y</code> 是否为 <code>true</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = <span class="hljs-literal">false</span>;<br><br><span class="hljs-keyword">match</span> x &#123;<br>    <span class="hljs-number">4</span> | <span class="hljs-number">5</span> | <span class="hljs-number">6</span> <span class="hljs-keyword">if</span> y =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;yes&quot;</span>),<br>    _ =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;no&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><p>这个匹配条件表明此分支只匹配 <code>x</code> 值为 <code>4</code>、<code>5</code> 或 <code>6</code> <strong>同时</strong> <code>y</code> 为 <code>true</code> 的情况。</p><p>虽然在第一个分支中，<code>x</code> 匹配了模式 <code>4</code> ，但是对于匹配守卫 <code>if y</code> 来说，因为 <code>y</code> 是 <code>false</code>，因此该守卫条件的值永远是 <code>false</code>，也意味着第一个分支永远无法被匹配。</p><h3 id="绑定"><a href="#绑定" class="headerlink" title="@绑定"></a>@绑定</h3><p><code>@</code>（读作 at）运算符允许为一个字段绑定另外一个变量。下面例子中，我们希望测试 <code>Message::Hello</code> 的 <code>id</code> 字段是否位于 <code>3..=7</code> 范围内，同时也希望能将其值绑定到 <code>id_variable</code> 变量中以便此分支中相关的代码可以使用它。我们可以将 <code>id_variable</code> 命名为 <code>id</code>，与字段同名，不过出于示例的目的这里选择了不同的名称。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Hello &#123; id: <span class="hljs-type">i32</span> &#125;,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">msg</span> = Message::Hello &#123; id: <span class="hljs-number">5</span> &#125;;<br><br><span class="hljs-keyword">match</span> msg &#123;<br>    Message::Hello &#123; id: id_variable @ <span class="hljs-number">3</span>..=<span class="hljs-number">7</span> &#125; =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Found an id in range: &#123;&#125;&quot;</span>, id_variable)<br>    &#125;,<br>    Message::Hello &#123; id: <span class="hljs-number">10</span>..=<span class="hljs-number">12</span> &#125; =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Found an id in another range&quot;</span>)<br>    &#125;,<br>    Message::Hello &#123; id &#125; =&gt; &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Found some other id: &#123;&#125;&quot;</span>, id)<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>上例会打印出 <code>Found an id in range: 5</code>。通过在 <code>3..=7</code> 之前指定 <code>id_variable @</code>，我们捕获了任何匹配此范围的值并同时将该值绑定到变量 <code>id_variable</code> 上。</p><p>第二个分支只在模式中指定了一个范围，<code>id</code> 字段的值可以是 <code>10、11 或 12</code>，不过这个模式的代码并不知情也不能使用 <code>id</code> 字段中的值，因为没有将 <code>id</code> 值保存进一个变量。</p><p>最后一个分支指定了一个没有范围的变量，此时确实拥有可以用于分支代码的变量 <code>id</code>，因为这里使用了结构体字段简写语法。不过此分支中没有像头两个分支那样对 <code>id</code> 字段的值进行测试：任何值都会匹配此分支。</p><p>当你既想要限定分支范围，又想要使用分支的变量时，就可以用 <code>@</code> 来绑定到一个新的变量上，实现想要的功能。</p><h4 id="前绑定后解构-Rust-1-56-新增"><a href="#前绑定后解构-Rust-1-56-新增" class="headerlink" title="@前绑定后解构(Rust 1.56 新增)"></a>@前绑定后解构(Rust 1.56 新增)</h4><p>使用 <code>@</code> 还可以在绑定新变量的同时，对目标进行解构：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    x: <span class="hljs-type">i32</span>,<br>    y: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 绑定新变量 `p`，同时对 `Point` 进行解构</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> @ Point &#123;x: px, y: py &#125; = Point &#123;x: <span class="hljs-number">10</span>, y: <span class="hljs-number">23</span>&#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x: &#123;&#125;, y: &#123;&#125;&quot;</span>, px, py);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, p);<br><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">point</span> = Point &#123;x: <span class="hljs-number">10</span>, y: <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> @ Point &#123;x: <span class="hljs-number">10</span>, y&#125; = point &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x is 10 and y is &#123;&#125; in &#123;:?&#125;&quot;</span>, y, p);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x was not 10 :(&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="新特性-Rust-1-53-新增"><a href="#新特性-Rust-1-53-新增" class="headerlink" title="@新特性(Rust 1.53 新增)"></a>@新特性(Rust 1.53 新增)</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-number">1</span> &#123;<br>    <span class="hljs-comment">// Rust 1.53 之后的版本才支持</span><br>        num @ (<span class="hljs-number">1</span> | <span class="hljs-number">2</span>) =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, num);<br>        &#125;<br>        _ =&gt; &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 14 方法(Method)</title>
    <link href="/2024/11/12/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2014%20%E6%96%B9%E6%B3%95(Method)/"/>
    <url>/2024/11/12/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2014%20%E6%96%B9%E6%B3%95(Method)/</url>
    
    <content type="html"><![CDATA[<h2 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h2><p>Rust 使用 <code>impl</code> 来定义方法，例如以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Circle</span> &#123;<br>    x: <span class="hljs-type">f64</span>,<br>    y: <span class="hljs-type">f64</span>,<br>    radius: <span class="hljs-type">f64</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-comment">// new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字</span><br>    <span class="hljs-comment">// 这种方法往往用于初始化当前结构体的实例</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: <span class="hljs-type">f64</span>, y: <span class="hljs-type">f64</span>, radius: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> Circle &#123;<br>        Circle &#123;<br>            x: x,<br>            y: y,<br>            radius: radius,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Circle的方法，&amp;self表示借用当前的Circle结构体</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        std::<span class="hljs-type">f64</span>::consts::PI * (<span class="hljs-keyword">self</span>.radius * <span class="hljs-keyword">self</span>.radius)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里先不详细展开讲解，只是先建立对方法定义的大致印象。下面的图片将 Rust 方法定义与其它语言的方法定义做了对比：</p><p><img src="/img/rust_method.png"></p><p>可以看出，其它语言中所有定义都在 <code>class</code> 中，但是 Rust 的对象定义和方法定义是分离的，这种数据和使用分离的方式，会给予使用者极高的灵活度。</p><p>再来看一个例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<br>        <span class="hljs-string">&quot;The area of the rectangle is &#123;&#125; square pixels.&quot;</span>,<br>        rect1.<span class="hljs-title function_ invoke__">area</span>()<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>该例子定义了一个 <code>Rectangle</code> 结构体，并且在其上定义了一个 <code>area</code> 方法，用于计算该矩形的面积。</p><p><code>impl Rectangle &#123;&#125;</code> 表示为 <code>Rectangle</code> 实现方法（<code>impl</code> 是实现 <em>implementation</em> 的缩写），这样的写法表明 <code>impl</code> 语句块中的一切都是跟 <code>Rectangle</code> 相关联的。</p><h3 id="self、-self-和-mut-self"><a href="#self、-self-和-mut-self" class="headerlink" title="self、&amp;self 和 &amp;mut self"></a>self、&amp;self 和 &amp;mut self</h3><p> <code>area</code> 的签名中，我们使用 <code>&amp;self</code> 替代 <code>rectangle: &amp;Rectangle</code>，<code>&amp;self</code> 其实是 <code>self: &amp;Self</code> 的简写（注意大小写）。在一个 <code>impl</code> 块内，<code>Self</code> 指代被实现方法的结构体类型，<code>self</code> 指代此类型的实例，换句话说，<code>self</code> 指代的是 <code>Rectangle</code> 结构体实例，这样的写法会让我们的代码简洁很多，而且非常便于理解：我们为哪个结构体实现方法，那么 <code>self</code> 就是指代哪个结构体的实例。</p><p>需要注意的是，<code>self</code> 依然有所有权的概念：</p><ul><li><code>self</code> 表示 <code>Rectangle</code> 的所有权转移到该方法中，这种形式用的较少</li><li><code>&amp;self</code> 表示该方法对 <code>Rectangle</code> 的不可变借用</li><li><code>&amp;mut self</code> 表示可变借用</li></ul><p>总之，<code>self</code> 的使用就跟函数参数一样，要严格遵守 Rust 的所有权规则。</p><p>简单总结下，使用方法代替函数有以下好处：</p><ul><li>不用在函数签名中重复书写 <code>self</code> 对应的类型</li><li>代码的组织性和内聚性更强，对于代码维护和阅读来说，好处巨大</li></ul><h3 id="方法名跟结构体字段名相同"><a href="#方法名跟结构体字段名相同" class="headerlink" title="方法名跟结构体字段名相同"></a>方法名跟结构体字段名相同</h3><p>在 Rust 中，允许方法名跟结构体的字段名相同：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">width</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt; <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-keyword">if</span> rect1.<span class="hljs-title function_ invoke__">width</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The rectangle has a nonzero width; it is &#123;&#125;&quot;</span>, rect1.width);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用 <code>rect1.width()</code> 时，Rust 知道我们调用的是它的方法，如果使用 <code>rect1.width</code>，则是访问它的字段。</p><p>一般来说，方法跟字段同名，往往适用于实现 <code>getter</code> 访问器，例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> my &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>        width: <span class="hljs-type">u32</span>,<br>        <span class="hljs-keyword">pub</span> height: <span class="hljs-type">u32</span>,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(width: <span class="hljs-type">u32</span>, height: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            Rectangle &#123; width, height &#125;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">width</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.width;<br>        &#125;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">height</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.height;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = my::Rectangle::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">30</span>, <span class="hljs-number">50</span>);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="hljs-title function_ invoke__">width</span>()); <span class="hljs-comment">// OK</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, rect1.<span class="hljs-title function_ invoke__">height</span>()); <span class="hljs-comment">// OK</span><br>    <span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, rect1.width); // Error - the visibility of field defaults to private</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, rect1.height); <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当从模块外部访问结构体时，结构体的字段默认是私有的，其目的是隐藏信息（封装）。我们如果想要从模块外部获取 <code>Rectangle</code> 的字段，只需把它的 <code>new</code>， <code>width</code> 和 <code>height</code> 方法设置为公开可见，那么用户就可以创建一个矩形，同时通过访问器 <code>rect1.width()</code> 和 <code>rect1.height()</code> 方法来获取矩形的宽度和高度。</p><p>因为 <code>width</code> 字段是私有的，当用户访问 <code>rect1.width</code> 字段时，就会报错。注意在此例中，<code>Self</code> 指代的就是被实现方法的结构体 <code>Rectangle</code>。</p><p>特别的是，这种默认的可见性（私有的）可以通过 <code>pub</code> 进行覆盖，这样对于模块外部来说，就可以直接访问使用 <code>pub</code> 修饰的字段而无需通过访问器。这种可见性仅当从定义结构的模块外部访问时才重要，并且具有隐藏信息（封装）的目的。</p><h2 id="带有多个参数的方法"><a href="#带有多个参数的方法" class="headerlink" title="带有多个参数的方法"></a>带有多个参数的方法</h2><p>方法和函数一样，可以使用多个参数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt; other.width &amp;&amp; <span class="hljs-keyword">self</span>.height &gt; other.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123; width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect2</span> = Rectangle &#123; width: <span class="hljs-number">10</span>, height: <span class="hljs-number">40</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect3</span> = Rectangle &#123; width: <span class="hljs-number">60</span>, height: <span class="hljs-number">45</span> &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can rect1 hold rect2? &#123;&#125;&quot;</span>, rect1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;rect2));<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Can rect1 hold rect3? &#123;&#125;&quot;</span>, rect1.<span class="hljs-title function_ invoke__">can_hold</span>(&amp;rect3));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h2><p>这种定义在 <code>impl</code> 中且没有 <code>self</code> 的函数被称之为<strong>关联函数</strong>： 因为它没有 <code>self</code>，不能用 <code>f.read()</code> 的形式调用，因此它是一个函数而不是方法，它又在 <code>impl</code> 中，与结构体紧密关联，因此称为关联函数。</p><p>在之前的代码中，我们已经多次使用过关联函数，例如 <code>String::from</code>，用于创建一个动态字符串。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(w: <span class="hljs-type">u32</span>, h: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> Rectangle &#123;<br>        Rectangle &#123; width: w, height: h &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Rust 中有一个约定俗成的规则，使用 <code>new</code> 来作为构造器的名称，出于设计上的考虑，Rust 特地没有用 <code>new</code> 作为关键字。</p></blockquote><p>因为是函数，所以不能用 <code>.</code> 的方式来调用，我们需要用 <code>::</code> 来调用，例如 <code>let sq = Rectangle::new(3, 3);</code>。这个方法位于结构体的命名空间中：<code>::</code> 语法用于关联函数和模块创建的命名空间。</p><h2 id="多个-impl-定义"><a href="#多个-impl-定义" class="headerlink" title="多个 impl 定义"></a>多个 impl 定义</h2><p>Rust 允许我们为一个结构体定义多个 <code>impl</code> 块，目的是提供更多的灵活性和代码组织性，例如当方法多了后，可以把相关的方法组织在同一个 <code>impl</code> 块中，那么就可以形成多个 <code>impl</code> 块，各自完成一块儿目标：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">can_hold</span>(&amp;<span class="hljs-keyword">self</span>, other: &amp;Rectangle) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>        <span class="hljs-keyword">self</span>.width &gt; other.width &amp;&amp; <span class="hljs-keyword">self</span>.height &gt; other.height<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为枚举实现方法"><a href="#为枚举实现方法" class="headerlink" title="为枚举实现方法"></a>为枚举实现方法</h2><p>枚举类型之所以强大，不仅仅在于它好用、可以<a href="https://course.rs/basic/compound-type/enum.html#%E5%90%8C%E4%B8%80%E5%8C%96%E7%B1%BB%E5%9E%8B">同一化类型</a>，还在于，我们可以像结构体一样，为枚举实现方法：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Message</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">call</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 在这里定义方法体</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Message::<span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>    m.<span class="hljs-title function_ invoke__">call</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 13 枚举</title>
    <link href="/2024/11/12/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2013%20%E6%9E%9A%E4%B8%BE/"/>
    <url>/2024/11/12/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2013%20%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<p>枚举(enum 或 enumeration)允许你通过列举可能的成员来定义一个<strong>枚举类型</strong>，例如扑克牌花色：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PokerSuit</span> &#123;<br>  Clubs,<br>  Spades,<br>  Diamonds,<br>  Hearts,<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>枚举类型是一个类型，它会包含所有可能的枚举成员，而枚举值是该类型中的具体某个成员的实例。</strong></p><h2 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h2><p>我们通过 <code>::</code> 操作符来访问 <code>PokerSuit</code> 下的具体成员，从代码可以清晰看出，<code>heart</code> 和 <code>diamond</code> 都是 <code>PokerSuit</code> 枚举类型的，接着可以定义一个函数来使用它们：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">heart</span> = PokerSuit::Hearts;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">diamond</span> = PokerSuit::Diamonds;<br><br>    <span class="hljs-title function_ invoke__">print_suit</span>(heart); <span class="hljs-comment">// 输出结果：Hearts</span><br>    <span class="hljs-title function_ invoke__">print_suit</span>(diamond); <span class="hljs-comment">// 输出结果：Diamonds</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_suit</span>(card: PokerSuit) &#123;<br>    <span class="hljs-comment">// 需要在定义 enum PokerSuit 的上面添加上 #[derive(Debug)]，否则会报 card 没有实现 Debug</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,card);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>任何类型的数据都可以放入枚举成员中</strong>：例如字符串、数值、结构体甚至另一个枚举。</p><p>看以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Message</span> &#123;<br>    Quit,<br>    Move &#123; x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span> &#125;,<br>    <span class="hljs-title function_ invoke__">Write</span>(<span class="hljs-type">String</span>),<br>    <span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m1</span> = Message::Quit;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m2</span> = Message::Move&#123;x:<span class="hljs-number">1</span>,y:<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m3</span> = Message::<span class="hljs-title function_ invoke__">ChangeColor</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该枚举类型代表一条消息，它包含四个不同的成员：</p><ul><li><code>Quit</code> 没有任何关联数据</li><li><code>Move</code> 包含一个匿名结构体</li><li><code>Write</code> 包含一个 <code>String</code> 字符串</li><li><code>ChangeColor</code> 包含三个 <code>i32</code></li></ul><h2 id="同一化类型"><a href="#同一化类型" class="headerlink" title="同一化类型"></a>同一化类型</h2><p>同一化类型的用途：</p><ol><li>类型安全：枚举确保一个值只能是其变体之一，这提供了类型安全，防止了不匹配的情况。</li><li>模式匹配：Rust 的  <code>match</code>  语句允许你根据枚举的变体执行不同的代码块，这是处理枚举值的强大工具。</li><li>代码清晰：使用枚举可以更清晰地表达代码的意图，尤其是在处理有限数量的不同情况时。</li></ol><p>示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 考虑一个简单的IP地址枚举，它有两种变体：IPv4和IPv6：</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>    V4,<br>    V6,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">route</span>(ip_kind: IpAddrKind) &#123;<br>    <span class="hljs-comment">// 这里的代码适用于任何IpAddrKind类型的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，  <code>IpAddrKind::V4</code>  和  <code>IpAddrKind::V6</code>  都是  <code>IpAddrKind</code>  类型的值。你可以将它们传递给接受  <code>IpAddrKind</code>  类型的函数，如  <code>route</code>  函数。尽管  <code>V4</code>  和  <code>V6</code>  是不同的变体，它们都被统一视为  <code>IpAddrKind</code>  类型。</p><h2 id="Option-枚举用于处理空值"><a href="#Option-枚举用于处理空值" class="headerlink" title="Option 枚举用于处理空值"></a>Option 枚举用于处理空值</h2><p><code>Option</code> 枚举包含两个成员，一个成员表示含有值：<code>Some(T)</code>, 另一个表示没有值：<code>None</code>，定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(T),<br>    <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>T</code> 是泛型参数，<code>Some(T)</code>表示该枚举成员的数据类型是 <code>T</code>，换句话说，<code>Some</code> 可以包含任何类型的数据。</p><p>再来看以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">some_number</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;a string&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">absent_number</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br></code></pre></td></tr></table></figure><p>如果使用 <code>None</code> 而不是 <code>Some</code>，需要告诉 Rust <code>Option&lt;T&gt;</code> 是什么类型的，因为编译器只通过 <code>None</code> 值无法推断出 <code>Some</code> 成员保存的值的类型。</p><p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，而这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。</p><p>简而言之，因为 <code>Option&lt;T&gt;</code> 和 <code>T</code>（这里 <code>T</code> 可以是任何类型）是不同的类型，例如，这段代码不能编译，因为它尝试将 <code>Option&lt;i8&gt;</code>(<code>Option&lt;T&gt;</code>) 与 <code>i8</code>(<code>T</code>) 相加：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: <span class="hljs-type">i8</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i8</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = x + y;<br></code></pre></td></tr></table></figure><p>如果运行这些代码，将得到类似这样的错误信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is<br>not satisfied<br> --&gt;<br>  |<br>5 |     <span class="hljs-built_in">let</span> <span class="hljs-built_in">sum</span> = x + y;<br>  |                 ^ no implementation <span class="hljs-keyword">for</span> `i8 + std::option::Option&lt;i8&gt;`<br>  |<br></code></pre></td></tr></table></figure><p>事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8&gt;</code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值，我们可以放心使用而无需做空值检查。只有当使用 <code>Option&lt;i8&gt;</code>（或者任何用到的类型）的时候才需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p><p>换句话说，在对 <code>Option&lt;T&gt;</code> 进行 <code>T</code> 的运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：期望某值不为空但实际上为空的情况。</p><p>不再担心会错误的使用一个空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的 <code>Option&lt;T&gt;</code> 中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是 <code>Option&lt;T&gt;</code> 类型，你就 <strong>可以</strong> 安全的认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 12 结构体</title>
    <link href="/2024/11/11/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2012%20%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2024/11/11/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2012%20%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h2 id="结构体语法"><a href="#结构体语法" class="headerlink" title="结构体语法"></a>结构体语法</h2><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>一个结构体由几部分组成：</p><ul><li>通过关键字 <code>struct</code> 定义</li><li>一个清晰明确的结构体 <code>名称</code></li><li>几个有名字的结构体 <code>字段</code></li></ul><p>例如, 以下结构体定义了某网站的用户：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    active: <span class="hljs-type">bool</span>,<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>该结构体名称是 <code>User</code>，拥有 4 个字段，且每个字段都有对应的字段名及类型声明，例如 <code>username</code> 代表了用户名，是一个可变的 <code>String</code> 类型。</p><h3 id="创建结构体实例"><a href="#创建结构体实例" class="headerlink" title="创建结构体实例"></a>创建结构体实例</h3><p>有几点值得注意:</p><ul><li>初始化实例时，<strong>每个字段</strong>都需要进行初始化</li><li>初始化时的字段顺序<strong>不需要</strong>和结构体定义时的顺序一致</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>active: <span class="hljs-literal">true</span>,<br>sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="访问结构体字段"><a href="#访问结构体字段" class="headerlink" title="访问结构体字段"></a>访问结构体字段</h3><p>通过 <code>.</code> 操作符即可访问结构体实例内部的字段值，也可以修改它们：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">user1</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>active: <span class="hljs-literal">true</span>,<br>sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br><br>user1.email = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;anotheremail@example.com&quot;</span>);<br></code></pre></td></tr></table></figure><p>需要注意：</p><ul><li>必须要将结构体实例声明为可变的，才能修改其中的字段</li><li>Rust 不支持将某个结构体某个字段标记为可变。</li></ul><h3 id="简化结构体创建"><a href="#简化结构体创建" class="headerlink" title="简化结构体创建"></a>简化结构体创建</h3><p>当函数参数和结构体字段同名时，可以直接使用缩略的方式进行初始化，跟 TypeScript 中一模一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">build_user</span>(email: <span class="hljs-type">String</span>, username: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> User &#123;<br>    User &#123;<br>        email,<br>        username,<br>        active: <span class="hljs-literal">true</span>,<br>        sign_in_count: <span class="hljs-number">1</span>,<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体更新语法"><a href="#结构体更新语法" class="headerlink" title="结构体更新语法"></a>结构体更新语法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>..user1<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>..</code> 语法表明凡是我们没有显式声明的字段，全部从 <code>user1</code> 中自动获取。需要注意的是 <code>..user1</code> <strong>必须在结构体的尾部使用</strong>。</p><blockquote><p>结构体更新语法跟赋值语句 <code>=</code> 非常相像，因此在上面代码中，<code>user1</code> 的部分字段所有权被转移到 <code>user2</code> 中：<code>username</code> 字段发生了所有权转移，作为结果，<code>user1</code> 无法再被使用。</p></blockquote><h2 id="元组结构体-Tuple-Struct"><a href="#元组结构体-Tuple-Struct" class="headerlink" title="元组结构体(Tuple Struct)"></a>元组结构体(Tuple Struct)</h2><p>结构体必须要有名称，但是结构体的字段可以没有名称，这种结构体长得很像元组，因此被称为元组结构体，例如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = <span class="hljs-title function_ invoke__">Point</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>元组结构体在你希望有一个整体名称，但是又不关心里面字段的名称时将非常有用。例如上面的 <code>Point</code> 元组结构体，众所周知 3D 点是 <code>(x, y, z)</code> 形式的坐标点，因此我们无需再为内部的字段逐一命名为：<code>x</code>, <code>y</code>, <code>z</code>。</p><h2 id="单元结构体-Unit-like-Struct"><a href="#单元结构体-Unit-like-Struct" class="headerlink" title="单元结构体(Unit-like Struct)"></a>单元结构体(Unit-like Struct)</h2><p>如果你定义一个类型，但是不关心该类型的内容，只关心它的行为时，就可以使用 <code>单元结构体</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AlwaysEqual</span>;<br><br><span class="hljs-comment">// 实例化不需要花括号或圆括号</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">subject</span> = AlwaysEqual;<br><br><span class="hljs-comment">// 我们不关心 AlwaysEqual 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SomeTrait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">AlwaysEqual</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结构体数据的所有权"><a href="#结构体数据的所有权" class="headerlink" title="结构体数据的所有权"></a>结构体数据的所有权</h2><ul><li>实现了 <code>Copy</code> 特征的类型无需所有权转移，可以直接在赋值时进行数据拷贝，如<code>active(bool)</code> 和 <code>sign_in_count(u64)</code> 字段。</li><li>没有实现 <code>Copy</code> 特征的类型所有权发生转移，如 <code>username(String)</code>，导致了 <code>user1</code> 无法再被使用，但是 <code>user1</code> 内部的其它字段不受影响。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user1</span> = User &#123;<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someone@example.com&quot;</span>),<br>    username: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;someusername123&quot;</span>),<br>    active: <span class="hljs-literal">true</span>,<br>    sign_in_count: <span class="hljs-number">1</span>,<br>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>    active: user1.active,<br>    username: user1.username,<br>    email: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;another@example.com&quot;</span>),<br>    sign_in_count: user1.sign_in_count,<br>&#125;;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, user1.active);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, user1.email);<br><span class="hljs-comment">// 下面这行会报错</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, user1);<br></code></pre></td></tr></table></figure><h2 id="使用-derive-Debug-来打印结构体的信息"><a href="#使用-derive-Debug-来打印结构体的信息" class="headerlink" title="使用 #[derive(Debug)] 来打印结构体的信息"></a>使用 <code>#[derive(Debug)]</code> 来打印结构体的信息</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;&#125;&quot;</span>, rect1); <span class="hljs-comment">// 报错</span><br>    <span class="hljs-comment">// error[E0277]: `Rectangle` doesn&#x27;t implement `std::fmt::Display`</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1); <span class="hljs-comment">// 报错</span><br>    <span class="hljs-comment">// error[E0277]: `Rectangle` doesn&#x27;t implement `Debug`</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Rust 默认没有实现 <code>Display</code> 特征，<code>&#123;&#125;</code> 不可用</p></li><li><p>Rust 默认没有实现 <code>Debug</code> 特征，<code>&#123;:?&#125;</code>不可用 ，为了实现，有两种方式可以选择：</p><ul><li>手动实现</li><li>使用 <code>derive</code> 派生实现</li></ul></li></ul><p>后者简单得多：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    width: <span class="hljs-type">u32</span>,<br>    height: <span class="hljs-type">u32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rect1</span> = Rectangle &#123;<br>        width: <span class="hljs-number">30</span>,<br>        height: <span class="hljs-number">50</span>,<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;rect1 is &#123;:?&#125;&quot;</span>, rect1);<br>    <span class="hljs-comment">// 输出结果：rect1 is Rectangle &#123; width: 30, height: 50 &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当结构体较大时，我们可能希望能够有更好的输出表现，此时可以使用 <strong><code>&#123;:#?&#125;</code></strong> 来替代 <code>&#123;:?&#125;</code>，输出如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">rect1 is Rectangle &#123;<br>    width: 30,<br>    height: 50,<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 11 元组(tuple)</title>
    <link href="/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2011%20%E5%85%83%E7%BB%84(tuple)/"/>
    <url>/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2011%20%E5%85%83%E7%BB%84(tuple)/</url>
    
    <content type="html"><![CDATA[<p>元组是由多种类型组合到一起形成的，因此它是复合类型，元组的长度是固定的，元组中元素的顺序也是固定的。</p><h2 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h2><p>可以通过以下语法创建一个元组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 变量 tup 被绑定了一个元组值 (500, 6.4, 1)，该元组的类型是 (i32, f64, u8) </span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用模式匹配解构元组"><a href="#用模式匹配解构元组" class="headerlink" title="用模式匹配解构元组"></a>用模式匹配解构元组</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span> = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> (x, y, z) = tup;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>    <span class="hljs-comment">// 输出结果：The value of y is: 6.4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码首先创建一个元组，然后将其绑定到 <code>tup</code> 上，接着使用 <code>let (x, y, z) = tup;</code> 来完成一次模式匹配，因为元组是 <code>(n1, n2, n3)</code> 形式的，因此我们用一模一样的 <code>(x, y, z)</code> 形式来进行匹配，元组中对应的值会绑定到变量 <code>x</code>， <code>y</code>， <code>z</code>上。这就是解构：用同样的形式把一个复杂对象中的值匹配出来。</p><h2 id="用-来访问元组"><a href="#用-来访问元组" class="headerlink" title="用 . 来访问元组"></a>用 <code>.</code> 来访问元组</h2><p>模式匹配可以让我们一次性把元组中的值全部或者部分获取出来，如果只想要访问某个特定元素，那模式匹配就略显繁琐，对此，Rust 提供了 <code>.</code> 的访问方式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">five_hundred</span> = x.<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">six_point_four</span> = x.<span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span> = x.<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>和其它语言的数组、字符串一样，<strong>元组的索引从 0 开始</strong>。</p><h2 id="元组的使用示例"><a href="#元组的使用示例" class="headerlink" title="元组的使用示例"></a>元组的使用示例</h2><p>元组在函数返回值场景很常用，例如下面的代码，可以使用元组返回多个值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> (s2, len) = <span class="hljs-title function_ invoke__">calculate_length</span>(s1);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s2, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>, <span class="hljs-type">usize</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = s.<span class="hljs-title function_ invoke__">len</span>(); <span class="hljs-comment">// len() 返回字符串的长度</span><br><br>    (s, length)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>calculate_length</code> 函数接收 <code>s1</code> 字符串的所有权，然后计算字符串的长度，接着把字符串所有权和字符串长度再返回给 <code>s2</code> 和 <code>len</code> 变量。</p><p>在其他语言中，可以用结构体来声明一个三维空间中的点，例如 <code>Point(10, 20, 30)</code>，虽然使用 Rust 元组也可以做到：<code>(10, 20, 30)</code>，但是这样写有个非常重大的缺陷：</p><p><strong>不具备任何清晰的含义</strong>，在下一章节中，会提到一种与元组类似的结构体，<code>元组结构体</code>，可以解决这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 10 数组(array)</title>
    <link href="/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2010%20%E6%95%B0%E7%BB%84(array)/"/>
    <url>/2024/11/08/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%2010%20%E6%95%B0%E7%BB%84(array)/</url>
    
    <content type="html"><![CDATA[<p>在 Rust 中，最常用的数组有两种：</p><ul><li>第一种是速度很快但是长度固定的 <code>array</code></li><li>第二种是可动态增长的但是有性能损耗的 <code>Vector</code></li></ul><p>对于本章节，我们的重点还是放在数组 <code>array</code> 上。数组的具体定义很简单：将多个类型相同的元素依次组合在一起，就是一个数组。</p><p>数组的三要素：</p><ul><li>长度固定</li><li>元素必须有相同的类型</li><li>依次线性排列</li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>在 Rust 中，数组是这样定义的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 1. 简单字面量定义, 编译器自动推导出数组的类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>    <br><span class="hljs-comment">// 2. 显式声明：声明类型和长度</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// 3. 某个值重复出现 N 次的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = [<span class="hljs-number">1</span>; <span class="hljs-number">3</span>];<br><span class="hljs-comment">// let c = [1, 1, 1]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>数组类型是通过方括号语法声明<code>[T; N]</code>，<code>T</code> 是元素类型，分号后面的 <code>N</code> 是数组长度，数组类型也从侧面说明了<strong>数组的元素类型要统一，长度要固定</strong>。</p><h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><p>因为数组是连续存放元素的，因此可以通过索引的方式来访问存放其中的元素：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>];<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = a[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 获取a数组第一个元素, first = 9</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">second</span> = a[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 获取第二个元素, second = 8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与许多语言类似，<strong>数组的索引下标是从 0 开始</strong>的。此处，<code>first</code> 获取到的值是 <code>9</code>，<code>second</code> 是 <code>8</code>。</p><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第一个元素：&#123;&#125;&quot;</span>, arr[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;不存在的元素：&#123;&#125;&quot;</span>, arr[<span class="hljs-number">5</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>cargo run</code> 来运行代码，因为数组只有 5 个元素，如果我们试图输入 <code>5</code> 去访问第 6 个元素，则会访问到不存在的数组元素，最终程序会崩溃退出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">error: this operation will panic at runtime<br> --&gt; src/main.rs:4:27<br>  |<br>4 |     println!(<span class="hljs-string">&quot;不存在的元素：&#123;&#125;&quot;</span>, arr[5]);<br>  |                                  ^^^^^^ index out of bounds: the length is 5 but the index is 5<br>  |<br>  = note: `#[deny(unconditional_panic)]` on by default<br><br>error: could not compile `compound_types` (bin <span class="hljs-string">&quot;compound_types&quot;</span>) due to 1 previous error<br></code></pre></td></tr></table></figure><p>这就是数组访问越界，访问了数组中不存在的元素，导致 Rust 运行时错误。程序因此退出并显示错误消息，未执行最后的 <code>println!</code> 语句。</p><h2 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h2><p>切片允许你引用集合中的部分连续片段，而不是整个集合，对于数组也是，数组切片允许我们引用数组的一部分：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span>: &amp;[<span class="hljs-type">i32</span>] = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br><br><span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>上面的数组切片 <code>slice</code> 的类型是<code>&amp;[i32]</code>，与之对比，数组的类型是<code>[i32;5]</code>，简单总结下切片的特点：</p><ul><li>切片的长度可以与数组不同，并不是固定的，而是取决于你使用时指定的起始和结束位置</li><li>创建切片的代价非常小，因为切片只是针对底层数组的一个引用</li><li>切片类型 [T] 拥有不固定的大小，而切片引用类型 &amp;[T] 则具有固定的大小，因为 Rust 很多时候都需要固定大小数据类型，因此 &amp;[T] 更有用，<code>&amp;str</code> 字符串切片也同理</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 编译器自动推导出one的类型</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">one</span>             = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-comment">// 显式类型标注</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">two</span>: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>]    = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">blank1</span>          = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">blank2</span>: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">0</span>; <span class="hljs-number">3</span>];<br><br>  <span class="hljs-comment">// arrays是一个二维数组，其中每一个元素都是一个数组，元素类型是[u8; 3]</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">arrays</span>: [[<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>]; <span class="hljs-number">4</span>]  = [one, two, blank1, blank2];<br><br>  <span class="hljs-comment">// 借用arrays的元素用作循环中</span><br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">a</span> <span class="hljs-keyword">in</span> &amp;arrays &#123;<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;:?&#125;: &quot;</span>, a);<br>    <span class="hljs-comment">// 将a变成一个迭代器，用于循环</span><br>    <span class="hljs-comment">// 你也可以直接用for n in a &#123;&#125;来进行循环</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">n</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>      <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;\t&#123;&#125; + 10 = &#123;&#125;&quot;</span>, n, n+<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">sum</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 0..a.len,是一个 Rust 的语法糖，其实就等于一个数组，元素是从0,1,2一直增加到到a.len-1</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..a.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>      sum += a[i];<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;\t(&#123;:?&#125; = &#123;&#125;)&quot;</span>, a, sum);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>做个总结，数组虽然很简单，但是其实还是存在几个要注意的点：</p><ul><li><strong>数组类型容易跟数组切片混淆</strong>，[T;n] 描述了一个数组的类型，而 [T] 描述了切片的类型， 因为切片是运行期的数据结构，它的长度无法在编译期得知，因此不能用 [T;n] 的形式去描述</li><li><code>[u8; 3]</code>和<code>[u8; 4]</code>是不同的类型，数组的长度也是类型的一部分</li><li>**在实际开发中，使用最多的是数组切片[T]**，我们往往通过引用的方式去使用<code>&amp;[T]</code>，因为后者有固定的类型大小</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 8 切片(slice)</title>
    <link href="/2024/11/07/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%208%20%E5%88%87%E7%89%87(slice)/"/>
    <url>/2024/11/07/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%208%20%E5%88%87%E7%89%87(slice)/</url>
    
    <content type="html"><![CDATA[<p>切片并不是 Rust 独有的概念，在 Go 语言中就非常流行，它允许你引用集合中部分连续的元素序列，而不是引用整个集合。</p><p>Rust常见的数据类型中，有三种类型已支持Slice操作: <strong>String类型</strong>、<strong>Array类型</strong>和<strong>Vec类型</strong></p><p>对于字符串而言，切片就是对 <code>String</code> 类型中某一部分的引用，它看起来像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = &amp;s[<span class="hljs-number">6</span>..<span class="hljs-number">11</span>];<br></code></pre></td></tr></table></figure><p><code>hello</code> 没有引用整个 <code>String s</code>，而是引用了 <code>s</code> 的一部分内容，通过 <code>[0..5]</code> 的方式来指定。</p><h2 id="切片语法"><a href="#切片语法" class="headerlink" title="切片语法"></a>切片语法</h2><p>创建切片使用方括号包括的一个序列：<strong>[开始索引..终止索引]</strong></p><blockquote><p>其中开始索引是切片中第一个元素的索引位置，而终止索引是最后一个元素后面的索引位置。</p></blockquote><p>对于 <code>let world = &amp;s[6..11];</code> 来说，<code>world</code> 是一个切片，该切片的指针指向 <code>s</code> 的第 7 个字节(索引从 0 开始, 6 是第 7 个字节)，且该切片的长度是 <code>5</code> 个字节。</p><p><img src="/img/rust_slice.jpg"></p><p>在使用 Rust 的 <code>..</code> <a href="https://course.rs/basic/base-type/numbers.html#%E5%BA%8F%E5%88%97range">range 序列</a>语法时，如果你想从索引 0 开始，可以使用如下的方式，这两个是等效的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>同样的，如果你的切片想要包含 <code>String</code> 的最后一个字节，则可以这样使用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">4</span>..len];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">4</span>..];<br></code></pre></td></tr></table></figure><p>你也可以截取完整的 <code>String</code> 切片：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[<span class="hljs-number">0</span>..len];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;s[..];<br></code></pre></td></tr></table></figure><h2 id="索引边界"><a href="#索引边界" class="headerlink" title="索引边界"></a>索引边界</h2><p>在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界，例如中文在 UTF-8 中占用三个字节，下面的代码就会崩溃：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;中国人&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,a);<br></code></pre></td></tr></table></figure><p>因为我们只取 <code>s</code> 字符串的前两个字节，但是本例中每个汉字占用三个字节，因此没有落在边界处，也就是连 <code>中</code> 字都取不完整，此时程序会直接崩溃退出，如果改成 <code>&amp;s[0..3]</code>，则可以正常通过编译。 因此，当你需要对字符串做切片索引操作时，需要格外小心这一点，关于该如何操作 UTF-8 字符串，参见<a href="https://course.rs/basic/compound-type/string-slice.html#%E6%93%8D%E4%BD%9C-utf-8-%E5%AD%97%E7%AC%A6%E4%B8%B2">这里</a>。</p><h2 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h2><h3 id="字符串字面量是切片"><a href="#字符串字面量是切片" class="headerlink" title="字符串字面量是切片"></a>字符串字面量是切片</h3><p>之前提到过字符串字面量，但是没有提到它的类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>实际上，<code>s</code> 的类型是 <code>&amp;str</code>，因此你也可以这样声明：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span>: &amp;<span class="hljs-type">str</span> = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br></code></pre></td></tr></table></figure><p>该切片指向了程序可执行文件中的某个点，这也是为什么字符串字面量是不可变的，因为 <code>&amp;str</code> 是一个不可变引用。</p><p>字符串切片的类型标识是 <code>&amp;str</code>，因此我们可以这样声明一个函数，输入 <code>String</code> 类型，返回它的切片：<code>fn first_word(s: &amp;String) -&gt; &amp;str</code> 。</p><p>有了切片就可以写出这样的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">word</span> = <span class="hljs-title function_ invoke__">first_word</span>(&amp;s);<br><br>    s.<span class="hljs-title function_ invoke__">clear</span>(); <span class="hljs-comment">// error!</span><br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;the first word is: &#123;&#125;&quot;</span>, word);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">first_word</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    &amp;s[..<span class="hljs-number">1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器报错如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable<br>  --&gt; src/main.rs:18:5<br>   |<br>16 |     <span class="hljs-built_in">let</span> word = first_word(&amp;s);<br>   |                           -- immutable borrow occurs here<br>17 |<br>18 |     s.clear(); // error!<br>   |     ^^^^^^^^^ mutable borrow occurs here<br>19 |<br>20 |     println!(<span class="hljs-string">&quot;the first word is: &#123;&#125;&quot;</span>, word);<br>   |                                       ---- immutable borrow later used here<br></code></pre></td></tr></table></figure><p>回忆一下借用的规则：当我们已经有了可变借用时，就无法再拥有不可变的借用。因为 <code>clear</code> 需要清空改变 <code>String</code>，因此它需要一个可变借用（利用 VSCode 可以看到该方法的声明是 <code>pub fn clear(&amp;mut self)</code> ，参数是对自身的可变借用 ）；而之后的 <code>println!</code> 又使用了不可变借用，也就是在 <code>s.clear()</code> 处可变借用与不可变借用试图同时生效，因此编译无法通过。</p><p>从上述代码可以看出，Rust 不仅让我们的 <code>API</code> 更加容易使用，而且也在编译期就消除了大量错误！</p><h2 id="其他切片"><a href="#其他切片" class="headerlink" title="其他切片"></a>其他切片</h2><p>因为切片是对集合的部分引用，因此不仅仅字符串有切片，其它集合类型也有，例如数组：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span> = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br><br><span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure><p>该数组切片的类型是 <code>&amp;[i32]</code>，数组切片和字符串切片的工作方式是一样的，例如持有一个引用指向原始数组的某个元素和长度。</p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul><li><code>len()</code> 获取 slice 元素个数</li><li><code>is_empty()</code> 判断slice是否为空</li><li><code>contains()</code> 判断是否包含某个元素</li><li><code>repeat()</code> 重复slice指定次数</li><li><code>reverse()</code> 反转slice</li><li><code>join()</code> 将各元素压平(flatten)并通过指定的分隔符连接起来</li><li><code>swap()</code> 交换两个索引处的元素，如 <code>s.swap(1.3)</code></li><li><code>windows()</code> 以指定大小的窗口进行滚动法代</li><li><code>starts_with()</code> 判断 slice 是否以某个 slice 开头</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 7 引用与借用</title>
    <link href="/2024/11/05/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%207%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/"/>
    <url>/2024/11/05/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%207%20%E5%BC%95%E7%94%A8%E4%B8%8E%E5%80%9F%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Rust 通过 <code>借用(Borrowing)</code> 这个概念来达成上述的目的，**获取变量的引用，称之为借用(borrowing)**。</p><h2 id="引用与解引用"><a href="#引用与解引用" class="headerlink" title="引用与解引用"></a>引用与解引用</h2><p>常规引用是一个指针类型，指向了对象存储的内存地址。在下面代码中，我们创建一个 <code>i32</code> 值的引用 <code>y</code>，然后使用解引用运算符来解出 <code>y</code> 所使用的值:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;x;<br><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, x);<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">5</span>, *y);<br>&#125;<br></code></pre></td></tr></table></figure><p>变量 <code>x</code> 存放了一个 <code>i32</code> 值 <code>5</code>。<code>y</code> 是 <code>x</code> 的一个引用。可以断言 <code>x</code> 等于 <code>5</code>。然而，如果希望对 <code>y</code> 的值做出断言，必须使用 <code>*y</code> 来解出引用所指向的值（也就是<strong>解引用</strong>）。一旦解引用了 <code>y</code>，就可以访问 <code>y</code> 所指向的整型值并可以与 <code>5</code> 做比较。</p><h2 id="不可变引用"><a href="#不可变引用" class="headerlink" title="不可变引用"></a>不可变引用</h2><p>下面的代码，我们用 <code>s1</code> 的引用作为参数传递给 <code>calculate_length</code> 函数，而不是把 <code>s1</code> 的所有权转移给该函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s1);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>能注意到两点：</p><ol><li>无需像上章一样：先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁</li><li><code>calculate_length</code> 的参数 <code>s</code> 类型从 <code>String</code> 变为 <code>&amp;String</code></li></ol><p>这里，<code>&amp;</code> 符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：</p><p>![[rust_borrowing.jpg]]<br>通过 <code>&amp;s1</code> 语法，我们创建了一个<strong>指向 <code>s1</code> 的引用</strong>，但是并不拥有它。因为并不拥有这个值，当引用离开作用域后，其指向的值也不会被丢弃。</p><p>同理，函数 <code>calculate_length</code> 使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123; <span class="hljs-comment">// s 是对 String 的引用</span><br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125; <span class="hljs-comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span><br>  <span class="hljs-comment">// 所以什么也不会发生</span><br></code></pre></td></tr></table></figure><h2 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h2><p>修改借用的变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">change</span>(&amp;<span class="hljs-keyword">mut</span> s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change</span>(some_string: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) &#123;<br>    some_string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;, world&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，声明 <code>s</code> 是可变类型，其次创建一个可变的引用 <code>&amp;mut s</code> 和接受可变引用参数 <code>some_string: &amp;mut String</code> 的函数。</p><h3 id="可变引用同时只能存在一个"><a href="#可变引用同时只能存在一个" class="headerlink" title="可变引用同时只能存在一个"></a>可变引用同时只能存在一个</h3><p>不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制： <strong>同一作用域，特定数据只能有一个可变引用</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);<br></code></pre></td></tr></table></figure><p>以上代码会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0499]: cannot borrow `s` as mutable more than once at a time 同一时间无法对 `s` 进行两次可变借用<br> --&gt; src/main.rs:5:14<br>  |<br>4 |     <span class="hljs-built_in">let</span> r1 = &amp;mut s;<br>  |              ------ first mutable borrow occurs here 首个可变引用在这里借用<br>5 |     <span class="hljs-built_in">let</span> r2 = &amp;mut s;<br>  |              ^^^^^^ second mutable borrow occurs here 第二个可变引用在这里借用<br>6 |<br>7 |     println!(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);<br>  |                        -- first borrow later used here 第一个借用在这里使用<br></code></pre></td></tr></table></figure><p>这段代码出错的原因在于，第一个可变借用 <code>r1</code> 必须要持续到最后一次使用的位置 <code>println!</code>，在 <code>r1</code> 创建和最后一次使用之间，我们又尝试创建第二个可变借用 <code>r2</code>。</p><p>这是 Rust 编译器的 <code>borrow checker</code> 特性之一</p><p>这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：</p><ul><li>两个或更多的指针同时访问同一数据</li><li>至少有一个指针被用来写入数据</li><li>没有同步数据访问的机制</li></ul><p>数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。而 Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</p><p>很多时候，大括号可以帮我们解决一些编译不通过的问题，通过手动限制变量的作用域：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;<span class="hljs-keyword">mut</span> s;<br><br>&#125; <span class="hljs-comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> s;<br></code></pre></td></tr></table></figure><h3 id="可变引用与不可变引用不能同时存在"><a href="#可变引用与不可变引用不能同时存在" class="headerlink" title="可变引用与不可变引用不能同时存在"></a>可变引用与不可变引用不能同时存在</h3><p>下面的代码会导致一个错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;s; <span class="hljs-comment">// 没问题</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;s; <span class="hljs-comment">// 没问题</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = &amp;<span class="hljs-keyword">mut</span> s; <span class="hljs-comment">// 大问题</span><br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);<br></code></pre></td></tr></table></figure><p>错误如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable<br>        // 无法借用可变 `s` 因为它已经被借用了不可变<br> --&gt; src/main.rs:6:14<br>  |<br>4 |     <span class="hljs-built_in">let</span> r1 = &amp;s; // 没问题<br>  |              -- immutable borrow occurs here 不可变借用发生在这里<br>5 |     <span class="hljs-built_in">let</span> r2 = &amp;s; // 没问题<br>6 |     <span class="hljs-built_in">let</span> r3 = &amp;mut s; // 大问题<br>  |              ^^^^^^ mutable borrow occurs here 可变借用发生在这里<br>7 |<br>8 |     println!(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;</span>, r1, r2, r3);<br>  |                                -- immutable borrow later used here 不可变借用在这里使用<br></code></pre></td></tr></table></figure><p>其实这个也很好理解，正在借用不可变引用的用户，肯定不希望他借用的东西，被另外一个人莫名其妙改变了。多个不可变借用被允许是因为没有人会去试图修改数据，每个人都只读这一份数据而不做修改，因此不用担心数据被污染。</p><blockquote><p>注意，引用的作用域 <code>s</code> 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 <code>&#125;</code></p></blockquote><p>Rust 的编译器一直在优化，早期的时候，引用的作用域跟变量作用域是一致的，这对日常使用带来了很大的困扰，你必须非常小心的去安排可变、不可变变量的借用，免得无法通过编译，例如以下代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;s;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125; and &#123;&#125;&quot;</span>, r1, r2);<br>    <span class="hljs-comment">// 新编译器中，r1,r2作用域在这里结束</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r3</span> = &amp;<span class="hljs-keyword">mut</span> s;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, r3);<br>&#125; <span class="hljs-comment">// 老编译器中，r1、r2、r3作用域在这里结束</span><br>  <span class="hljs-comment">// 新编译器中，r3作用域在这里结束</span><br></code></pre></td></tr></table></figure><p>在老版本的编译器中（Rust 1.31 前），将会报错，因为 <code>r1</code> 和 <code>r2</code> 的作用域在花括号 <code>&#125;</code> 处结束，那么 <code>r3</code> 的借用就会触发 <strong>无法同时借用可变和不可变</strong> 的规则。</p><p>但是在新的编译器中，该代码将顺利通过，因为 <strong>引用作用域的结束位置从花括号变成最后一次使用的位置</strong>，因此 <code>r1</code> 借用和 <code>r2</code> 借用在 <code>println!</code> 后，就结束了，此时 <code>r3</code> 可以顺利借用到可变引用。</p><h2 id="悬垂引用-Dangling-References"><a href="#悬垂引用-Dangling-References" class="headerlink" title="悬垂引用(Dangling References)"></a>悬垂引用(Dangling References)</h2><p>悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。</p><p>让我们尝试创建一个悬垂引用，Rust 会抛出一个编译时错误：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">reference_to_nothing</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &amp;s<br>&#125;<br></code></pre></td></tr></table></figure><p>这里是错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0106]: missing lifetime specifier<br> --&gt; src/main.rs:5:16<br>  |<br>5 | fn dangle() -&gt; &amp;String &#123;<br>  |                ^ expected named lifetime parameter<br>  |<br>  = <span class="hljs-built_in">help</span>: this <span class="hljs-keyword">function</span><span class="hljs-string">&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from</span><br><span class="hljs-string">help: consider using the `&#x27;</span>static` lifetime<br>  |<br>5 | fn dangle() -&gt; &amp;<span class="hljs-string">&#x27;static String &#123;</span><br><span class="hljs-string">  |                ~~~~~~~~</span><br></code></pre></td></tr></table></figure><p>仔细看看 <code>dangle</code> 代码的每一步到底发生了什么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123; <span class="hljs-comment">// dangle 返回一个字符串的引用</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// s 是一个新字符串</span><br><br>    &amp;s <span class="hljs-comment">// 返回字符串 s 的引用</span><br>&#125; <span class="hljs-comment">// 这里 s 离开作用域并被丢弃。其内存被释放。</span><br>  <span class="hljs-comment">// 危险！</span><br></code></pre></td></tr></table></figure><p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放，但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！</p><p>其中一个很好的解决方法是直接返回 <code>String</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">no_dangle</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    s<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就没有任何错误了，最终 <code>String</code> 的 <strong>所有权被转移给外面的调用者</strong>。</p><h2 id="借用规则总结"><a href="#借用规则总结" class="headerlink" title="借用规则总结"></a>借用规则总结</h2><p>总的来说，借用规则如下：</p><ul><li>同一时刻，你只能拥有要么一个可变引用，要么任意多个不可变引用</li><li>引用必须总是有效的</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 6 所有权</title>
    <link href="/2024/11/04/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%206%20%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <url>/2024/11/04/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%206%20%E6%89%80%E6%9C%89%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>零开销内存回收 的一种高效实现方式</p></blockquote><p>Rust是一种系统编程语言，其设计目的是确保内存安全并防止数据竞争，而不依赖垃圾回收器。这种内存安全性主要通过所有权系统来实现。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><h3 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h3><table><thead><tr><th>特性</th><th>静态语言</th><th>动态语言</th></tr></thead><tbody><tr><td><strong>类型检查时间</strong></td><td>编译时</td><td>运行时</td></tr><tr><td><strong>类型安全</strong></td><td>更安全，减少运行时类型错误</td><td>较灵活，但类型错误可能在运行时出现</td></tr><tr><td><strong>性能</strong></td><td>通常更高效，编译器优化</td><td>通常较低，运行时类型检查</td></tr><tr><td><strong>灵活性</strong></td><td>较低，需明确声明类型</td><td>较高，允许在运行时改变类型</td></tr><tr><td><strong>代码简洁性</strong></td><td>需要显式类型声明，代码相对冗长</td><td>通常更简洁，适合快速开发</td></tr><tr><td><strong>开发工具支持</strong></td><td>更强大的静态分析和重构工具</td><td>开发工具支持有限，但在快速开发上占优势</td></tr></tbody></table><h3 id="回收方式对比"><a href="#回收方式对比" class="headerlink" title="回收方式对比"></a>回收方式对比</h3><table><thead><tr><th>特性</th><th>C&#x2F;C++</th><th>JavaScript</th><th>Rust</th></tr></thead><tbody><tr><td><strong>内存管理方式</strong></td><td>手动管理 (Manual Management)</td><td>垃圾回收 (Garbage Collection)</td><td>所有权系统 (Ownership System)</td></tr><tr><td><strong>特点</strong></td><td>- 程序员通过 <code>malloc</code> 和 <code>free</code> (C) 或 <code>new</code> 和 <code>delete</code> (C++) 手动分配和释放内存。<br>- 没有内置的垃圾回收机制。</td><td>- 浏览器和Node.js环境中均使用垃圾回收器（如V8引擎的垃圾回收器）。<br>- 采用标记-清除(Mark-and-Sweep)、标记-压缩(Mark-and-Compact)分代回收等算法。</td><td>- Rust使用所有权系统进行内存管理，编译器在编译时通过静态分析来确保内存安全。<br>- 每个值都有一个所有者，在任何时候只能有一个有效的所有者。<br>- 通过借用（引用）机制来共享数据，同时保证数据竞争和悬垂指针的安全。</td></tr><tr><td><strong>优点</strong></td><td>- 高效且灵活，适用于对性能要求极高的系统级编程。</td><td>- 自动内存管理，适合快速开发和运行在多平台上的应用。</td><td>- 在编译时保证内存安全，没有运行时开销。<br>- 避免了数据竞争和悬垂指针。</td></tr><tr><td><strong>缺点</strong></td><td>- 容易出现内存泄漏、悬垂指针和缓冲区溢出等问题，需要非常小心的内存管理。</td><td>- 垃圾回收机制在某些情况下可能导致性能问题，如UI线程停顿。</td><td>- 需要程序员理解和遵循所有权和借用规则，学习曲线较陡。</td></tr></tbody></table><h2 id="栈-Stack-与堆-Heap"><a href="#栈-Stack-与堆-Heap" class="headerlink" title="栈(Stack)与堆(Heap)"></a>栈(Stack)与堆(Heap)</h2><p>栈和堆是编程语言最核心的数据结构，但是在很多语言中，你并不需要深入了解栈与堆。 但对于 Rust 这样的系统编程语言，值是位于栈上还是堆上非常重要，因为这会影响程序的行为和性能。</p><p>栈和堆的核心目标就是为程序在运行时提供可供使用的内存空间。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈按照顺序存储值并以相反顺序取出值，这也被称作<strong>后进先出</strong>。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，再从顶部拿走。不能从中间也不能从底部增加或拿走盘子！</p><p>增加数据叫做<strong>进栈</strong>，移出数据则叫做<strong>出栈</strong>。</p><p>因为上述的实现方式，栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p><p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的<strong>指针</strong>，该过程被称为<strong>在堆上分配内存</strong>，有时简称为 “分配”(allocating)。</p><p>接着，该指针会被推入<strong>栈</strong>中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的<strong>指针</strong>，来获取数据在堆上的实际内存位置，进而访问该数据。</p><p>由上可知，堆是一种缺乏组织的数据结构。想象一下去餐馆就座吃饭：进入餐馆，告知服务员有几个人，然后服务员找到一个够大的空桌子（堆上分配的内存空间）并领你们过去。如果有人来迟了，他们也可以通过桌号（栈上的指针）来找到你们坐在哪。</p><h3 id="性能区别"><a href="#性能区别" class="headerlink" title="性能区别"></a>性能区别</h3><p>在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。</p><h3 id="所有权与堆栈"><a href="#所有权与堆栈" class="headerlink" title="所有权与堆栈"></a>所有权与堆栈</h3><p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p><p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p><p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是<strong>在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助</strong>。</p><h2 id="所有权原则"><a href="#所有权原则" class="headerlink" title="所有权原则"></a>所有权原则</h2><blockquote><ol><li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li><li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li><li>当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)</li></ol></blockquote><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>作用域是一个变量在程序中有效的范围，假如有这样一个变量：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure><p>变量 <code>s</code> 绑定到了一个字符串字面值，该字符串字面值是硬编码到程序代码中的。<code>s</code> 变量从声明的点开始直到当前作用域的结束都是有效的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;                      <span class="hljs-comment">// s 在这里无效，它尚未声明</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;hello&quot;</span>;   <span class="hljs-comment">// 从此处起，s 是有效的</span><br><br>    <span class="hljs-comment">// 使用 s</span><br>&#125;                      <span class="hljs-comment">// 此作用域已结束，s不再有效</span><br></code></pre></td></tr></table></figure><p>简而言之，<code>s</code> 从创建开始就有效，然后有效期持续到它离开作用域为止，可以看出，就作用域来说，Rust 语言跟其他编程语言没有区别。</p><h2 id="变量绑定背后的数据交互"><a href="#变量绑定背后的数据交互" class="headerlink" title="变量绑定背后的数据交互"></a>变量绑定背后的数据交互</h2><h3 id="转移所有权"><a href="#转移所有权" class="headerlink" title="转移所有权"></a>转移所有权</h3><p>先来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br></code></pre></td></tr></table></figure><p>这段代码并没有发生所有权的转移，原因很简单： 代码首先将 <code>5</code> 绑定到变量 <code>x</code>，接着<strong>拷贝</strong> <code>x</code> 的值赋给 <code>y</code>，最终 <code>x</code> 和 <code>y</code> 都等于 <code>5</code>，因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过<strong>自动拷贝</strong>的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。</p><p>整个过程中的赋值都是通过值拷贝的方式完成（发生在栈中），因此并不需要所有权转移。</p><p>然后再来看一段代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br></code></pre></td></tr></table></figure><p>实际上， <code>String</code> 类型是一个复杂类型，由存储在栈中的<strong>堆指针</strong>、<strong>字符串长度</strong>、<strong>字符串容量</strong>共同组成，其中<strong>堆指针</strong>是最重要的，它指向了真实存储字符串内容的堆内存，至于长度和容量，如果你有 Go 语言的经验，这里就很好理解：容量是堆内存分配空间的大小，长度是目前已经使用的大小。</p><p>总之 <code>String</code> 类型指向了一个堆上的空间，这里存储着它的真实数据，下面对上面代码中的 <code>let s2 = s1</code> 分成两种情况讨论：</p><ol><li><p>拷贝 <code>String</code> 和存储在堆上的字节数组 如果该语句是拷贝所有数据(深拷贝)，那么无论是 <code>String</code> 本身还是底层的堆上数据，都会被全部拷贝，这对于性能而言会造成非常大的影响</p></li><li><p>只拷贝 <code>String</code> 本身 这样的拷贝非常快，因为在 64 位机器上就拷贝了 <code>8字节的指针</code>、<code>8字节的长度</code>、<code>8字节的容量</code>，总计 24 字节，但是带来了新的问题，还记得我们之前提到的所有权规则吧？其中有一条就是：<strong>一个值只允许有一个所有者</strong>，而现在这个值（堆上的真实字符串数据）有了两个所有者：<code>s1</code> 和 <code>s2</code>。</p></li></ol><p>好吧，就假定一个值可以拥有两个所有者，会发生什么呢？</p><p>当变量离开作用域后，Rust 会自动调用 <code>drop</code> 函数并清理变量的堆内存。不过由于两个 <code>String</code> 变量指向了同一位置。这就有了一个问题：当 <code>s1</code> 和 <code>s2</code> 离开作用域，它们都会尝试释放相同的内存。这是一个叫做 <strong>二次释放（double free）</strong> 的错误，也是之前提到过的内存安全性 BUG 之一。两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。</p><p>因此，Rust 这样解决问题：<strong>当 <code>s1</code> 被赋予 <code>s2</code> 后，Rust 认为 <code>s1</code> 不再有效，因此也无需在 <code>s1</code> 离开作用域后 <code>drop</code> 任何东西，这就是把所有权从 <code>s1</code> 转移给了 <code>s2</code>，<code>s1</code> 在被赋予 <code>s2</code> 后就马上失效了</strong>。</p><p>再来看看，在所有权转移后再来使用旧的所有者，会发生什么：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1: &#123;&#125;&quot;</span>, s1)<br></code></pre></td></tr></table></figure><p>由于 Rust 禁止你使用无效的引用，你会看到以下的错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">error[E0382]: borrow of moved value: `s1`<br>  --&gt; src/main.rs:13:24<br>   |<br>11 |     <span class="hljs-built_in">let</span> s1 = String::from(<span class="hljs-string">&quot;Hello&quot;</span>);<br>   |         -- move occurs because `s1` has <span class="hljs-built_in">type</span> `String`, <span class="hljs-built_in">which</span> does not implement the `Copy` trait<br>12 |     <span class="hljs-built_in">let</span> s2 = s1;<br>   |              -- value moved here<br>13 |     println!(<span class="hljs-string">&quot;s1: &#123;&#125;&quot;</span>, s1)<br>   |                        ^^ value borrowed here after move<br>   |<br>   = note: this error originates <span class="hljs-keyword">in</span> the macro `<span class="hljs-variable">$crate</span>::format_args_nl` <span class="hljs-built_in">which</span> comes from the expansion of the macro `println` (<span class="hljs-keyword">in</span> Nightly builds, run with -Z macro-backtrace <span class="hljs-keyword">for</span> more info)<br><span class="hljs-built_in">help</span>: consider cloning the value <span class="hljs-keyword">if</span> the performance cost is acceptable<br>   |<br>12 |     <span class="hljs-built_in">let</span> s2 = s1.clone();<br>   |                ++++++++<br><br>For more information about this error, try `rustc --explain E0382`.<br></code></pre></td></tr></table></figure><p>如果你在其他语言中听说过术语 <strong>浅拷贝(shallow copy)</strong> 和 **深拷贝(deep copy)**，那么拷贝指针、长度和容量而不拷贝数据听起来就像浅拷贝，但是又因为 Rust 同时使第一个变量 <code>s1</code> 无效了，因此这个操作被称为 <strong>移动(move)<strong>，而不是浅拷贝。上面的例子可以解读为 <code>s1</code> 被</strong>移动</strong>到了 <code>s2</code> 中。那么具体发生了什么，用一张图简单说明：</p><p><img src="/img/rust_copy.jpg" alt="拷贝"></p><p>这样就解决了我们之前的问题，<code>s1</code> 不再指向任何数据，只有 <code>s2</code> 是有效的，当 <code>s2</code> 离开作用域，它就会释放内存。 相信此刻，你应该明白了，为什么 Rust 称呼 <code>let a = b</code> 为<strong>变量绑定</strong>了吧？</p><h3 id="克隆（深拷贝）"><a href="#克隆（深拷贝）" class="headerlink" title="克隆（深拷贝）"></a>克隆（深拷贝）</h3><p>首先，<strong>Rust 永远也不会自动创建数据的 “深拷贝”</strong>。因此，任何<strong>自动</strong>的复制都不是深拷贝，可以被认为对运行时性能影响较小。</p><p>如果我们<strong>确实</strong>需要深度复制 <code>String</code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 <code>clone</code> 的方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);<br></code></pre></td></tr></table></figure><p>这段代码能够正常运行，说明 <code>s2</code> 确实完整的复制了 <code>s1</code> 的数据。</p><p>如果代码性能无关紧要，例如初始化程序时或者在某段时间只会执行寥寥数次时，你可以使用 <code>clone</code> 来简化编程。但是对于执行较为频繁的代码（热点路径），使用 <code>clone</code> 会极大的降低程序性能，需要小心使用！</p><h3 id="拷贝（浅拷贝）"><a href="#拷贝（浅拷贝）" class="headerlink" title="拷贝（浅拷贝）"></a>拷贝（浅拷贝）</h3><p>浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。</p><p>再回到之前看过的例子:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = x;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y);<br></code></pre></td></tr></table></figure><p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 <code>clone</code>，不过依然实现了类似深拷贝的效果 —— 没有报所有权的错误。</p><p>原因是像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 <code>y</code> 后使 <code>x</code> 无效（<code>x</code>、<code>y</code> 都仍然有效）。换句话说，这里没有深浅拷贝的区别，因此这里调用 <code>clone</code> 并不会与通常的浅拷贝有什么不同，我们可以不用管它（可以理解成在栈上做了深拷贝）。</p><p>Rust 有一个叫做 <code>Copy</code> 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 <code>Copy</code> 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。</p><p>那么什么类型是可 <code>Copy</code> 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则： <strong>任何基本类型的组合可以 <code>Copy</code> ，不需要分配内存或某种形式资源的类型是可以 <code>Copy</code> 的</strong>。如下是一些 <code>Copy</code> 的类型：</p><ul><li>所有整数类型，比如 <code>u32</code></li><li>布尔类型，<code>bool</code>，它的值是 <code>true</code> 和 <code>false</code></li><li>所有浮点数类型，比如 <code>f64</code></li><li>字符类型，<code>char</code></li><li>元组，当且仅当其包含的类型也都是 <code>Copy</code> 的时候。比如，<code>(i32, i32)</code> 是 <code>Copy</code> 的，但 <code>(i32, String)</code> 就不是</li><li>不可变引用 <code>&amp;T</code> ，例如转移所有权中的最后一个例子，<strong>但是注意：可变引用 <code>&amp;mut T</code> 是不可以 Copy的</strong></li></ul><h2 id="函数传值与返回"><a href="#函数传值与返回" class="headerlink" title="函数传值与返回"></a>函数传值与返回</h2><p>将值传递给函数，一样会发生 <code>移动</code> 或者 <code>复制</code>，就跟 <code>let</code> 语句一样，下面的代码展示了所有权、作用域的规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">// s 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">takes_ownership</span>(s);             <span class="hljs-comment">// s 的值移动到函数里 ...</span><br>                                    <span class="hljs-comment">// ... 所以到这里不再有效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// x 进入作用域</span><br><br>    <span class="hljs-title function_ invoke__">makes_copy</span>(x);                  <span class="hljs-comment">// x 应该移动函数里，</span><br>                                    <span class="hljs-comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span><br><br>&#125; <span class="hljs-comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span><br>  <span class="hljs-comment">// 所以不会有特殊操作</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) &#123; <span class="hljs-comment">// some_string 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) &#123; <span class="hljs-comment">// some_integer 进入作用域</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// 这里，some_integer 移出作用域。不会有特殊操作</span><br></code></pre></td></tr></table></figure><p>同样的，函数返回值也有所有权，例如:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();         <span class="hljs-comment">// gives_ownership 将返回值</span><br>                                        <span class="hljs-comment">// 移给 s1</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// s2 进入作用域</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);  <span class="hljs-comment">// s2 被移动到</span><br>                                        <span class="hljs-comment">// takes_and_gives_back 中,</span><br>                                        <span class="hljs-comment">// 它也将返回值移给 s3</span><br>&#125; <span class="hljs-comment">// 这里, s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，</span><br>  <span class="hljs-comment">// 所以什么也不会发生。s1 移出作用域并被丢弃</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;             <span class="hljs-comment">// gives_ownership 将返回值移动给</span><br>                                             <span class="hljs-comment">// 调用它的函数</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">// some_string 进入作用域.</span><br><br>    some_string                              <span class="hljs-comment">// 返回 some_string 并移出给调用的函数</span><br>&#125;<br><br><span class="hljs-comment">// takes_and_gives_back 将传入字符串并返回该值</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <span class="hljs-comment">// a_string 进入作用域</span><br><br>    a_string  <span class="hljs-comment">// 返回 a_string 并移出给调用的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： <strong>总是把一个值传来传去来使用它</strong>。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 5 流程控制</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%205%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%205%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><h3 id="使用-if-来做分支控制"><a href="#使用-if-来做分支控制" class="headerlink" title="使用 if 来做分支控制"></a>使用 if 来做分支控制</h3><p>不像 Ruby 或 JavaScript 这样的语言，Rust 并不会尝试自动地将非布尔值转换为布尔值。必须总是显式地使用布尔值作为 <code>if</code> 的条件</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> condition == <span class="hljs-literal">true</span> &#123;<br>    <span class="hljs-comment">// A...</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// B...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该代码读作：若 <code>condition</code> 的值为 <code>true</code>，则执行 <code>A</code> 代码，否则执行 <code>B</code> 代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">condition</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">number</span> = <span class="hljs-keyword">if</span> condition &#123;<br>        <span class="hljs-number">5</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-number">6</span><br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码有以下几点要注意：</p><ul><li><strong><code>if</code> 语句块是表达式</strong>，这里我们使用 <code>if</code> 表达式的返回值来给 <code>number</code> 进行赋值：<code>number</code> 的值是 <code>5</code></li><li>用 <code>if</code> 来赋值时，要保证每个分支返回的类型一样（事实上，这种说法不完全准确，见<a href="https://course.rs/appendix/expressions.html#if%E8%A1%A8%E8%BE%BE%E5%BC%8F">这里</a>），此处返回的 <code>5</code> 和 <code>6</code> 就是同一个类型，如果返回类型不一致就会报错</li></ul><h3 id="使用-else-if-来处理多重条件"><a href="#使用-else-if-来处理多重条件" class="headerlink" title="使用 else if 来处理多重条件"></a>使用 else if 来处理多重条件</h3><p>可以将 <code>else if</code> 与 <code>if</code>、<code>else</code> 组合在一起实现更复杂的条件分支判断：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = <span class="hljs-number">6</span>;<br><br>    <span class="hljs-keyword">if</span> n % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 4&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 3&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is divisible by 2&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行时，会按照自上至下的顺序执行每一个分支判断，一旦成功，则跳出 <code>if</code> 语句块，最终本程序会匹配执行 <code>else if n % 3 == 0</code> 的分支，输出 <code>&quot;number is divisible by 3&quot;</code>。</p><blockquote><p>有一点要注意，就算有多个分支能匹配，也只有第一个匹配的分支会被执行！</p></blockquote><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="for-循坏"><a href="#for-循坏" class="headerlink" title="for 循坏"></a>for 循坏</h3><p><code>for</code> 循环是 Rust 的大杀器：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码循环输出一个从 1 到 5 的序列，简单粗暴，核心就在于 <code>for</code> 和 <code>in</code> 的联动，语义表达如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> 元素 <span class="hljs-keyword">in</span> 集合 &#123;<br>  <span class="hljs-comment">// 使用元素干一些你懂我不懂的事情</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，使用 <code>for</code> 时我们往往使用集合的引用形式，除非你不想在后面的代码中继续使用该集合（比如我们这里使用了 <code>container</code> 的引用）。如果不使用引用的话，所有权会被转移（move）到 <code>for</code> 语句块中，后面就无法再使用这个集合了)：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;container &#123;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于实现了 <code>copy</code> 特征的数组（例如 [i32; 10]）而言， <code>for item in arr</code> 并不会把 <code>arr</code> 的所有权转移，而是直接对其进行了拷贝，因此循环之后仍然可以使用 <code>arr</code> 。</p></blockquote><p>如果想在循环中，<strong>修改该元素</strong>，可以使用 <code>mut</code> 关键字：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> collection &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结如下：</p><table><thead><tr><th>使用方法</th><th>等价使用方式</th><th>所有权</th></tr></thead><tbody><tr><td><code>for item in collection</code></td><td><code>for item in IntoIterator::into_iter(collection)</code></td><td>转移所有权</td></tr><tr><td><code>for item in &amp;collection</code></td><td><code>for item in collection.iter()</code></td><td>不可变借用</td></tr><tr><td><code>for item in &amp;mut collection</code></td><td><code>for item in collection.iter_mut()</code></td><td>可变借用</td></tr></tbody></table><p>如果想在循环中<strong>获取元素的索引</strong>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// `.iter()` 方法把 `a` 数组变成一个迭代器</span><br>    <span class="hljs-keyword">for</span> (i, v) <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>, i + <span class="hljs-number">1</span>, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>使用 <code>continue</code> 可以跳过当前当次的循环，开始下次的循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码对 1 到 3 的序列进行迭代，且跳过值为 2 时的循环，输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br>3<br></code></pre></td></tr></table></figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>使用 <code>break</code> 可以直接跳出当前整个循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span> &#123;<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码对 1 到 3 的序列进行迭代，在遇到值为 2 时的跳出整个循环，后面的循环不再执行，输出如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br></code></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>当条件为 <code>true</code> 时，执行循环；条件为 <code>false</code>，跳出循环：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">n</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> n &lt;= <span class="hljs-number">5</span>  &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;!&quot;</span>, n);<br>        n = n + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;我出来了！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>该 <code>while</code> 循环，只有当 <code>n</code> 小于等于 <code>5</code> 时，才执行，否则就立刻跳出循环，因此在上述代码中，它会先从 <code>0</code> 开始，满足条件，进行循环，然后是 <code>1</code>，满足条件，进行循环，最终到 <code>6</code> 的时候，大于 5，不满足条件，跳出 <code>while</code> 循环，执行 <code>我出来了</code> 的打印，然后程序结束：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">0!<br>1!<br>2!<br>3!<br>4!<br>5!<br>我出来了！<br></code></pre></td></tr></table></figure><h3 id="loop-循环"><a href="#loop-循环" class="headerlink" title="loop 循环"></a>loop 循环</h3><p>对于循环而言，<code>loop</code> 循环毋庸置疑，是适用面最高的，它可以适用于所有循环场景（虽然能用，但是在很多场景下， <code>for</code> 和 <code>while</code> 才是最优选择），因为 <code>loop</code> 就是一个简单的无限循环，你可以在内部实现逻辑通过 <code>break</code> 关键字来控制循环何时结束。</p><p>使用 <code>loop</code> 循环一定要打起精神，否则你会写出下面的跑满你一个 CPU 核心的疯子代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;again!&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 该循环会不停的在终端打印输出，直到你使用 `Ctrl-C` 结束程序：</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// again!</span><br><span class="hljs-comment">// ^Cagain!</span><br></code></pre></td></tr></table></figure><p>因此，当使用 <code>loop</code> 时，必不可少的伙伴是 <code>break</code> 关键字，它能让循环在满足某个条件时跳出：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">counter</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-keyword">loop</span> &#123;<br>        counter += <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The result is &#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码当 <code>counter</code> 递增到 <code>10</code> 时，就会通过 <code>break</code> 返回一个 <code>counter * 2</code> 的值，最后赋给 <code>result</code> 并打印出来。</p><p>这里有几点值得注意：</p><ul><li><strong>break 可以单独使用，也可以带一个返回值</strong>，有些类似 <code>return</code></li><li><strong>loop 是一个表达式</strong>，因此可以返回一个值</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 4 基础类型</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%204%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%204%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>Rust 使用一个相对传统的语法来创建整数（<code>1</code>，<code>2</code>，…）和浮点数（<code>1.0</code>，<code>1.1</code>，…）。整数、浮点数的运算和你在其它语言上见过的一致，都是通过常见的运算符来完成。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p><strong>整数</strong>是没有小数部分的数字。之前使用过的 <code>i32</code> 类型，表示有符号的 32 位整数（ <code>i</code> 是英文单词 <em>integer</em> 的首字母，与之相反的是 <code>u</code>，代表无符号 <code>unsigned</code> 类型）。下表显示了 Rust 中的内置的整数类型：</p><table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody><tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr><tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr><tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr><tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr><tr><td>128 位</td><td><code>i128</code></td><td><code>u128</code></td></tr><tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr></tbody></table><p>类型定义的形式统一为：<code>有无符号 + 类型大小(位数)</code>。<strong>无符号数</strong>表示数字只能取正数和 0，而<strong>有符号</strong>则表示数字可以取正数、负数还有 0。就像在纸上写数字一样：当要强调符号时，数字前面可以带上正号或负号；然而，当很明显确定数字为正数时，就不需要加上正号了。有符号数字以<a href="https://en.wikipedia.org/wiki/Two%27s_complement">补码</a>形式存储。</p><p>每个有符号类型规定的数字范围是 -(2n - 1) ~ 2n - 1 - 1，其中 <code>n</code> 是该定义形式的位长度。因此 <code>i8</code> 可存储数字范围是 -(27) ~ 27 - 1，即 -128 ~ 127。无符号类型可以存储的数字范围是 0 ~ 2n - 1，所以 <code>u8</code> 能够存储的数字为 0 ~ 28 - 1，即 0 ~ 255。</p><p>此外，<code>isize</code> 和 <code>usize</code> 类型取决于程序运行的计算机 CPU 类型： 若 CPU 是 32 位的，则这两个类型是 32 位的，同理，若 CPU 是 64 位，那么它们则是 64 位。</p><p>整形字面量可以用下表的形式书写：</p><table><thead><tr><th>数字字面量</th><th>示例</th></tr></thead><tbody><tr><td>十进制</td><td><code>98_222</code></td></tr><tr><td>十六进制</td><td><code>0xff</code></td></tr><tr><td>八进制</td><td><code>0o77</code></td></tr><tr><td>二进制</td><td><code>0b1111_0000</code></td></tr><tr><td>字节 (仅限于 <code>u8</code>)</td><td><code>b&#39;A&#39;</code></td></tr></tbody></table><blockquote><ul><li>Rust 整型默认使用 <code>i32</code>，例如 <code>let i = 1</code>，那 <code>i</code> 就是 <code>i32</code> 类型，因此可以首选它，同时该类型也往往是性能最好的。</li><li><code>isize</code> 和 <code>usize</code> 的主要应用场景是用作集合的索引。</li></ul></blockquote><h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p><strong>浮点类型数字</strong> 是带有小数点的数字，在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</p><p>下面是一个演示浮点数的示例：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">2.0</span>; <span class="hljs-comment">// f64</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">y</span>: <span class="hljs-type">f32</span> = <span class="hljs-number">3.0</span>; <span class="hljs-comment">// f32</span><br>&#125;<br></code></pre></td></tr></table></figure><p>浮点数根据 <code>IEEE-754</code> 标准实现。<code>f32</code> 类型是单精度浮点型，<code>f64</code> 为双精度。</p><h4 id="浮点数陷阱"><a href="#浮点数陷阱" class="headerlink" title="浮点数陷阱"></a>浮点数陷阱</h4><p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p><ol><li><strong>浮点数往往是你想要数字的近似表达</strong></li><li><strong>浮点数在某些特性上是反直觉的</strong></li></ol><p>为了避免上面说的两个陷阱，需要遵守以下准则：</p><ul><li>避免在浮点数上测试相等性</li><li>当结果在数学上可能存在未定义时，需要格外的小心</li></ul><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 断言0.1 + 0.2与0.3相等</span><br>  <span class="hljs-built_in">assert!</span>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>你可能以为，这段代码没啥问题吧，实际上它会 _panic_（程序崩溃，抛出异常），因为二进制精度问题，导致了 0.1 + 0.2 并不严格等于 0.3，它们可能在小数点 N 位后存在误差。</p><p>那如果非要进行比较呢？可以考虑用这种方式 <code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code> ，具体小于多少，取决于你对精度的需求。</p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p>对于数学上未定义的结果，例如对负数取平方根 <code>-42.1.sqrt()</code> ，会产生一个特殊的结果：Rust 的浮点数类型使用 <code>NaN</code> (not a number) 来处理这些情况。</p><p>**所有跟 <code>NaN</code> 交互的操作，都会返回一个 <code>NaN</code>**，而且 <code>NaN</code> 不能用来比较，下面的代码会崩溃：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = (-<span class="hljs-number">42.0_f32</span>).<span class="hljs-title function_ invoke__">sqrt</span>();<br>  <span class="hljs-built_in">assert_eq!</span>(x, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>出于防御性编程的考虑，可以使用 <code>is_nan()</code> 等方法，可以用来判断一个数值是否是 <code>NaN</code> ：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = (-<span class="hljs-number">42.0_f32</span>).<span class="hljs-title function_ invoke__">sqrt</span>();<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">is_nan</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;未定义的数学行为&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数值类型总结"><a href="#数值类型总结" class="headerlink" title="数值类型总结"></a>数值类型总结</h3><p>之前提到了过 Rust 的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p><ul><li><strong>Rust 拥有相当多的数值类型</strong>. 因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</li><li><strong>类型转换必须是显式的</strong>. Rust 永远也不会偷偷把你的 16bit 整数转换成 32bit 整数</li><li><strong>Rust 的数值上可以使用方法</strong>. 例如你可以用以下方法来将 <code>13.14</code> 取整：<code>13.14_f32.round()</code>，在这里我们使用了类型后缀，因为编译器需要知道 <code>13.14</code> 的具体类型</li></ul><h2 id="字符类型-char"><a href="#字符类型-char" class="headerlink" title="字符类型(char)"></a>字符类型(char)</h2><p>Rust 的字符不仅仅是 <code>ASCII</code>，所有的 <code>Unicode</code> 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。</p><p>由于 <code>Unicode</code> 都是 4 个字节编码，因此字符类型也是占用 4 个字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-string">&#x27;中&#x27;</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;字符&#x27;中&#x27;占用了&#123;&#125;字节的内存大小&quot;</span>,std::mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;x));<br>    <span class="hljs-comment">// 字符&#x27;中&#x27;占用了4字节的内存大小</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="布尔类型-bool"><a href="#布尔类型-bool" class="headerlink" title="布尔类型(bool)"></a>布尔类型(bool)</h2><p>Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>，布尔值占用内存的大小为 <code>1</code> 个字节：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span>: <span class="hljs-type">bool</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 使用类型标注,显式指定f的类型</span><br><br>    <span class="hljs-keyword">if</span> f &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;这是段毫无意义的代码&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用布尔类型的场景主要在于流程控制，例如上述代码的中的 <code>if</code> 就是其中之一。</p><h2 id="单元类型"><a href="#单元类型" class="headerlink" title="单元类型"></a>单元类型</h2><p>单元类型就是 <code>()</code>  ，唯一的值也是 <code>()</code> </p><p> <code>main</code> 函数就返回这个单元类型 <code>()</code>，你不能说 <code>main</code> 函数无返回值，因为没有返回值的函数在 Rust 中是有单独的定义的：<code>发散函数( diverge function )</code>，顾名思义，无法收敛的函数。</p><p>例如常见的 <code>println!()</code> 的返回值也是单元类型 <code>()</code>。</p><p>再比如，你可以用 <code>()</code> 作为 <code>map</code> 的值，表示我们不关注具体的值，只关注 <code>key</code>。 这种用法和 Go 语言的 <em><strong>struct{}</strong></em> 类似，可以作为一个值用来占位，但是完全<strong>不占用</strong>任何内存。</p><h2 id="序列-Range"><a href="#序列-Range" class="headerlink" title="序列(Range)"></a>序列(Range)</h2><p>Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 <code>1..5</code>，生成从 1 到 4 的连续数字，不包含 5 ；<code>1..=5</code>，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..=<span class="hljs-number">5</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,i);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>最终程序输出:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">1<br>2<br>3<br>4<br>5<br><br></code></pre></td></tr></table></figure><p>序列只允许用于数字或字符类型，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。如下是一个使用字符类型序列的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;a&#x27;</span>..=<span class="hljs-string">&#x27;z&#x27;</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,i);<br>    <span class="hljs-comment">// 输出 a～z 的字母</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类型强制转换"><a href="#类型强制转换" class="headerlink" title="类型强制转换"></a>类型强制转换</h2><p>在Rust中，<code>as</code> 关键字用于在原始类型(如 <code>i64</code>、<code>f64</code>、<code>u64</code>、<code>char</code>等)之间进行类型转换。</p><blockquote><p>注意：<code>as</code>关键字并不适用于复合类型，比如<code>String</code>或其他用户定义的类型。对于复合类型的转换，通常需要使用其他方法或函数。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 3 函数</title>
    <link href="/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%203%20%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/01/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%203%20%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="函数组成"><a href="#函数组成" class="headerlink" title="函数组成"></a>函数组成</h2><p>定义一个 <code>add</code> 函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(i: <span class="hljs-type">i32</span>, j: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>i + j<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数如此简单，但是又是如此的五脏俱全，声明函数的关键字 <code>fn</code>，函数名 <code>add()</code>，参数 <code>i</code> 和 <code>j</code>，参数类型和返回值类型都是 <code>i32</code>，总之一切那么的普通，但是又那么的自信，直到你看到了下面这张图：</p><p><img src="/img/rust_fn.png" alt="函数组成"></p><h2 id="函数要点"><a href="#函数要点" class="headerlink" title="函数要点"></a>函数要点</h2><ul><li>函数名和变量名使用<a href="https://course.rs/practice/naming.html">蛇形命名法(snake case)</a>，例如 <code>fn add_two() -&gt; &#123;&#125;</code></li><li>函数的位置可以<strong>随便放</strong>，Rust 不关心我们在哪里定义了函数，只要有定义即可</li><li><strong>每个函数参数</strong>都需要标注类型</li></ul><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>Rust 是静态类型语言，因此需要你为每一个函数参数都标识出它的具体类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-title function_ invoke__">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(i: <span class="hljs-type">i32</span>, j) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>i + j<br>&#125;<br></code></pre></td></tr></table></figure><p>错误如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">error: expected one of `:`, `@`, or `|`, found `)`<br>  --&gt; src/main.rs:10:17<br>   |<br>10 | fn add(i: i32, j) -&gt; i32 &#123;<br>   |                 ^ expected one of `:`, `@`, or `|`<br>   |<br>   = note: anonymous parameters are removed <span class="hljs-keyword">in</span> the 2018 edition (see RFC 1685)<br><span class="hljs-built_in">help</span>: <span class="hljs-keyword">if</span> this is a parameter name, give it a <span class="hljs-built_in">type</span><br>   |<br>10 | fn add(i: i32, j: TypeName) -&gt; i32 &#123;<br>   |                 ++++++++++<br><span class="hljs-built_in">help</span>: <span class="hljs-keyword">if</span> this is a <span class="hljs-built_in">type</span>, explicitly ignore the parameter name<br>   |<br>10 | fn add(i: i32, _: j) -&gt; i32 &#123;<br>   |   <br></code></pre></td></tr></table></figure><h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>函数的返回值就是函数体最后一条表达式的返回值，当然我们也可以使用 <code>return</code> 提前返回</p><p>可以简单记住以下两种形态：</p><ul><li><code>return</code></li><li>没有<code>return</code> + 没有分号</li></ul><p>以下这段代码同时使用 <strong><code>return</code></strong> 和<strong>表达式</strong>作为返回值：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">plus_or_minus</span>(x:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span> &#123;<br>        <span class="hljs-keyword">return</span> x - <span class="hljs-number">5</span><br>    &#125;<br>    x + <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-title function_ invoke__">plus_or_minus</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>2 个重点：</p><ol><li><code>let x = plus_or_minus(5)</code>，说明我们用一个函数的返回值来初始化 <code>x</code> 变量，因此侧面说明了在 Rust 中函数也是表达式，这种写法等同于 <code>let x = 5 + 5;</code></li><li><code>x + 5</code> 没有分号，因为它是一条表达式</li></ol><h2 id="Rust-中的特殊返回类型"><a href="#Rust-中的特殊返回类型" class="headerlink" title="Rust 中的特殊返回类型"></a>Rust 中的特殊返回类型</h2><h3 id="无返回值"><a href="#无返回值" class="headerlink" title="无返回值()"></a>无返回值()</h3><ul><li>函数没有返回值，那么返回一个 <code>()</code></li><li>通过 <code>;</code> 结尾的语句返回一个 <code>()</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 隐式返回一个 ()</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(i: <span class="hljs-type">i32</span>)&#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);  <br>&#125;<br><br><span class="hljs-comment">// 显式的返回了 ()</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">print</span>(i:<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span>() &#123;  <br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, i);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="永不返回的发散函数"><a href="#永不返回的发散函数" class="headerlink" title="永不返回的发散函数 !"></a>永不返回的发散函数 <code>!</code></h3><p>当用 <code>!</code> 作函数返回类型的时候，表示该函数永不返回( diverge function )，特别的，这种语法往往用做会导致程序崩溃的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dead_end</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;你已经到了穷途末路，崩溃吧！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面的函数创建了一个无限循环，该循环永不跳出，因此函数也永不返回：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">forever</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-keyword">loop</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">forever_panic</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 2 变量和可变类型</title>
    <link href="/2024/10/31/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/10/31/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="变量可变性"><a href="#变量可变性" class="headerlink" title="变量可变性"></a>变量可变性</h2><ul><li>Rust 的变量在默认情况下是<strong>不可变的</strong></li><li>通过 <code>mut</code> 关键字让变量变为<strong>可变的</strong></li></ul><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-comment">// 声明不可变变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>x = <span class="hljs-number">6</span>; <span class="hljs-comment">// 此处会报错，error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br><br><span class="hljs-comment">// 声明可变变量</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">y</span> = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>y = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of y is: &#123;&#125;&quot;</span>, y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量-constant"><a href="#常量-constant" class="headerlink" title="常量(constant)"></a>常量(constant)</h2><ul><li>常量不允许使用<code>mut</code></li><li><strong>常量不仅仅默认不可变，而且自始至终不可变</strong></li><li>常量使用 <code>const</code> 关键字而不是 <code>let</code> 关键字来声明</li><li>必须显示指定数据类型</li><li>Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词</li><li>必须使用常量表达式进行赋值，即必须是编译期能计算出的值</li><li>常量不支持重定义（遮蔽），这和变量是不同的</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 常量声明</span><br><span class="hljs-keyword">const</span> MAX_COUNT: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is: &#123;&#125;&quot;</span>, MAX_COUNT);<br></code></pre></td></tr></table></figure><h3 id="不可变变量和常量的区别？"><a href="#不可变变量和常量的区别？" class="headerlink" title="不可变变量和常量的区别？"></a>不可变变量和常量的区别？</h3><ul><li>常量使用 <code>const</code> 进行声明，不可变变量使用 <code>let</code> 进行声明 。</li><li>常量在编译期就确定了值，不能在运行时改变。不可变变量直到运行期来能确定下来。</li><li>常量不可以修改，不可变变量可以通过 <code>shadowing</code> 来修改。</li><li>常量必须声明类型，不可变变量不需要声明类型</li><li>常量必须使用大写字母，不可变变量不需要</li></ul><h2 id="静态变量-Static"><a href="#静态变量-Static" class="headerlink" title="静态变量 (Static)"></a>静态变量 (Static)</h2><ul><li>静态变量使用 <code>static</code> 关键字进行声明并在编译时分配内存，并且在程序运行期间一直存在</li><li>静态变量可以在整个程序中共享，并且可以在多个线程之间共享。</li><li>静态变量的值在程序运行期间不会改变，因此它们通常用于存储程序的全局状态</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 声明一个静态变量</span><br><span class="hljs-keyword">static</span> NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 声明一个可变的静态变量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER2: <span class="hljs-type">i32</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of NUM is: &#123;&#125;&quot;</span>, NUM); <span class="hljs-comment">// The value of NUM is: 5</span><br><br><span class="hljs-title function_ invoke__">change_counter_static</span>();<br><span class="hljs-title function_ invoke__">change_counter_static_unsafe</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change_counter_static</span>() &#123;<br>COUNTER += <span class="hljs-number">1</span>; <span class="hljs-comment">// error[E0133]: use of mutable static is unsafe and requires unsafe function or block</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of COUNTER is: &#123;&#125;&quot;</span>, COUNTER);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">change_counter_static_unsafe</span>() &#123;<br><span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-comment">// 需要用 unsafe 包裹才生效</span><br>COUNTER += <span class="hljs-number">1</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of COUNTER is: &#123;&#125;&quot;</span>, COUNTER);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与常量的相似点"><a href="#与常量的相似点" class="headerlink" title="与常量的相似点"></a>与常量的相似点</h3><ul><li>名称都要求使用大写，否则会报 Warning</li><li>都必须明确指定类型</li><li>都要求必须使用常量表达式进行赋值，即必须是编译期能计算出的值</li><li>都不支持重定义(遮蔽)，这和变量是不同的</li></ul><h3 id="与常量的区别"><a href="#与常量的区别" class="headerlink" title="与常量的区别"></a>与常量的区别</h3><ul><li>定义关键字: 静态变量使用 <code>static</code>，常量使用 <code>const</code></li><li>常量在编译时被内联，但静态变量不会。在整个程序中静态变量只有一个实例，也就是说所有引用都指向同一个地址。</li><li>常量不可变，而静态变量和普通变量一样，默认不可变但可以通过 <code>mut</code> 关键字定义为可变</li></ul><h2 id="变量遮蔽-variable-shadowing"><a href="#变量遮蔽-variable-shadowing" class="headerlink" title="变量遮蔽(variable shadowing)"></a>变量遮蔽(variable shadowing)</h2><p>变量绑定有一个作用域(scope)，它被限定只在一个代码块(block)中生存(live)。 代码块是一个被 {}包围的语句集合。另外也允许变量遮蔽(variable shadowing)</p><p>Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// 在main函数的作用域内对之前的x进行遮蔽</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x + <span class="hljs-number">1</span>;<br><br>    &#123;<br>        <span class="hljs-comment">// 在当前的花括号作用域内，对之前的x进行遮蔽</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x * <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);<br>&#125;<br></code></pre></td></tr></table></figure><p>将输出以下内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">The value of x <span class="hljs-keyword">in</span> the inner scope is: 12<br>The value of x is: 6<br></code></pre></td></tr></table></figure><p>这和 <code>mut</code> 变量的使用是不同的，第二个 <code>let</code> 生成了完全不同的新变量，两个变量只是恰好拥有同样的名称，涉及一次内存对象的再分配 ，而 <code>mut</code> 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好。</p><p><strong>变量遮蔽的用处</strong>在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust 基础入门 - Day 1 环境搭建</title>
    <link href="/2024/10/29/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%201%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/10/29/Rust%20%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20Day%201%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-Rust-环境"><a href="#安装-Rust-环境" class="headerlink" title="安装 Rust 环境"></a>安装 <strong>Rust</strong> 环境</h2><h3 id="安装-rustup"><a href="#安装-rustup" class="headerlink" title="安装 rustup"></a>安装 <code>rustup</code></h3><p>打开终端并输入下面命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl --proto <span class="hljs-string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh<br></code></pre></td></tr></table></figure><p>如果安装成功，将出现下面这行:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">Rust is installed now. Great!<br></code></pre></td></tr></table></figure><p><strong>可能出现的问题</strong></p><ul><li>下载源速度很慢，解决方案：1. 选择镜像站 2. 使用代理&#x2F;VPN等</li></ul><h3 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h3><p>检查是否正确安装了 Rust，可打开终端并输入下面这行，此时能看到最新发布的稳定版本的版本号、提交哈希值和提交日期：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustc -V<br>rustc 1.81.0 (eeb90cda1 2024-09-04)<br><br>cargo -V<br>cargo 1.81.0 (2dbb1af80 2024-08-20)<br></code></pre></td></tr></table></figure><h3 id="rustup常用命令"><a href="#rustup常用命令" class="headerlink" title="rustup常用命令"></a><code>rustup</code>常用命令</h3><ul><li>更新：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup update<br></code></pre></td></tr></table></figure></li><li>卸载<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup self uninstall<br></code></pre></td></tr></table></figure></li><li>本地文档，让浏览器打开本地文档<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustup doc<br></code></pre></td></tr></table></figure></li></ul><h2 id="VS-Code-插件推荐"><a href="#VS-Code-插件推荐" class="headerlink" title="VS Code 插件推荐"></a>VS Code 插件推荐</h2><ol><li><a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer</a>，社区驱动的</li><li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Even Better TOML</a>，支持 <code>.toml</code> 文件的完整特性</li><li><a href="https://marketplace.visualstudio.com/items?itemName=tamasfe.even-better-toml">Dependi</a>，依赖管理工具，代替<code>crates</code></li></ol><h2 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h2><h3 id="编写-Rust-代码"><a href="#编写-Rust-代码" class="headerlink" title="编写 Rust 代码"></a>编写 Rust 代码</h3><p>新建一个源文件，Rust 源文件总是以 <code>.rs</code> 扩展名结尾。如果文件名包含多个单词，那么按照命名习惯，应当使用下划线来分隔单词。例如命名为 <code>hello_world.rs</code>，而不是 <code>helloworld.rs</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> hello_world<br><span class="hljs-built_in">cd</span> hello_world<br><span class="hljs-built_in">touch</span> main.rs<br></code></pre></td></tr></table></figure><p>打开刚创建的<code>main.rs</code> 文件，输入示例 1-1 代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>在运行 Rust 程序之前，必须先使用 Rust 编译器编译它，即输入 <code>rustc</code> 命令并传入源文件名称，如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">rustc main.rs<br></code></pre></td></tr></table></figure><p>编译成功后，Rust会输出一个二进制的可执行文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">ls</span><br>main main.rs<br></code></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>Rust 是一种 <strong>预编译静态类型(ahead-of-time compiled)语言</strong>，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">./main<br>Hello, World!<br></code></pre></td></tr></table></figure><h2 id="认识Cargo"><a href="#认识Cargo" class="headerlink" title="认识Cargo"></a>认识Cargo</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">cargo new hello_cargo<br><span class="hljs-built_in">cd</span> hello_cargo<br></code></pre></td></tr></table></figure><p>初始化的项目结构</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ tree<br>.<br>├── .git<br>├── .gitignore<br>├── Cargo.toml<br>└── src<br>    └── main.rs<br><br></code></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>有两种方式可以运行项目：</p><ol><li><p><code>cargo run</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ cargo run<br>   Compiling hello_cargo v0.1.0 (/Users/vic9527/Documents/rust/hello_cargo)<br>    Finished `dev` profile [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.29s<br>     Running `target/debug/hello_cargo`<br>Hello, Cargo!<br></code></pre></td></tr></table></figure></li><li><p>手动编译和运行项目<br>编译</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ cargo build<br>    Finished `dev` profile [unoptimized + debuginfo] target(s) <span class="hljs-keyword">in</span> 0.02s<br>    <br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">❯ ./target/debug/hello_cargo<br>Hello, Cargo!<br></code></pre></td></tr></table></figure></li></ol><h3 id="发布构建"><a href="#发布构建" class="headerlink" title="发布构建"></a>发布构建</h3><p>当项目最终准备好发布时，可以使用 <code>cargo build --release</code> 来优化编译项目</p><ul><li><p><code>debug</code>模式，<strong>代码的编译速度会非常快</strong>，但是<strong>运行速度就慢了</strong>。原因是，在 <code>debug</code> 模式下，Rust 编译器不会做任何的优化，只为了尽快的编译完成，让你的开发流程更加顺畅。</p></li><li><p><code>release</code>模式，<strong>高性能模式</strong>，为用户构建最终程序</p><ul><li><code>cargo run --release</code></li><li><code>cargo build --release</code></li></ul></li></ul><h3 id="Cargo-toml-和-Cargo-lock"><a href="#Cargo-toml-和-Cargo-lock" class="headerlink" title="Cargo.toml 和 Cargo.lock"></a>Cargo.toml 和 Cargo.lock</h3><p><code>Cargo.toml</code> 和 <code>Cargo.lock</code> 是 <code>cargo</code> 的核心文件，它的所有活动均基于此二者。</p><ul><li><p><code>Cargo.toml</code> 是 <code>cargo</code> 特有的<strong>项目数据描述文件</strong>。它存储了项目的所有元配置信息，如果 Rust 开发者希望 Rust 项目能够按照期望的方式进行构建、测试和运行，那么，必须按照合理的方式构建 <code>Cargo.toml</code>。</p></li><li><p><code>Cargo.lock</code> 文件是 <code>cargo</code> 工具根据同一项目的 <code>toml</code> 文件生成的<strong>项目依赖详细清单</strong>，因此我们一般不用修改它，只需要对着 <code>Cargo.toml</code> 文件撸就行了。</p><blockquote><p>什么情况下该把 <code>Cargo.lock</code> 上传到 git 仓库里？很简单，当你的项目是一个可运行的程序时，就上传 <code>Cargo.lock</code>，如果是一个依赖库项目，那么请把它添加到 <code>.gitignore</code> 中。</p></blockquote></li></ul><h3 id="package-配置段落"><a href="#package-配置段落" class="headerlink" title="package 配置段落"></a>package 配置段落</h3><p><code>package</code> 中记录了项目的描述信息，典型的如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;hello_cargo&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>name</code> 字段定义了项目名称</li><li><code>version</code> 字段定义当前版本，新项目默认是 <code>0.1.0</code></li><li><code>edition</code> 字段定义了我们使用的 Rust 大版本</li></ul><h3 id="定义项目依赖"><a href="#定义项目依赖" class="headerlink" title="定义项目依赖"></a>定义项目依赖</h3><p>使用 <code>cargo</code> 工具的最大优势就在于，能够对该项目的各种依赖项进行方便、统一和灵活的管理。</p><p>在 <code>Cargo.toml</code> 中，主要通过各种依赖段落来描述该项目的各种依赖项：</p><ul><li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li><li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li><li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li></ul><p>这三种形式具体写法如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">rand</span> = <span class="hljs-string">&quot;0.3&quot;</span><br><span class="hljs-attr">hammer</span> = &#123; version = <span class="hljs-string">&quot;0.5.0&quot;</span>&#125;<br><span class="hljs-attr">color</span> = &#123; git = <span class="hljs-string">&quot;https://github.com/bjz/color-rs&quot;</span> &#125;<br><span class="hljs-attr">geometry</span> = &#123; path = <span class="hljs-string">&quot;crates/geometry&quot;</span> &#125;<br></code></pre></td></tr></table></figure><h2 id="下载依赖太慢"><a href="#下载依赖太慢" class="headerlink" title="下载依赖太慢"></a>下载依赖太慢</h2><ol><li><p>科技上网，不赘述</p></li><li><p>修改下载镜像</p><p> 修改配置文件，文件位置<code>$HOME/.cargo/config.toml</code></p></li></ol><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-comment"># 选择的镜像源</span><br><span class="hljs-comment"># 喜欢哪个用哪个吧，没有注释掉的那个就是你选择的</span><br><span class="hljs-comment">#replace-with = &#x27;ustc&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;tuna&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;sjtu&#x27;</span><br><span class="hljs-comment">#replace-with = &#x27;rustcc&#x27;</span><br><span class="hljs-attr">replace-with</span> = <span class="hljs-string">&#x27;aliyun&#x27;</span><br><br><span class="hljs-comment"># 源码地址</span><br><span class="hljs-section">[source.crates-io]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 镜像地址</span><br><span class="hljs-comment"># 清华大学</span><br><span class="hljs-section">[source.tuna]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><br><span class="hljs-comment"># 中国科学技术大学</span><br><span class="hljs-section">[source.ustc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 上海交通大学</span><br><span class="hljs-section">[source.sjtu]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><br><span class="hljs-comment"># rustcc社区</span><br><span class="hljs-section">[source.rustcc]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br><br><span class="hljs-comment"># 阿里云</span><br><span class="hljs-section">[source.aliyun]</span><br><span class="hljs-attr">registry</span> = <span class="hljs-string">&quot;https://code.aliyun.com/rustcc/crates.io-index&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
